import {
  writable
} from "./chunk-DY7FSUYH.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  afterUpdate,
  append_hydration_dev,
  assign,
  attr_dev,
  beforeUpdate,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_custom_element_data_map,
  set_data_dev,
  set_svg_attributes,
  space,
  svg_element,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-K6MJRMI7.js";

// node_modules/konsta/shared/esm/cls.js
function cls() {
  const classes = [];
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  args.forEach((arg) => {
    if (typeof arg === "object" && arg.constructor === Object) {
      Object.keys(arg).forEach((key) => {
        if (arg[key])
          classes.push(key);
      });
    } else if (Array.isArray(arg)) {
      classes.push(...arg);
    } else if (typeof arg === "function") {
      classes.push(arg());
    } else if (arg && arg.value) {
      classes.push(arg.value);
    } else if (arg)
      classes.push(arg);
  });
  const uniqueClasses = [];
  classes.forEach((c) => {
    if (uniqueClasses.indexOf(c) < 0)
      uniqueClasses.push(c);
  });
  return uniqueClasses.filter((c) => !!c).join(" ");
}

// node_modules/konsta/shared/esm/position-class.js
var positionClass = function(position, className) {
  if (className === void 0) {
    className = "";
  }
  if (!className || typeof className !== "string")
    return position;
  const classes = ["static", "relative", "absolute", "fixed", "sticky"];
  const hasPositionClass = classes.filter((c) => className.indexOf(c) >= 0).length > 0;
  return hasPositionClass ? "" : position;
};

// node_modules/konsta/shared/esm/classes/AppClasses.js
var AppClasses = (props, currentTheme, classes) => {
  const {
    safeAreas
  } = props;
  return cls(currentTheme === "ios" && `k-ios`, currentTheme === "material" && "k-material", "k-app w-full h-full min-h-screen", safeAreas && "safe-areas", positionClass("relative", classes), classes);
};

// node_modules/konsta/svelte/shared/KonstaStore.js
var KonstaStore = writable({
  theme: "material",
  dark: true,
  touchRipple: true
});

// node_modules/konsta/svelte/shared/KonstaProvider.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("KonstaProvider", slots, ["default"]);
  let { theme } = $$props;
  let { dark = false } = $$props;
  let { touchRipple = true } = $$props;
  let { autoThemeDetection = true } = $$props;
  let currentTheme = theme;
  const updateStore = () => {
    KonstaStore.set({ theme: currentTheme, dark, touchRipple });
  };
  const calcTheme = () => {
    if (!autoThemeDetection)
      return;
    if (theme === "ios" || theme === "material") {
      if (currentTheme !== theme) {
        currentTheme = theme;
        updateStore();
      }
    } else if (currentTheme === "parent" && typeof window !== "undefined" && typeof document !== "undefined") {
      const htmlEl = document.documentElement;
      if (htmlEl) {
        if (htmlEl.classList.contains("ios")) {
          currentTheme = "ios";
          updateStore();
        } else if (htmlEl.classList.contains("md") || htmlEl.classList.contains("material")) {
          currentTheme = "material";
          updateStore();
        }
      }
    }
  };
  afterUpdate(() => {
    calcTheme();
  });
  calcTheme();
  updateStore();
  $$self.$$.on_mount.push(function() {
    if (theme === void 0 && !("theme" in $$props || $$self.$$.bound[$$self.$$.props["theme"]])) {
      console.warn("<KonstaProvider> was created without expected prop 'theme'");
    }
  });
  const writable_props = ["theme", "dark", "touchRipple", "autoThemeDetection"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<KonstaProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("dark" in $$props2)
      $$invalidate(1, dark = $$props2.dark);
    if ("touchRipple" in $$props2)
      $$invalidate(2, touchRipple = $$props2.touchRipple);
    if ("autoThemeDetection" in $$props2)
      $$invalidate(3, autoThemeDetection = $$props2.autoThemeDetection);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    KonstaStore,
    theme,
    dark,
    touchRipple,
    autoThemeDetection,
    currentTheme,
    updateStore,
    calcTheme
  });
  $$self.$inject_state = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("dark" in $$props2)
      $$invalidate(1, dark = $$props2.dark);
    if ("touchRipple" in $$props2)
      $$invalidate(2, touchRipple = $$props2.touchRipple);
    if ("autoThemeDetection" in $$props2)
      $$invalidate(3, autoThemeDetection = $$props2.autoThemeDetection);
    if ("currentTheme" in $$props2)
      currentTheme = $$props2.currentTheme;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [theme, dark, touchRipple, autoThemeDetection, $$scope, slots];
}
var KonstaProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      theme: 0,
      dark: 1,
      touchRipple: 2,
      autoThemeDetection: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "KonstaProvider",
      options,
      id: create_fragment.name
    });
  }
  get theme() {
    throw new Error("<KonstaProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<KonstaProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dark() {
    throw new Error("<KonstaProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dark(value) {
    throw new Error("<KonstaProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<KonstaProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<KonstaProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoThemeDetection() {
    throw new Error("<KonstaProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoThemeDetection(value) {
    throw new Error("<KonstaProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var KonstaProvider_default = KonstaProvider;

// node_modules/konsta/svelte/components/App.svelte
var file = "node_modules/konsta/svelte/components/App.svelte";
function create_default_slot(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 70, 2, 1563);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(65:0) <KonstaProvider   theme={currentTheme}   {dark}   {touchRipple}   autoThemeDetection={false} >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let konstaprovider;
  let current;
  konstaprovider = new KonstaProvider_default({
    props: {
      theme: (
        /*currentTheme*/
        ctx[2]
      ),
      dark: (
        /*dark*/
        ctx[0]
      ),
      touchRipple: (
        /*touchRipple*/
        ctx[1]
      ),
      autoThemeDetection: false,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(konstaprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(konstaprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(konstaprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const konstaprovider_changes = {};
      if (dirty & /*currentTheme*/
      4)
        konstaprovider_changes.theme = /*currentTheme*/
        ctx2[2];
      if (dirty & /*dark*/
      1)
        konstaprovider_changes.dark = /*dark*/
        ctx2[0];
      if (dirty & /*touchRipple*/
      2)
        konstaprovider_changes.touchRipple = /*touchRipple*/
        ctx2[1];
      if (dirty & /*$$scope, classes, $$restProps*/
      536) {
        konstaprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      konstaprovider.$set(konstaprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(konstaprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(konstaprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(konstaprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "theme", "dark", "touchRipple", "safeAreas"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("App", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { theme = "material" } = $$props;
  let { dark = true } = $$props;
  let { touchRipple = true } = $$props;
  let { safeAreas = true } = $$props;
  let currentTheme = theme;
  const updateStore = () => {
    KonstaStore.set({ theme: currentTheme, dark, touchRipple });
  };
  const calcTheme = () => {
    if (theme === "ios" || theme === "material") {
      if (currentTheme !== theme) {
        $$invalidate(2, currentTheme = theme);
        updateStore();
      }
    } else if (currentTheme === "parent" && typeof window !== "undefined" && typeof document !== "undefined") {
      const htmlEl = document.documentElement;
      if (htmlEl) {
        if (htmlEl.classList.contains("ios")) {
          $$invalidate(2, currentTheme = "ios");
          updateStore();
        } else if (htmlEl.classList.contains("md") || htmlEl.classList.contains("material")) {
          $$invalidate(2, currentTheme = "material");
          updateStore();
        }
      }
    }
  };
  afterUpdate(() => {
    calcTheme();
  });
  calcTheme();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("theme" in $$new_props)
      $$invalidate(6, theme = $$new_props.theme);
    if ("dark" in $$new_props)
      $$invalidate(0, dark = $$new_props.dark);
    if ("touchRipple" in $$new_props)
      $$invalidate(1, touchRipple = $$new_props.touchRipple);
    if ("safeAreas" in $$new_props)
      $$invalidate(7, safeAreas = $$new_props.safeAreas);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    AppClasses,
    KonstaProvider: KonstaProvider_default,
    KonstaStore,
    className,
    theme,
    dark,
    touchRipple,
    safeAreas,
    currentTheme,
    updateStore,
    calcTheme,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("theme" in $$props)
      $$invalidate(6, theme = $$new_props.theme);
    if ("dark" in $$props)
      $$invalidate(0, dark = $$new_props.dark);
    if ("touchRipple" in $$props)
      $$invalidate(1, touchRipple = $$new_props.touchRipple);
    if ("safeAreas" in $$props)
      $$invalidate(7, safeAreas = $$new_props.safeAreas);
    if ("currentTheme" in $$props)
      $$invalidate(2, currentTheme = $$new_props.currentTheme);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*theme, dark, touchRipple, safeAreas, currentTheme, className*/
    231) {
      $:
        $$invalidate(3, classes = AppClasses({ theme, dark, touchRipple, safeAreas }, currentTheme, className));
    }
  };
  return [
    dark,
    touchRipple,
    currentTheme,
    classes,
    $$restProps,
    className,
    theme,
    safeAreas,
    slots,
    $$scope
  ];
}
var App = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      class: 5,
      theme: 6,
      dark: 0,
      touchRipple: 1,
      safeAreas: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "App",
      options,
      id: create_fragment2.name
    });
  }
  get class() {
    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dark() {
    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dark(value) {
    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get safeAreas() {
    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set safeAreas(value) {
    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var App_default = App;

// node_modules/konsta/shared/esm/classes/ActionsClasses.js
var ActionsClasses = (props, classes) => {
  return {
    base: {
      common: cls("transition-transform z-40 left-1/2 bottom-0 transform -translate-x-1/2 max-w-md w-full overflow-hidden", positionClass("fixed", classes)),
      ios: "pt-2 px-2 pb-2-safe duration-300",
      material: "pb-safe last-child-hairline-b-none rounded-t-2xl duration-400 ease-material-in",
      opened: "",
      closed: "translate-y-full"
    },
    backdrop: {
      common: "fixed z-40 w-full h-full left-0 top-0 bg-black bg-opacity-50 duration-300",
      opened: "",
      closed: "opacity-0 pointer-events-none"
    }
  };
};

// node_modules/konsta/svelte/shared/use-theme-classes.js
var propClasses = (classesObj, theme, state) => {
  if (typeof classesObj === "string")
    return classesObj;
  const arr = [classesObj.common, classesObj[theme]];
  if (state && classesObj[state]) {
    if (typeof classesObj[state] === "string")
      arr.push(classesObj[state]);
    else {
      arr.push(classesObj[state].common, classesObj[state][theme]);
    }
  }
  return arr;
};
var themeClasses = (classesObj, theme, addBaseClassName) => {
  const c = {};
  const themeSubKeys = ["common", "ios", "material"];
  Object.keys(classesObj).forEach((key) => {
    const addBaseClass = key === "base" ? addBaseClassName : "";
    const hasStates = typeof classesObj[key] !== "string" && Object.keys(classesObj[key]).filter(
      (state) => !themeSubKeys.includes(state)
    ).length > 0;
    if (!hasStates) {
      c[key] = cls(propClasses(classesObj[key], theme), addBaseClass);
      return;
    }
    c[key] = {};
    const defaultStateClasses = propClasses(classesObj[key], theme);
    c[key].default = cls(defaultStateClasses, addBaseClass);
    Object.keys(classesObj[key]).filter((state) => !themeSubKeys.includes(state)).forEach((state) => {
      c[key][state] = cls(
        defaultStateClasses,
        propClasses(classesObj[key], theme, state),
        addBaseClass
      );
    });
  });
  return c;
};
var useThemeClasses = (props, classesObj, addBaseClassName = "", cb) => {
  let theme = get_store_value(KonstaStore).theme;
  const calcClasses = () => {
    return themeClasses(
      typeof classesObj === "function" ? classesObj() : classesObj,
      theme,
      addBaseClassName
    );
  };
  if (props.ios)
    theme = "ios";
  else if (props.material)
    theme = "material";
  else {
    KonstaStore.subscribe((context) => {
      theme = context.theme || "ios";
      if (cb) {
        cb(calcClasses());
      }
    });
  }
  return calcClasses();
};

// node_modules/konsta/svelte/components/Actions.svelte
var file2 = "node_modules/konsta/svelte/components/Actions.svelte";
function create_if_block(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[2].backdrop[
        /*state*/
        ctx[3]
      ]);
      add_location(div, file2, 24, 2, 575);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onBackdropClick*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*c, state*/
      12 && div_class_value !== (div_class_value = /*c*/
      ctx[2].backdrop[
        /*state*/
        ctx[3]
      ])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:0) {#if backdrop}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let t;
  let div;
  let div_class_value;
  let current;
  let if_block = (
    /*backdrop*/
    ctx[0] && create_if_block(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[2].base[
        /*state*/
        ctx[3]
      ]
    },
    /*$$restProps*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 26, 0, 642);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*backdrop*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c, state*/
        12 && div_class_value !== (div_class_value = /*c*/
        ctx2[2].base[
          /*state*/
          ctx2[3]
        ])) && { class: div_class_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let state;
  let c;
  const omit_props_names = ["class", "ios", "material", "opened", "backdrop", "onBackdropClick"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Actions", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { opened = void 0 } = $$props;
  let { backdrop = true } = $$props;
  let { onBackdropClick = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("ios" in $$new_props)
      $$invalidate(6, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(7, material = $$new_props.material);
    if ("opened" in $$new_props)
      $$invalidate(8, opened = $$new_props.opened);
    if ("backdrop" in $$new_props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$new_props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ActionsClasses,
    useThemeClasses,
    className,
    ios,
    material,
    opened,
    backdrop,
    onBackdropClick,
    c,
    state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("ios" in $$props)
      $$invalidate(6, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(7, material = $$new_props.material);
    if ("opened" in $$props)
      $$invalidate(8, opened = $$new_props.opened);
    if ("backdrop" in $$props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("c" in $$props)
      $$invalidate(2, c = $$new_props.c);
    if ("state" in $$props)
      $$invalidate(3, state = $$new_props.state);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*opened*/
    256) {
      $:
        $$invalidate(3, state = opened ? "opened" : "closed");
    }
    if ($$self.$$.dirty & /*ios, material, className*/
    224) {
      $:
        $$invalidate(2, c = useThemeClasses({ ios, material }, ActionsClasses({}), className, (v) => $$invalidate(2, c = v)));
    }
  };
  return [
    backdrop,
    onBackdropClick,
    c,
    state,
    $$restProps,
    className,
    ios,
    material,
    opened,
    $$scope,
    slots
  ];
}
var Actions = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      class: 5,
      ios: 6,
      material: 7,
      opened: 8,
      backdrop: 0,
      onBackdropClick: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Actions",
      options,
      id: create_fragment3.name
    });
  }
  get class() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBackdropClick() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBackdropClick(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Actions_default = Actions;

// node_modules/konsta/shared/esm/classes/ActionsButtonClasses.js
var ActionsButtonClasses = (props, colors, darkClasses) => {
  const {
    fontSizeIos,
    fontSizeMaterial,
    bold,
    dividers
  } = props;
  return {
    base: {
      common: cls(`flex items-center w-full px-4 relative z-10 overflow-hidden`, dividers && "hairline-b"),
      ios: cls(`h-14`, colors.textIos, colors.bgIos, colors.activeBgIos, fontSizeIos, "first:rounded-t-xl last:rounded-b-xl justify-center", bold && "font-semibold"),
      material: cls(`h-12`, colors.textMaterial, colors.bgMaterial, colors.activeBgMaterial, fontSizeMaterial, "justify-start", darkClasses("dark:touch-ripple-white"), bold && "font-medium")
    }
  };
};

// node_modules/konsta/shared/esm/colors/ActionsButtonColors.js
var ActionsButtonColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: cls("bg-white", dark("dark:bg-neutral-800")),
    bgMaterial: cls("bg-md-light-surface-3", dark("dark:bg-md-dark-surface-3")),
    activeBgIos: cls("active:bg-neutral-200", dark("dark:active:bg-neutral-700")),
    activeBgMaterial: "",
    textIos: "text-primary",
    textMaterial: cls("text-md-light-on-surface", dark("dark:text-md-dark-on-surface")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/shared/use-theme.js
var useTheme = (props, cb) => {
  let ios;
  let material;
  if (typeof props === "function") {
    cb = props;
    props = {};
  } else {
    ios = props.ios;
    material = props.material;
  }
  const calcTheme = (ctx) => {
    let theme = ctx.theme || "ios";
    if (ios)
      theme = "ios";
    if (material)
      theme = "material";
    return theme;
  };
  if (cb) {
    KonstaStore.subscribe((newValue) => {
      cb(calcTheme(newValue));
    });
  }
  return calcTheme(get_store_value(KonstaStore));
};

// node_modules/konsta/svelte/shared/use-dark-classes.js
var useDarkClasses = () => {
  return (classNames) => {
    const context = get_store_value(KonstaStore);
    if (!context.dark)
      return "";
    return classNames;
  };
};

// node_modules/konsta/shared/esm/touch-ripple-class.js
var TouchRipple = class {
  constructor(el, x, y) {
    const ripple = this;
    if (!el)
      return void 0;
    ripple.el = el;
    const {
      left,
      top,
      width,
      height
    } = el.getBoundingClientRect();
    const center = {
      x: x - left,
      y: y - top
    };
    let diameter = Math.max((height ** 2 + width ** 2) ** 0.5, 48);
    const isInset = el.classList.contains("k-touch-ripple-inset");
    if (isInset) {
      diameter = Math.max(Math.min(width, height), 48);
    }
    const isOverflowHidden = typeof window !== "undefined" && window.getComputedStyle(el, null).getPropertyValue("overflow") === "hidden";
    if (!isInset && isOverflowHidden) {
      const distanceFromCenter = ((center.x - width / 2) ** 2 + (center.y - height / 2) ** 2) ** 0.5;
      const scale = (diameter / 2 + distanceFromCenter) / (diameter / 2);
      ripple.rippleTransform = `translate3d(0px, 0px, 0) scale(${scale})`;
    } else {
      ripple.rippleTransform = `translate3d(${-center.x + width / 2}px, ${-center.y + height / 2}px, 0) scale(1)`;
    }
    ripple.rippleWaveEl = document.createElement("span");
    ripple.rippleWaveEl.classList.add("k-touch-ripple-wave");
    ripple.rippleWaveEl.setAttribute("hidden", "");
    ripple.rippleWaveEl.style = `
      width: ${diameter}px;
      height: ${diameter}px;
      margin-top:-${diameter / 2}px;
      margin-left:-${diameter / 2}px;
      left:${center.x}px;
      top:${center.y}px; --k-ripple-transform: ${ripple.rippleTransform}`;
    el.insertAdjacentElement("afterbegin", ripple.rippleWaveEl);
    const animationEnd = () => {
      ripple.rippleWaveEl.removeEventListener("animationend", animationEnd);
      if (!ripple.rippleWaveEl)
        return;
      if (ripple.rippleWaveEl.classList.contains("k-touch-ripple-wave-out"))
        return;
      ripple.rippleWaveEl.classList.add("k-touch-ripple-wave-in");
      if (ripple.shouldBeRemoved) {
        ripple.out();
      }
    };
    ripple.rippleWaveEl.addEventListener("animationend", animationEnd);
    return ripple;
  }
  destroy() {
    let ripple = this;
    if (ripple.rippleWaveEl) {
      ripple.el.removeChild(ripple.rippleWaveEl);
    }
    Object.keys(ripple).forEach((key) => {
      ripple[key] = null;
      delete ripple[key];
    });
    ripple = null;
  }
  out() {
    const ripple = this;
    const {
      rippleWaveEl
    } = this;
    clearTimeout(ripple.removeTimeout);
    rippleWaveEl.classList.add("k-touch-ripple-wave-out");
    ripple.removeTimeout = setTimeout(() => {
      ripple.destroy();
    }, 300);
    const animationEnd = () => {
      ripple.rippleWaveEl.removeEventListener("animationend", animationEnd);
      clearTimeout(ripple.removeTimeout);
      ripple.destroy();
    };
    ripple.rippleWaveEl.addEventListener("animationend", animationEnd);
  }
  remove() {
    const ripple = this;
    if (ripple.shouldBeRemoved)
      return;
    ripple.removeTimeout = setTimeout(() => {
      ripple.destroy();
    }, 400);
    ripple.shouldBeRemoved = true;
    if (ripple.rippleWaveEl.classList.contains("k-touch-ripple-wave-in")) {
      ripple.out();
    }
  }
};

// node_modules/konsta/svelte/shared/use-touch-ripple.js
var useTouchRipple = (el, touchRipple, eventsEl) => {
  if (!eventsEl)
    eventsEl = el;
  const needsTouchRipple = () => {
    return touchRipple && get_store_value(KonstaStore).theme === "material" && get_store_value(KonstaStore).touchRipple;
  };
  let ripple = null;
  const removeRipple = () => {
    if (ripple)
      ripple.remove();
    ripple = null;
  };
  const onPointerDown = (e) => {
    ripple = new TouchRipple(el.current, e.pageX, e.pageY);
  };
  const onPointerMove = () => {
    removeRipple();
  };
  const onPointerUp = () => {
    removeRipple();
  };
  const attachEvents = () => {
    if (!eventsEl || !eventsEl.current || !eventsEl.current.addEventListener || !needsTouchRipple() || eventsEl.__touchRippleAttached__)
      return;
    eventsEl.__touchRippleAttached__ = true;
    eventsEl.current.addEventListener("pointerdown", onPointerDown);
    eventsEl.current.addEventListener("pointermove", onPointerMove);
    eventsEl.current.addEventListener("pointerup", onPointerUp);
    eventsEl.current.addEventListener("pointercancel", onPointerUp);
    eventsEl.current.addEventListener("contextmenu", onPointerUp);
  };
  const detachEvents = (deleteFlag) => {
    if (!eventsEl || !eventsEl.current || !eventsEl.current.addEventListener)
      return;
    if (deleteFlag) {
      delete eventsEl.__touchRippleAttached__;
    }
    eventsEl.current.removeEventListener("pointerdown", onPointerDown);
    eventsEl.current.removeEventListener("pointermove", onPointerMove);
    eventsEl.current.removeEventListener("pointerup", onPointerUp);
    eventsEl.current.removeEventListener("pointercancel", onPointerUp);
    eventsEl.current.removeEventListener("contextmenu", onPointerUp);
  };
  onMount(() => {
    attachEvents();
  });
  beforeUpdate(() => {
    if (!needsTouchRipple()) {
      detachEvents(true);
    }
  });
  onDestroy(() => {
    detachEvents(true);
  });
  KonstaStore.subscribe(() => {
    if (!needsTouchRipple()) {
      detachEvents();
    } else {
      detachEvents();
      attachEvents();
    }
  });
};

// node_modules/konsta/svelte/components/ActionsButton.svelte
var file3 = "node_modules/konsta/svelte/components/ActionsButton.svelte";
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*c*/
      ctx[3].base
    },
    /*attrs*/
    ctx[4]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*Component*/
        ctx[2]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*Component*/
        (ctx[2] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*Component*/
        ctx[2]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file3, 72, 0, 1899);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[24](svelte_element);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          svelte_element,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[22],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*c*/
        8 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx[3].base)) && { class: svelte_element_class_value },
        dirty & /*attrs*/
        16 && /*attrs*/
        ctx[4]
      ]);
      if (/-/.test(
        /*Component*/
        ctx[2]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(73:0) <svelte:element   this={Component}   bind:this={rippleEl.current}   class={c.base}   on:click={onClick}   {...attrs} >",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let previous_tag = (
    /*Component*/
    ctx[2]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*Component*/
    ctx[2]
  );
  validate_void_dynamic_element(
    /*Component*/
    ctx[2]
  );
  let svelte_element = (
    /*Component*/
    ctx[2] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*Component*/
        ctx2[2]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*Component*/
          ctx2[2]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*Component*/
            ctx2[2]
          );
          validate_void_dynamic_element(
            /*Component*/
            ctx2[2]
          );
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*Component*/
      ctx2[2];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let attrs;
  let colors;
  let isDividers;
  let isBold;
  let c;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "component",
    "href",
    "bold",
    "boldIos",
    "boldMaterial",
    "fontSizeIos",
    "fontSizeMaterial",
    "touchRipple",
    "dividers",
    "onClick"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ActionsButton", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "button" } = $$props;
  let { href = void 0 } = $$props;
  let { bold = void 0 } = $$props;
  let { boldIos = false } = $$props;
  let { boldMaterial = false } = $$props;
  let { fontSizeIos = "text-xl" } = $$props;
  let { fontSizeMaterial = "text-base" } = $$props;
  let { touchRipple = true } = $$props;
  let { dividers = true } = $$props;
  let { onClick = void 0 } = $$props;
  const rippleEl = { current: null };
  const dark = useDarkClasses();
  let Component = component;
  if (typeof component === "undefined" && (href || href === "")) {
    Component = "a";
  } else if (typeof component === "undefined") {
    Component = "button";
  }
  let theme;
  theme = useTheme({}, (v) => $$invalidate(18, theme = v));
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(1, rippleEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(6, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(8, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(9, component = $$new_props.component);
    if ("href" in $$new_props)
      $$invalidate(10, href = $$new_props.href);
    if ("bold" in $$new_props)
      $$invalidate(11, bold = $$new_props.bold);
    if ("boldIos" in $$new_props)
      $$invalidate(12, boldIos = $$new_props.boldIos);
    if ("boldMaterial" in $$new_props)
      $$invalidate(13, boldMaterial = $$new_props.boldMaterial);
    if ("fontSizeIos" in $$new_props)
      $$invalidate(14, fontSizeIos = $$new_props.fontSizeIos);
    if ("fontSizeMaterial" in $$new_props)
      $$invalidate(15, fontSizeMaterial = $$new_props.fontSizeMaterial);
    if ("touchRipple" in $$new_props)
      $$invalidate(16, touchRipple = $$new_props.touchRipple);
    if ("dividers" in $$new_props)
      $$invalidate(17, dividers = $$new_props.dividers);
    if ("onClick" in $$new_props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ActionsButtonClasses,
    ActionsButtonColors,
    useThemeClasses,
    useTheme,
    useDarkClasses,
    useTouchRipple,
    className,
    colorsProp,
    ios,
    material,
    component,
    href,
    bold,
    boldIos,
    boldMaterial,
    fontSizeIos,
    fontSizeMaterial,
    touchRipple,
    dividers,
    onClick,
    rippleEl,
    dark,
    Component,
    theme,
    c,
    colors,
    isDividers,
    isBold,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(6, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(8, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(9, component = $$new_props.component);
    if ("href" in $$props)
      $$invalidate(10, href = $$new_props.href);
    if ("bold" in $$props)
      $$invalidate(11, bold = $$new_props.bold);
    if ("boldIos" in $$props)
      $$invalidate(12, boldIos = $$new_props.boldIos);
    if ("boldMaterial" in $$props)
      $$invalidate(13, boldMaterial = $$new_props.boldMaterial);
    if ("fontSizeIos" in $$props)
      $$invalidate(14, fontSizeIos = $$new_props.fontSizeIos);
    if ("fontSizeMaterial" in $$props)
      $$invalidate(15, fontSizeMaterial = $$new_props.fontSizeMaterial);
    if ("touchRipple" in $$props)
      $$invalidate(16, touchRipple = $$new_props.touchRipple);
    if ("dividers" in $$props)
      $$invalidate(17, dividers = $$new_props.dividers);
    if ("onClick" in $$props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("Component" in $$props)
      $$invalidate(2, Component = $$new_props.Component);
    if ("theme" in $$props)
      $$invalidate(18, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(3, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(19, colors = $$new_props.colors);
    if ("isDividers" in $$props)
      $$invalidate(20, isDividers = $$new_props.isDividers);
    if ("isBold" in $$props)
      $$invalidate(21, isBold = $$new_props.isBold);
    if ("attrs" in $$props)
      $$invalidate(4, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*rippleEl, touchRipple*/
    65538) {
      $:
        useTouchRipple(rippleEl, touchRipple);
    }
    $:
      $$invalidate(4, attrs = { href, ...$$restProps });
    if ($$self.$$.dirty & /*colorsProp*/
    64) {
      $:
        $$invalidate(19, colors = ActionsButtonColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*dividers, theme*/
    393216) {
      $:
        $$invalidate(20, isDividers = typeof dividers === "undefined" ? theme === "ios" : dividers);
    }
    if ($$self.$$.dirty & /*bold, theme, boldIos, boldMaterial*/
    276480) {
      $:
        $$invalidate(21, isBold = typeof bold === "undefined" ? theme === "ios" ? boldIos : boldMaterial : bold);
    }
    if ($$self.$$.dirty & /*ios, material, isBold, fontSizeIos, fontSizeMaterial, isDividers, colors, className*/
    3719584) {
      $:
        $$invalidate(3, c = useThemeClasses(
          { ios, material },
          ActionsButtonClasses(
            {
              bold: isBold,
              fontSizeIos,
              fontSizeMaterial,
              dividers: isDividers
            },
            colors,
            dark
          ),
          className,
          (v) => $$invalidate(3, c = v)
        ));
    }
  };
  return [
    onClick,
    rippleEl,
    Component,
    c,
    attrs,
    className,
    colorsProp,
    ios,
    material,
    component,
    href,
    bold,
    boldIos,
    boldMaterial,
    fontSizeIos,
    fontSizeMaterial,
    touchRipple,
    dividers,
    theme,
    colors,
    isDividers,
    isBold,
    $$scope,
    slots,
    svelte_element_binding
  ];
}
var ActionsButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      class: 5,
      colors: 6,
      ios: 7,
      material: 8,
      component: 9,
      href: 10,
      bold: 11,
      boldIos: 12,
      boldMaterial: 13,
      fontSizeIos: 14,
      fontSizeMaterial: 15,
      touchRipple: 16,
      dividers: 17,
      onClick: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ActionsButton",
      options,
      id: create_fragment4.name
    });
  }
  get class() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bold() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bold(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get boldIos() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set boldIos(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get boldMaterial() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set boldMaterial(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSizeIos() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSizeIos(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSizeMaterial() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSizeMaterial(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dividers() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dividers(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<ActionsButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<ActionsButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ActionsButton_default = ActionsButton;

// node_modules/konsta/shared/esm/classes/ActionsLabelClasses.js
var ActionsLabelClasses = (props, colors) => {
  const {
    fontSizeIos,
    fontSizeMaterial,
    dividers
  } = props;
  return {
    base: {
      common: cls(`flex items-center w-full px-4 relative z-10 overflow-hidden ${colors.activeBg}`, dividers && "hairline-b"),
      ios: cls(`h-14`, colors.bgIos, colors.textIos, fontSizeIos, "first:rounded-t-xl last:rounded-b-xl justify-center"),
      material: cls(`h-12`, colors.bgMaterial, colors.textMaterial, fontSizeMaterial, "font-medium", "justify-start")
    }
  };
};

// node_modules/konsta/shared/esm/colors/ActionsLabelColors.js
var ActionsLabelColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: cls("bg-white", dark("dark:bg-neutral-800")),
    bgMaterial: cls("bg-md-light-surface-3", dark("dark:bg-md-dark-surface-3")),
    textIos: cls("text-black text-opacity-55", dark("dark:text-white dark:text-opacity-55")),
    textMaterial: cls("text-md-light-primary", dark("dark:text-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/ActionsLabel.svelte
var file4 = "node_modules/konsta/svelte/components/ActionsLabel.svelte";
function create_fragment5(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[0].base
    },
    /*attrs*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file4, 43, 0, 1168);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c*/
        1 && div_class_value !== (div_class_value = /*c*/
        ctx2[0].base)) && { class: div_class_value },
        dirty & /*attrs*/
        2 && /*attrs*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let attrs;
  let colors;
  let isDividers;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "fontSizeIos", "fontSizeMaterial", "dividers"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ActionsLabel", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { fontSizeIos = "text-sm" } = $$props;
  let { fontSizeMaterial = "text-sm" } = $$props;
  let { dividers = void 0 } = $$props;
  const dark = useDarkClasses();
  let theme;
  theme = useTheme({}, (v) => $$invalidate(9, theme = v));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(3, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(5, material = $$new_props.material);
    if ("fontSizeIos" in $$new_props)
      $$invalidate(6, fontSizeIos = $$new_props.fontSizeIos);
    if ("fontSizeMaterial" in $$new_props)
      $$invalidate(7, fontSizeMaterial = $$new_props.fontSizeMaterial);
    if ("dividers" in $$new_props)
      $$invalidate(8, dividers = $$new_props.dividers);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ActionsLabelClasses,
    ActionsLabelColors,
    useTheme,
    useThemeClasses,
    useDarkClasses,
    className,
    colorsProp,
    ios,
    material,
    fontSizeIos,
    fontSizeMaterial,
    dividers,
    dark,
    theme,
    c,
    colors,
    isDividers,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(3, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(5, material = $$new_props.material);
    if ("fontSizeIos" in $$props)
      $$invalidate(6, fontSizeIos = $$new_props.fontSizeIos);
    if ("fontSizeMaterial" in $$props)
      $$invalidate(7, fontSizeMaterial = $$new_props.fontSizeMaterial);
    if ("dividers" in $$props)
      $$invalidate(8, dividers = $$new_props.dividers);
    if ("theme" in $$props)
      $$invalidate(9, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(0, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(10, colors = $$new_props.colors);
    if ("isDividers" in $$props)
      $$invalidate(11, isDividers = $$new_props.isDividers);
    if ("attrs" in $$props)
      $$invalidate(1, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, attrs = { ...$$restProps });
    if ($$self.$$.dirty & /*colorsProp*/
    8) {
      $:
        $$invalidate(10, colors = ActionsLabelColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*dividers, theme*/
    768) {
      $:
        $$invalidate(11, isDividers = typeof dividers === "undefined" ? theme === "ios" : dividers);
    }
    if ($$self.$$.dirty & /*ios, material, fontSizeIos, fontSizeMaterial, isDividers, colors, className*/
    3316) {
      $:
        $$invalidate(0, c = useThemeClasses(
          { ios, material },
          ActionsLabelClasses(
            {
              fontSizeIos,
              fontSizeMaterial,
              dividers: isDividers
            },
            colors,
            dark
          ),
          className,
          (v) => $$invalidate(0, c = v)
        ));
    }
  };
  return [
    c,
    attrs,
    className,
    colorsProp,
    ios,
    material,
    fontSizeIos,
    fontSizeMaterial,
    dividers,
    theme,
    colors,
    isDividers,
    $$scope,
    slots
  ];
}
var ActionsLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      class: 2,
      colors: 3,
      ios: 4,
      material: 5,
      fontSizeIos: 6,
      fontSizeMaterial: 7,
      dividers: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ActionsLabel",
      options,
      id: create_fragment5.name
    });
  }
  get class() {
    throw new Error("<ActionsLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ActionsLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<ActionsLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<ActionsLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<ActionsLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<ActionsLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<ActionsLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<ActionsLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSizeIos() {
    throw new Error("<ActionsLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSizeIos(value) {
    throw new Error("<ActionsLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSizeMaterial() {
    throw new Error("<ActionsLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSizeMaterial(value) {
    throw new Error("<ActionsLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dividers() {
    throw new Error("<ActionsLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dividers(value) {
    throw new Error("<ActionsLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ActionsLabel_default = ActionsLabel;

// node_modules/konsta/shared/esm/classes/ActionsGroupClasses.js
var ActionsGroupClasses = (props) => {
  const {
    dividers
  } = props;
  return {
    base: {
      common: `relative`,
      ios: `mt-2 first:mt-0 last-child-hairline-b-none`,
      material: cls(dividers && `hairline-b`)
    }
  };
};

// node_modules/konsta/svelte/components/ActionsGroup.svelte
var file5 = "node_modules/konsta/svelte/components/ActionsGroup.svelte";
function create_fragment6(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[0].base
    },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file5, 19, 0, 464);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c*/
        1 && div_class_value !== (div_class_value = /*c*/
        ctx2[0].base)) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let c;
  const omit_props_names = ["class", "ios", "material", "dividers"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ActionsGroup", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { dividers = true } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("ios" in $$new_props)
      $$invalidate(3, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(4, material = $$new_props.material);
    if ("dividers" in $$new_props)
      $$invalidate(5, dividers = $$new_props.dividers);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ActionsGroupClasses,
    useThemeClasses,
    className,
    ios,
    material,
    dividers,
    c
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("ios" in $$props)
      $$invalidate(3, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(4, material = $$new_props.material);
    if ("dividers" in $$props)
      $$invalidate(5, dividers = $$new_props.dividers);
    if ("c" in $$props)
      $$invalidate(0, c = $$new_props.c);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ios, material, dividers, className*/
    60) {
      $:
        $$invalidate(0, c = useThemeClasses({ ios, material }, ActionsGroupClasses({ dividers }), className, (v) => $$invalidate(0, c = v)));
    }
  };
  return [c, $$restProps, className, ios, material, dividers, $$scope, slots];
}
var ActionsGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      class: 2,
      ios: 3,
      material: 4,
      dividers: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ActionsGroup",
      options,
      id: create_fragment6.name
    });
  }
  get class() {
    throw new Error("<ActionsGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ActionsGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<ActionsGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<ActionsGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<ActionsGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<ActionsGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dividers() {
    throw new Error("<ActionsGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dividers(value) {
    throw new Error("<ActionsGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ActionsGroup_default = ActionsGroup;

// node_modules/konsta/shared/esm/classes/BadgeClasses.js
var BadgeClasses = (props, colors) => {
  return {
    base: {
      common: `${colors.text} ${colors.bg} inline-flex items-center justify-center rounded-full leading-none`,
      ios: `font-semibold`,
      material: `font-medium`,
      sm: "text-2xs min-w-4 min-h-4 px-0.5",
      md: "text-xs min-w-5 min-h-5 px-1.5 py-0.5"
    }
  };
};

// node_modules/konsta/shared/esm/colors/BadgeColors.js
var BadgeColors = function(colorsProp) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bg: "bg-primary",
    text: "text-white",
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Badge.svelte
var file6 = "node_modules/konsta/svelte/components/Badge.svelte";
function create_fragment7(ctx) {
  let span;
  let span_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let span_levels = [
    {
      class: span_class_value = /*c*/
      ctx[1].base[
        /*size*/
        ctx[2]
      ]
    },
    /*$$restProps*/
    ctx[3]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file6, 28, 0, 692);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*c, size*/
        6 && span_class_value !== (span_class_value = /*c*/
        ctx[1].base[
          /*size*/
          ctx[2]
        ])) && { class: span_class_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx[3]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let colors;
  let size;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "small", "onClick"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Badge", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { small = false } = $$props;
  let { onClick = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(5, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(6, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(7, material = $$new_props.material);
    if ("small" in $$new_props)
      $$invalidate(8, small = $$new_props.small);
    if ("onClick" in $$new_props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    BadgeClasses,
    BadgeColors,
    useThemeClasses,
    className,
    colorsProp,
    ios,
    material,
    small,
    onClick,
    c,
    colors,
    size
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(5, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(6, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(7, material = $$new_props.material);
    if ("small" in $$props)
      $$invalidate(8, small = $$new_props.small);
    if ("onClick" in $$props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("c" in $$props)
      $$invalidate(1, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(9, colors = $$new_props.colors);
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    32) {
      $:
        $$invalidate(9, colors = BadgeColors(colorsProp));
    }
    if ($$self.$$.dirty & /*small*/
    256) {
      $:
        $$invalidate(2, size = small ? "sm" : "md");
    }
    if ($$self.$$.dirty & /*ios, material, small, colors, className*/
    976) {
      $:
        $$invalidate(1, c = useThemeClasses({ ios, material }, BadgeClasses({ small }, colors), className, (v) => $$invalidate(1, c = v)));
    }
  };
  return [
    onClick,
    c,
    size,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    small,
    colors,
    $$scope,
    slots
  ];
}
var Badge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      class: 4,
      colors: 5,
      ios: 6,
      material: 7,
      small: 8,
      onClick: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Badge",
      options,
      id: create_fragment7.name
    });
  }
  get class() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Badge_default = Badge;

// node_modules/konsta/shared/esm/classes/BlockClasses.js
var BlockClasses = (props, colors, classes) => {
  const {
    inset,
    nested,
    margin,
    padding,
    strong,
    outline
  } = props;
  return {
    base: {
      common: cls(`text-sm z-10`, positionClass("relative", classes), !inset && !nested && outline && "hairline-t hairline-b", inset && outline && "border", inset && "px-4", !inset && "pl-4-safe pr-4-safe", !nested && margin, (strong || outline) && padding),
      ios: cls(colors.textIos, strong && colors.strongBgIos, inset && outline && colors.outlineIos),
      material: cls(colors.textMaterial, strong && colors.strongBgMaterial, inset && outline && colors.outlineMaterial)
    },
    inset: {
      common: `ml-4-safe mr-4-safe overflow-hidden`,
      ios: `rounded-lg`,
      material: `rounded-2xl`
    }
  };
};

// node_modules/konsta/shared/esm/colors/BlockColors.js
var BlockColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    outlineIos: cls("border-black border-opacity-20", dark("dark:border-white dark:border-opacity-15")),
    outlineMaterial: cls("border-md-light-outline", dark("border-md-dark-outline")),
    strongBgIos: cls(`bg-ios-light-surface-1`, dark("dark:bg-ios-dark-surface-1")),
    strongBgMaterial: cls("bg-md-light-surface-1", dark("dark:bg-md-dark-surface-1")),
    textIos: "",
    textMaterial: cls("text-md-light-on-surface", dark("dark:text-md-dark-on-surface")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Block.svelte
var file7 = "node_modules/konsta/svelte/components/Block.svelte";
function create_fragment8(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file7, 84, 0, 1926);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[24],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let isStrong;
  let isOutline;
  let isInset;
  let colors;
  let c;
  let classes;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "margin",
    "padding",
    "inset",
    "insetIos",
    "insetMaterial",
    "strong",
    "strongIos",
    "strongMaterial",
    "outline",
    "outlineIos",
    "outlineMaterial",
    "nested"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Block", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { margin = "my-8" } = $$props;
  let { padding = "py-4" } = $$props;
  let { inset = void 0 } = $$props;
  let { insetIos = false } = $$props;
  let { insetMaterial = false } = $$props;
  let { strong = void 0 } = $$props;
  let { strongIos = false } = $$props;
  let { strongMaterial = false } = $$props;
  let { outline = void 0 } = $$props;
  let { outlineIos = false } = $$props;
  let { outlineMaterial = false } = $$props;
  let { nested = void 0 } = $$props;
  let theme;
  theme = useTheme({}, (v) => $$invalidate(18, theme = v));
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(3, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(5, material = $$new_props.material);
    if ("margin" in $$new_props)
      $$invalidate(6, margin = $$new_props.margin);
    if ("padding" in $$new_props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("inset" in $$new_props)
      $$invalidate(8, inset = $$new_props.inset);
    if ("insetIos" in $$new_props)
      $$invalidate(9, insetIos = $$new_props.insetIos);
    if ("insetMaterial" in $$new_props)
      $$invalidate(10, insetMaterial = $$new_props.insetMaterial);
    if ("strong" in $$new_props)
      $$invalidate(11, strong = $$new_props.strong);
    if ("strongIos" in $$new_props)
      $$invalidate(12, strongIos = $$new_props.strongIos);
    if ("strongMaterial" in $$new_props)
      $$invalidate(13, strongMaterial = $$new_props.strongMaterial);
    if ("outline" in $$new_props)
      $$invalidate(14, outline = $$new_props.outline);
    if ("outlineIos" in $$new_props)
      $$invalidate(15, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$new_props)
      $$invalidate(16, outlineMaterial = $$new_props.outlineMaterial);
    if ("nested" in $$new_props)
      $$invalidate(17, nested = $$new_props.nested);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    BlockClasses,
    BlockColors,
    cls,
    useDarkClasses,
    useTheme,
    useThemeClasses,
    className,
    colorsProp,
    ios,
    material,
    margin,
    padding,
    inset,
    insetIos,
    insetMaterial,
    strong,
    strongIos,
    strongMaterial,
    outline,
    outlineIos,
    outlineMaterial,
    nested,
    theme,
    dark,
    c,
    isInset,
    classes,
    colors,
    isStrong,
    isOutline
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(3, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(5, material = $$new_props.material);
    if ("margin" in $$props)
      $$invalidate(6, margin = $$new_props.margin);
    if ("padding" in $$props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("inset" in $$props)
      $$invalidate(8, inset = $$new_props.inset);
    if ("insetIos" in $$props)
      $$invalidate(9, insetIos = $$new_props.insetIos);
    if ("insetMaterial" in $$props)
      $$invalidate(10, insetMaterial = $$new_props.insetMaterial);
    if ("strong" in $$props)
      $$invalidate(11, strong = $$new_props.strong);
    if ("strongIos" in $$props)
      $$invalidate(12, strongIos = $$new_props.strongIos);
    if ("strongMaterial" in $$props)
      $$invalidate(13, strongMaterial = $$new_props.strongMaterial);
    if ("outline" in $$props)
      $$invalidate(14, outline = $$new_props.outline);
    if ("outlineIos" in $$props)
      $$invalidate(15, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$props)
      $$invalidate(16, outlineMaterial = $$new_props.outlineMaterial);
    if ("nested" in $$props)
      $$invalidate(17, nested = $$new_props.nested);
    if ("theme" in $$props)
      $$invalidate(18, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(19, c = $$new_props.c);
    if ("isInset" in $$props)
      $$invalidate(20, isInset = $$new_props.isInset);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
    if ("colors" in $$props)
      $$invalidate(21, colors = $$new_props.colors);
    if ("isStrong" in $$props)
      $$invalidate(22, isStrong = $$new_props.isStrong);
    if ("isOutline" in $$props)
      $$invalidate(23, isOutline = $$new_props.isOutline);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*strong, theme, strongIos, strongMaterial*/
    276480) {
      $:
        $$invalidate(22, isStrong = typeof strong === "undefined" ? theme === "ios" ? strongIos : strongMaterial : strong);
    }
    if ($$self.$$.dirty & /*outline, theme, outlineIos, outlineMaterial*/
    376832) {
      $:
        $$invalidate(23, isOutline = typeof outline === "undefined" ? theme === "ios" ? outlineIos : outlineMaterial : outline);
    }
    if ($$self.$$.dirty & /*inset, theme, insetIos, insetMaterial*/
    263936) {
      $:
        $$invalidate(20, isInset = typeof inset === "undefined" ? theme === "ios" ? insetIos : insetMaterial : inset);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    8) {
      $:
        $$invalidate(21, colors = BlockColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, margin, padding, nested, isInset, isOutline, isStrong, colors, className*/
    15859956) {
      $:
        $$invalidate(19, c = useThemeClasses(
          { ios, material },
          BlockClasses(
            {
              margin,
              padding,
              nested,
              inset: isInset,
              outline: isOutline,
              strong: isStrong
            },
            colors,
            className
          ),
          "",
          (v) => $$invalidate(19, c = v)
        ));
    }
    if ($$self.$$.dirty & /*c, isInset, className*/
    1572868) {
      $:
        $$invalidate(0, classes = cls(
          // base
          c.base,
          // inset
          isInset && c.inset,
          className
        ));
    }
  };
  return [
    classes,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    margin,
    padding,
    inset,
    insetIos,
    insetMaterial,
    strong,
    strongIos,
    strongMaterial,
    outline,
    outlineIos,
    outlineMaterial,
    nested,
    theme,
    c,
    isInset,
    colors,
    isStrong,
    isOutline,
    $$scope,
    slots
  ];
}
var Block = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      class: 2,
      colors: 3,
      ios: 4,
      material: 5,
      margin: 6,
      padding: 7,
      inset: 8,
      insetIos: 9,
      insetMaterial: 10,
      strong: 11,
      strongIos: 12,
      strongMaterial: 13,
      outline: 14,
      outlineIos: 15,
      outlineMaterial: 16,
      nested: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Block",
      options,
      id: create_fragment8.name
    });
  }
  get class() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get margin() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set margin(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inset() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inset(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetIos() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetIos(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetMaterial() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetMaterial(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strong() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strong(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongIos() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongIos(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongMaterial() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongMaterial(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineIos() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineIos(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineMaterial() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineMaterial(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nested() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nested(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Block_default = Block;

// node_modules/konsta/shared/esm/classes/BlockFooterClasses.js
var BlockFooterClasses = (props, colors) => {
  const {
    inset
  } = props;
  return {
    base: {
      common: cls(`mb-8 flex items-center -mt-6 text-sm`, inset ? "pl-8-safe pr-8-safe" : "pl-4-safe pr-4-safe"),
      ios: colors.textIos,
      material: colors.textMaterial
    }
  };
};

// node_modules/konsta/shared/esm/colors/BlockFooterColors.js
var BlockFooterColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    textIos: cls("text-black text-opacity-75", dark("dark:text-white dark:text-opacity-75")),
    textMaterial: cls("text-md-light-on-surface-variant", dark("dark:text-md-dark-on-surface-variant")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/BlockFooter.svelte
var file8 = "node_modules/konsta/svelte/components/BlockFooter.svelte";
function create_fragment9(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[0].base
    },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file8, 39, 0, 1086);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c*/
        1 && div_class_value !== (div_class_value = /*c*/
        ctx2[0].base)) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let isInset;
  let colors;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "inset", "insetIos", "insetMaterial"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BlockFooter", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { inset = void 0 } = $$props;
  let { insetIos = false } = $$props;
  let { insetMaterial = false } = $$props;
  let theme;
  theme = useTheme({}, (v) => $$invalidate(9, theme = v));
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(3, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(5, material = $$new_props.material);
    if ("inset" in $$new_props)
      $$invalidate(6, inset = $$new_props.inset);
    if ("insetIos" in $$new_props)
      $$invalidate(7, insetIos = $$new_props.insetIos);
    if ("insetMaterial" in $$new_props)
      $$invalidate(8, insetMaterial = $$new_props.insetMaterial);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    BlockFooterClasses,
    BlockFooterColors,
    useTheme,
    useThemeClasses,
    useDarkClasses,
    className,
    colorsProp,
    ios,
    material,
    inset,
    insetIos,
    insetMaterial,
    theme,
    dark,
    c,
    colors,
    isInset
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(3, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(5, material = $$new_props.material);
    if ("inset" in $$props)
      $$invalidate(6, inset = $$new_props.inset);
    if ("insetIos" in $$props)
      $$invalidate(7, insetIos = $$new_props.insetIos);
    if ("insetMaterial" in $$props)
      $$invalidate(8, insetMaterial = $$new_props.insetMaterial);
    if ("theme" in $$props)
      $$invalidate(9, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(0, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(10, colors = $$new_props.colors);
    if ("isInset" in $$props)
      $$invalidate(11, isInset = $$new_props.isInset);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*inset, theme, insetIos, insetMaterial*/
    960) {
      $:
        $$invalidate(11, isInset = typeof inset === "undefined" ? theme === "ios" ? insetIos : insetMaterial : inset);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    8) {
      $:
        $$invalidate(10, colors = BlockFooterColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, isInset, colors, className*/
    3124) {
      $:
        $$invalidate(0, c = useThemeClasses({ ios, material }, BlockFooterClasses({ inset: isInset }, colors), className, (v) => $$invalidate(0, c = v)));
    }
  };
  return [
    c,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    inset,
    insetIos,
    insetMaterial,
    theme,
    colors,
    isInset,
    $$scope,
    slots
  ];
}
var BlockFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      class: 2,
      colors: 3,
      ios: 4,
      material: 5,
      inset: 6,
      insetIos: 7,
      insetMaterial: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BlockFooter",
      options,
      id: create_fragment9.name
    });
  }
  get class() {
    throw new Error("<BlockFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BlockFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<BlockFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<BlockFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<BlockFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<BlockFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<BlockFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<BlockFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inset() {
    throw new Error("<BlockFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inset(value) {
    throw new Error("<BlockFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetIos() {
    throw new Error("<BlockFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetIos(value) {
    throw new Error("<BlockFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetMaterial() {
    throw new Error("<BlockFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetMaterial(value) {
    throw new Error("<BlockFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BlockFooter_default = BlockFooter;

// node_modules/konsta/shared/esm/classes/BlockHeaderClasses.js
var BlockHeaderClasses = (props, colors) => {
  const {
    inset
  } = props;
  return {
    base: {
      common: cls(`mt-8 flex items-center -mb-6 text-sm`, inset ? "pl-8-safe pr-8-safe" : "pl-4-safe pr-4-safe"),
      ios: colors.textIos,
      material: colors.textMaterial
    }
  };
};

// node_modules/konsta/shared/esm/colors/BlockHeaderColors.js
var BlockHeaderColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    textIos: cls("text-black", dark("dark:text-white")),
    textMaterial: cls("text-md-light-on-surface-variant", dark("dark:text-md-dark-on-surface-variant")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/BlockHeader.svelte
var file9 = "node_modules/konsta/svelte/components/BlockHeader.svelte";
function create_fragment10(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[0].base
    },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file9, 39, 0, 1086);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c*/
        1 && div_class_value !== (div_class_value = /*c*/
        ctx2[0].base)) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let isInset;
  let colors;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "inset", "insetIos", "insetMaterial"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BlockHeader", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { inset = void 0 } = $$props;
  let { insetIos = false } = $$props;
  let { insetMaterial = false } = $$props;
  let theme;
  theme = useTheme({}, (v) => $$invalidate(9, theme = v));
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(3, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(5, material = $$new_props.material);
    if ("inset" in $$new_props)
      $$invalidate(6, inset = $$new_props.inset);
    if ("insetIos" in $$new_props)
      $$invalidate(7, insetIos = $$new_props.insetIos);
    if ("insetMaterial" in $$new_props)
      $$invalidate(8, insetMaterial = $$new_props.insetMaterial);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    BlockHeaderClasses,
    BlockHeaderColors,
    useTheme,
    useThemeClasses,
    useDarkClasses,
    className,
    colorsProp,
    ios,
    material,
    inset,
    insetIos,
    insetMaterial,
    theme,
    dark,
    c,
    colors,
    isInset
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(3, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(5, material = $$new_props.material);
    if ("inset" in $$props)
      $$invalidate(6, inset = $$new_props.inset);
    if ("insetIos" in $$props)
      $$invalidate(7, insetIos = $$new_props.insetIos);
    if ("insetMaterial" in $$props)
      $$invalidate(8, insetMaterial = $$new_props.insetMaterial);
    if ("theme" in $$props)
      $$invalidate(9, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(0, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(10, colors = $$new_props.colors);
    if ("isInset" in $$props)
      $$invalidate(11, isInset = $$new_props.isInset);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*inset, theme, insetIos, insetMaterial*/
    960) {
      $:
        $$invalidate(11, isInset = typeof inset === "undefined" ? theme === "ios" ? insetIos : insetMaterial : inset);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    8) {
      $:
        $$invalidate(10, colors = BlockHeaderColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, isInset, colors, className*/
    3124) {
      $:
        $$invalidate(0, c = useThemeClasses({ ios, material }, BlockHeaderClasses({ inset: isInset }, colors), className, (v) => $$invalidate(0, c = v)));
    }
  };
  return [
    c,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    inset,
    insetIos,
    insetMaterial,
    theme,
    colors,
    isInset,
    $$scope,
    slots
  ];
}
var BlockHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      class: 2,
      colors: 3,
      ios: 4,
      material: 5,
      inset: 6,
      insetIos: 7,
      insetMaterial: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BlockHeader",
      options,
      id: create_fragment10.name
    });
  }
  get class() {
    throw new Error("<BlockHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BlockHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<BlockHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<BlockHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<BlockHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<BlockHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<BlockHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<BlockHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inset() {
    throw new Error("<BlockHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inset(value) {
    throw new Error("<BlockHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetIos() {
    throw new Error("<BlockHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetIos(value) {
    throw new Error("<BlockHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetMaterial() {
    throw new Error("<BlockHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetMaterial(value) {
    throw new Error("<BlockHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BlockHeader_default = BlockHeader;

// node_modules/konsta/shared/esm/classes/BlockTitleClasses.js
var BlockTitleClasses = (props, colors) => {
  const {
    withBlock,
    medium,
    large
  } = props;
  return {
    base: {
      common: `pl-4-safe pr-4-safe mt-8 flex justify-between items-center ${withBlock ? "-mb-6" : "mb-2"}`,
      ios: cls(`font-semibold ${colors.textIos}`, large && "text-[1.5rem]", medium && "text-[1.125rem]", !medium && !large && "text-[1rem]"),
      material: cls(`font-medium ${colors.textMaterial}`, large && "text-[1.375rem]", medium && "text-[1rem]", !medium && !large && "text-[0.875rem]")
    }
  };
};

// node_modules/konsta/shared/esm/colors/BlockTitleColors.js
var BlockTitleColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    textIos: "",
    textMaterial: cls("text-md-light-primary", dark("dark:text-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/BlockTitle.svelte
var file10 = "node_modules/konsta/svelte/components/BlockTitle.svelte";
function create_fragment11(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[0].base
    },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file10, 28, 0, 837);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c*/
        1 && div_class_value !== (div_class_value = /*c*/
        ctx2[0].base)) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let colors;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "withBlock", "medium", "large"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BlockTitle", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { withBlock = true } = $$props;
  let { medium = false } = $$props;
  let { large = false } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(3, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(5, material = $$new_props.material);
    if ("withBlock" in $$new_props)
      $$invalidate(6, withBlock = $$new_props.withBlock);
    if ("medium" in $$new_props)
      $$invalidate(7, medium = $$new_props.medium);
    if ("large" in $$new_props)
      $$invalidate(8, large = $$new_props.large);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    BlockTitleClasses,
    BlockTitleColors,
    useThemeClasses,
    useDarkClasses,
    className,
    colorsProp,
    ios,
    material,
    withBlock,
    medium,
    large,
    dark,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(3, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(5, material = $$new_props.material);
    if ("withBlock" in $$props)
      $$invalidate(6, withBlock = $$new_props.withBlock);
    if ("medium" in $$props)
      $$invalidate(7, medium = $$new_props.medium);
    if ("large" in $$props)
      $$invalidate(8, large = $$new_props.large);
    if ("c" in $$props)
      $$invalidate(0, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(9, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    8) {
      $:
        $$invalidate(9, colors = BlockTitleColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, withBlock, medium, large, colors, className*/
    1012) {
      $:
        $$invalidate(0, c = useThemeClasses({ ios, material }, BlockTitleClasses({ withBlock, medium, large }, colors), className, (v) => $$invalidate(0, c = v)));
    }
  };
  return [
    c,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    withBlock,
    medium,
    large,
    colors,
    $$scope,
    slots
  ];
}
var BlockTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      class: 2,
      colors: 3,
      ios: 4,
      material: 5,
      withBlock: 6,
      medium: 7,
      large: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BlockTitle",
      options,
      id: create_fragment11.name
    });
  }
  get class() {
    throw new Error("<BlockTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BlockTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<BlockTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<BlockTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<BlockTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<BlockTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<BlockTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<BlockTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withBlock() {
    throw new Error("<BlockTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withBlock(value) {
    throw new Error("<BlockTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get medium() {
    throw new Error("<BlockTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set medium(value) {
    throw new Error("<BlockTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get large() {
    throw new Error("<BlockTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<BlockTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BlockTitle_default = BlockTitle;

// node_modules/konsta/shared/esm/classes/BreadcrumbsClasses.js
var BreadcrumbsClasses = (props) => {
  const {
    fontSizeIos,
    fontSizeMaterial
  } = props;
  return {
    base: {
      common: `flex items-center justify-start overflow-auto whitespace-nowrap py-1 px-0 space-x-3 no-scrollbar`,
      ios: fontSizeIos,
      material: fontSizeMaterial
    }
  };
};

// node_modules/konsta/svelte/components/Breadcrumbs.svelte
var file11 = "node_modules/konsta/svelte/components/Breadcrumbs.svelte";
function create_fragment12(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[0].base
    },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file11, 20, 0, 541);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c*/
        1 && div_class_value !== (div_class_value = /*c*/
        ctx2[0].base)) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let c;
  const omit_props_names = ["class", "ios", "material", "fontSizeIos", "fontSizeMaterial"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumbs", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { fontSizeIos = "text-[17px]" } = $$props;
  let { fontSizeMaterial = "text-[16px]" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("ios" in $$new_props)
      $$invalidate(3, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(4, material = $$new_props.material);
    if ("fontSizeIos" in $$new_props)
      $$invalidate(5, fontSizeIos = $$new_props.fontSizeIos);
    if ("fontSizeMaterial" in $$new_props)
      $$invalidate(6, fontSizeMaterial = $$new_props.fontSizeMaterial);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    BreadcrumbsClasses,
    useThemeClasses,
    className,
    ios,
    material,
    fontSizeIos,
    fontSizeMaterial,
    c
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("ios" in $$props)
      $$invalidate(3, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(4, material = $$new_props.material);
    if ("fontSizeIos" in $$props)
      $$invalidate(5, fontSizeIos = $$new_props.fontSizeIos);
    if ("fontSizeMaterial" in $$props)
      $$invalidate(6, fontSizeMaterial = $$new_props.fontSizeMaterial);
    if ("c" in $$props)
      $$invalidate(0, c = $$new_props.c);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ios, material, fontSizeIos, fontSizeMaterial, className*/
    124) {
      $:
        $$invalidate(0, c = useThemeClasses({ ios, material }, BreadcrumbsClasses({ fontSizeIos, fontSizeMaterial }), className, (v) => $$invalidate(0, c = v)));
    }
  };
  return [
    c,
    $$restProps,
    className,
    ios,
    material,
    fontSizeIos,
    fontSizeMaterial,
    $$scope,
    slots
  ];
}
var Breadcrumbs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      class: 2,
      ios: 3,
      material: 4,
      fontSizeIos: 5,
      fontSizeMaterial: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumbs",
      options,
      id: create_fragment12.name
    });
  }
  get class() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSizeIos() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSizeIos(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSizeMaterial() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSizeMaterial(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumbs_default = Breadcrumbs;

// node_modules/konsta/shared/esm/classes/BreadcrumbsItemClasses.js
var BreadcrumbsItemClasses = (props, colors) => {
  const {
    active
  } = props;
  return {
    base: {
      common: cls(`flex items-center`),
      ios: cls(colors.textIos, colors.bgIos, active ? colors.textActiveIos : colors.textIos, active && "font-semibold"),
      material: cls(`font-medium px-2 py-1 rounded-lg`, colors.bgMaterial, active ? colors.textActiveMaterial : colors.textMaterial)
    }
  };
};

// node_modules/konsta/shared/esm/colors/BreadcrumbsItemColors.js
var BreadcrumbsItemColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    textIos: cls("text-black text-opacity-55", dark("dark:text-white dark:text-opacity-55")),
    textMaterial: cls("text-md-light-on-secondary-container", dark("dark:text-md-dark-on-secondary-container")),
    bgIos: "",
    bgMaterial: cls("bg-md-light-secondary-container", dark("dark:bg-md-dark-secondary-container")),
    textActiveIos: cls("text-black", dark("dark:text-white")),
    textActiveMaterial: cls("text-md-light-on-secondary-container", dark("dark:text-md-dark-on-secondary-container")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/BreadcrumbsItem.svelte
var file12 = "node_modules/konsta/svelte/components/BreadcrumbsItem.svelte";
function create_fragment13(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[1].base
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file12, 30, 0, 827);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c*/
        2 && div_class_value !== (div_class_value = /*c*/
        ctx[1].base)) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let colors;
  let c;
  const omit_props_names = ["class", "ios", "material", "colors", "onClick", "active"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbsItem", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { active = false } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("ios" in $$new_props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(5, material = $$new_props.material);
    if ("colors" in $$new_props)
      $$invalidate(6, colorsProp = $$new_props.colors);
    if ("onClick" in $$new_props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("active" in $$new_props)
      $$invalidate(7, active = $$new_props.active);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    BreadcrumbsItemClasses,
    BreadcrumbsItemColors,
    useDarkClasses,
    useThemeClasses,
    className,
    ios,
    material,
    colorsProp,
    onClick,
    active,
    dark,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("ios" in $$props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(5, material = $$new_props.material);
    if ("colorsProp" in $$props)
      $$invalidate(6, colorsProp = $$new_props.colorsProp);
    if ("onClick" in $$props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("active" in $$props)
      $$invalidate(7, active = $$new_props.active);
    if ("c" in $$props)
      $$invalidate(1, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(8, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    64) {
      $:
        $$invalidate(8, colors = BreadcrumbsItemColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, active, colors, className*/
    440) {
      $:
        $$invalidate(1, c = useThemeClasses({ ios, material }, BreadcrumbsItemClasses({ active }, colors), className, (v) => $$invalidate(1, c = v)));
    }
  };
  return [
    onClick,
    c,
    $$restProps,
    className,
    ios,
    material,
    colorsProp,
    active,
    colors,
    $$scope,
    slots
  ];
}
var BreadcrumbsItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      class: 3,
      ios: 4,
      material: 5,
      colors: 6,
      onClick: 0,
      active: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbsItem",
      options,
      id: create_fragment13.name
    });
  }
  get class() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbsItem_default = BreadcrumbsItem;

// node_modules/konsta/shared/esm/classes/BreadcrumbsSeparatorClasses.js
var BreadcrumbsSeparatorClasses = () => {
  return {
    base: {
      common: `w-3 opacity-35 flex justify-center`,
      ios: ``,
      material: ``
    },
    icon: {
      common: "",
      ios: "h-3",
      material: "h-2.5"
    }
  };
};

// node_modules/konsta/svelte/components/icons/ChevronIcon.svelte
var file13 = "node_modules/konsta/svelte/components/icons/ChevronIcon.svelte";
function create_fragment14(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "8" },
    { height: "14" },
    { viewBox: "0 0 12 20" },
    { fill: "currentcolor" },
    /*$$restProps*/
    ctx[0]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.518406,10.5648622 C11.4831857,10.6163453 11.4426714,10.6653692 11.3968592,10.7111814 L2.5584348,19.5496058 C1.9753444,20.1326962 1.03186648,20.1345946 0.44199608,19.5447242 C-0.14379032,18.9589377 -0.14922592,18.0146258 0.43711448,17.4282854 L7.87507783,9.9903221 L0.4431923,2.5584366 C-0.1398981,1.9753462 -0.1417965,1.0318683 0.448074,0.4419979 C1.0338604,-0.1437886 1.9781723,-0.1492241 2.56451268,0.4371163 L11.4029371,9.2755407 C11.7556117,9.6282153 11.7969345,10.1725307 11.518406,10.5648622 Z");
      add_location(path, file13, 11, 2, 155);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file13, 3, 0, 20);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "8" },
        { height: "14" },
        { viewBox: "0 0 12 20" },
        { fill: "currentcolor" },
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronIcon", slots, []);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
var ChevronIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronIcon",
      options,
      id: create_fragment14.name
    });
  }
};
var ChevronIcon_default = ChevronIcon;

// node_modules/konsta/svelte/components/BreadcrumbsSeparator.svelte
var file14 = "node_modules/konsta/svelte/components/BreadcrumbsSeparator.svelte";
function create_fragment15(ctx) {
  let div;
  let chevronicon;
  let t;
  let div_class_value;
  let current;
  chevronicon = new ChevronIcon_default({
    props: { class: (
      /*c*/
      ctx[0].icon
    ) },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[0].base
    },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(chevronicon.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(chevronicon.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file14, 19, 0, 504);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(chevronicon, div, null);
      append_hydration_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chevronicon_changes = {};
      if (dirty & /*c*/
      1)
        chevronicon_changes.class = /*c*/
        ctx2[0].icon;
      chevronicon.$set(chevronicon_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c*/
        1 && div_class_value !== (div_class_value = /*c*/
        ctx2[0].base)) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronicon.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronicon.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(chevronicon);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let c;
  const omit_props_names = ["class", "ios", "material"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbsSeparator", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("ios" in $$new_props)
      $$invalidate(3, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(4, material = $$new_props.material);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    BreadcrumbsSeparatorClasses,
    useThemeClasses,
    ChevronIcon: ChevronIcon_default,
    className,
    ios,
    material,
    c
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("ios" in $$props)
      $$invalidate(3, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(4, material = $$new_props.material);
    if ("c" in $$props)
      $$invalidate(0, c = $$new_props.c);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ios, material, className*/
    28) {
      $:
        $$invalidate(0, c = useThemeClasses({ ios, material }, BreadcrumbsSeparatorClasses({}), className, (v) => $$invalidate(0, c = v)));
    }
  };
  return [c, $$restProps, className, ios, material, $$scope, slots];
}
var BreadcrumbsSeparator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { class: 2, ios: 3, material: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbsSeparator",
      options,
      id: create_fragment15.name
    });
  }
  get class() {
    throw new Error("<BreadcrumbsSeparator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BreadcrumbsSeparator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<BreadcrumbsSeparator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<BreadcrumbsSeparator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<BreadcrumbsSeparator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<BreadcrumbsSeparator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbsSeparator_default = BreadcrumbsSeparator;

// node_modules/konsta/shared/esm/classes/BreadcrumbsCollapsedClasses.js
var BreadcrumbsCollapsedClasses = (props, colors) => {
  return {
    base: {
      common: `flex items-center cursor-pointer space-x-0.75 ${colors.bg}`,
      ios: cls(`rounded active:opacity-30 px-1.5 h-[1em] duration-300 active:duration-0`, colors.bgIos),
      material: cls("py-3 px-2 rounded-lg", colors.bgMaterial)
    },
    dot: {
      common: `w-1 h-1 rounded-full ${colors.dotBg}`,
      ios: colors.dotBgIos,
      material: colors.dotBgMaterial
    }
  };
};

// node_modules/konsta/shared/esm/colors/BreadcrumbsCollapsedColors.js
var BreadcrumbsCollapsedColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: cls("bg-black bg-opacity-15", dark("dark:bg-white dark:bg-opacity-15")),
    bgMaterial: cls("bg-md-light-secondary-container", dark("dark:bg-md-dark-secondary-container")),
    dotBgIos: cls("bg-black", dark("dark:bg-white")),
    dotBgMaterial: cls("bg-md-light-primary", dark("dark:bg-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/BreadcrumbsCollapsed.svelte
var file15 = "node_modules/konsta/svelte/components/BreadcrumbsCollapsed.svelte";
function create_fragment16(ctx) {
  let div;
  let span0;
  let span0_class_value;
  let t0;
  let span1;
  let span1_class_value;
  let t1;
  let span2;
  let span2_class_value;
  let t2;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[1].base
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = space();
      span2 = element("span");
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t0 = claim_space(div_nodes);
      span1 = claim_element(div_nodes, "SPAN", { class: true });
      children(span1).forEach(detach_dev);
      t1 = claim_space(div_nodes);
      span2 = claim_element(div_nodes, "SPAN", { class: true });
      children(span2).forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = /*c*/
      ctx[1].dot);
      add_location(span0, file15, 29, 2, 878);
      attr_dev(span1, "class", span1_class_value = /*c*/
      ctx[1].dot);
      add_location(span1, file15, 30, 2, 903);
      attr_dev(span2, "class", span2_class_value = /*c*/
      ctx[1].dot);
      add_location(span2, file15, 31, 2, 928);
      set_attributes(div, div_data);
      add_location(div, file15, 28, 0, 819);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span0);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, span1);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, span2);
      append_hydration_dev(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & /*c*/
      2 && span0_class_value !== (span0_class_value = /*c*/
      ctx[1].dot)) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (!current || dirty & /*c*/
      2 && span1_class_value !== (span1_class_value = /*c*/
      ctx[1].dot)) {
        attr_dev(span1, "class", span1_class_value);
      }
      if (!current || dirty & /*c*/
      2 && span2_class_value !== (span2_class_value = /*c*/
      ctx[1].dot)) {
        attr_dev(span2, "class", span2_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c*/
        2 && div_class_value !== (div_class_value = /*c*/
        ctx[1].base)) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let colors;
  let c;
  const omit_props_names = ["class", "ios", "material", "colors", "onClick"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbsCollapsed", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("ios" in $$new_props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(5, material = $$new_props.material);
    if ("colors" in $$new_props)
      $$invalidate(6, colorsProp = $$new_props.colors);
    if ("onClick" in $$new_props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    BreadcrumbsCollapsedClasses,
    BreadcrumbsCollapsedColors,
    useDarkClasses,
    useThemeClasses,
    className,
    ios,
    material,
    colorsProp,
    onClick,
    dark,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("ios" in $$props)
      $$invalidate(4, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(5, material = $$new_props.material);
    if ("colorsProp" in $$props)
      $$invalidate(6, colorsProp = $$new_props.colorsProp);
    if ("onClick" in $$props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("c" in $$props)
      $$invalidate(1, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(7, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    64) {
      $:
        $$invalidate(7, colors = BreadcrumbsCollapsedColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    184) {
      $:
        $$invalidate(1, c = useThemeClasses({ ios, material }, BreadcrumbsCollapsedClasses({}, colors), className, (v) => $$invalidate(1, c = v)));
    }
  };
  return [
    onClick,
    c,
    $$restProps,
    className,
    ios,
    material,
    colorsProp,
    colors,
    $$scope,
    slots
  ];
}
var BreadcrumbsCollapsed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      class: 3,
      ios: 4,
      material: 5,
      colors: 6,
      onClick: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbsCollapsed",
      options,
      id: create_fragment16.name
    });
  }
  get class() {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<BreadcrumbsCollapsed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbsCollapsed_default = BreadcrumbsCollapsed;

// node_modules/konsta/shared/esm/classes/ButtonClasses.js
var ButtonClasses = (props, colors, classes, darkClasses) => {
  const {
    inline,
    segmented,
    segmentedStrong,
    segmentedActive,
    disabled
  } = props;
  return {
    base: {
      common: cls("flex text-center justify-center items-center appearance-none py-1 transition-colors focus:outline-none cursor-pointer select-none overflow-hidden z-10", inline ? "inline-flex" : "w-full flex", positionClass("relative", classes), disabled && "pointer-events-none", segmentedStrong && segmentedActive && "k-segmented-strong-button-active"),
      ios: `uppercase duration-100 font-semibold px-2`,
      material: `duration-300 font-medium px-4`,
      square: {
        ios: segmented && !segmentedStrong ? "first:rounded-l last:rounded-r" : "rounded",
        material: segmented && !segmentedStrong ? "first:rounded-lg-l last:rounded-lg-r" : "rounded-lg"
      },
      rounded: segmented && !segmentedStrong ? "" : "rounded-full"
    },
    style: {
      fill: {
        common: cls(disabled && cls(colors.disabledBg, colors.disabledText)),
        ios: cls(disabled ? cls(colors.disabledBg, colors.disabledText) : `${colors.fillTextIos} ${colors.fillBgIos} ${colors.fillActiveBgIos}`),
        material: cls(disabled ? cls(colors.disabledBg, colors.disabledText) : cls(colors.fillTextMaterial, colors.fillBgMaterial, colors.fillActiveBgMaterial, colors.fillTouchRipple))
      },
      outline: {
        common: cls(disabled ? cls(colors.disabledText, colors.disabledBorder) : cls("active:bg-opacity-15", colors.touchRipple)),
        ios: cls(!segmented && "border-2", !disabled && !segmented && colors.outlineBorderIos, !disabled && cls(colors.textIos, colors.activeBgIos)),
        material: cls(!segmented && "border", !disabled && !segmented && colors.outlineBorderMaterial, !disabled && cls(colors.textMaterial, colors.activeBgMaterial))
      },
      clear: {
        common: cls(disabled ? colors.disabledText : `active:bg-opacity-15 ${colors.touchRipple}`),
        ios: !disabled && cls(colors.textIos, colors.activeBgIos),
        material: !disabled && cls(colors.textMaterial, colors.activeBgMaterial)
      },
      tonal: {
        common: disabled ? cls(colors.disabledBg, colors.disabledText) : cls(colors.touchRipple),
        ios: !disabled && cls(colors.tonalTextIos, colors.tonalBgIos, colors.activeBgIos, "bg-opacity-15 active:bg-opacity-25"),
        material: !disabled && cls(colors.tonalTextMaterial, colors.tonalBgMaterial, colors.activeBgMaterial)
      },
      segmentedStrong: cls(`active:bg-black active:bg-opacity-10`, darkClasses("dark:active:bg-white dark:active:bg-opacity-5 dark:touch-ripple-white")),
      segmentedStrongActive: "duration-0"
    },
    size: {
      small: {
        ios: `text-xs h-7`,
        material: `text-sm h-8`
      },
      medium: {
        common: "text-sm",
        ios: `h-7`,
        material: `h-10`
      },
      large: {
        ios: `h-11`,
        material: `h-12`
      }
    },
    raised: `shadow active:shadow-lg`
  };
};

// node_modules/konsta/shared/esm/colors/ButtonColors.js
var ButtonColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    activeBgIos: "active:bg-primary",
    activeBgMaterial: "",
    textIos: "text-primary",
    textMaterial: cls("text-md-light-primary", "dark:text-md-dark-primary"),
    fillTextIos: cls("text-white"),
    fillTextMaterial: cls("text-md-light-on-primary", dark("dark:text-md-dark-on-primary")),
    fillActiveBgIos: "active:bg-ios-primary-shade",
    fillActiveBgMaterial: "",
    fillBgIos: "bg-primary",
    fillBgMaterial: cls("bg-md-light-primary", dark("dark:bg-md-dark-primary")),
    fillTouchRipple: cls("touch-ripple-white", "dark:touch-ripple-primary"),
    outlineBorderIos: "border-primary",
    outlineBorderMaterial: cls("border-md-light-outline", dark("dark:border-md-dark-outline")),
    tonalBgIos: "bg-primary",
    tonalBgMaterial: cls("bg-md-light-secondary-container", dark("dark:bg-md-dark-secondary-container")),
    tonalTextIos: "text-primary",
    tonalTextMaterial: cls("text-md-light-on-secondary-container", dark("dark:text-md-dark-on-secondary-container")),
    touchRipple: "touch-ripple-primary",
    disabledText: cls("text-black text-opacity-30", dark("dark:text-white dark:text-opacity-30")),
    disabledBg: cls("bg-black bg-opacity-10", dark("dark:bg-white dark:bg-opacity-10")),
    disabledBorder: cls("border-black border-opacity-10", dark("dark:border-white dark:border-opacity-10")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Button.svelte
var file16 = "node_modules/konsta/svelte/components/Button.svelte";
function create_else_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    /*attrs*/
    ctx[5]
  ];
  var switch_value = (
    /*component*/
    ctx[0]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[51](switch_instance);
    switch_instance.$on("click", function() {
      if (is_function(
        /*onClick*/
        ctx[2]
      ))
        ctx[2].apply(this, arguments);
    });
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = dirty[0] & /*classes, disabled, attrs*/
      50 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*classes*/
        16 && { class: (
          /*classes*/
          ctx[4]
        ) },
        dirty[0] & /*disabled*/
        2 && { disabled: (
          /*disabled*/
          ctx[1]
        ) },
        dirty[0] & /*attrs*/
        32 && get_spread_object(
          /*attrs*/
          ctx[5]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      2097152) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (switch_value !== (switch_value = /*component*/
      ctx[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          ctx[51](switch_instance);
          switch_instance.$on("click", function() {
            if (is_function(
              /*onClick*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          });
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[51](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(200:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let previous_tag = (
    /*component*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[0]
  );
  let svelte_element = (
    /*component*/
    ctx[0] && create_dynamic_element2(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*component*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element2(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element2(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[0];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(189:0) {#if typeof component === 'string'}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[49].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[52],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[52],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[52]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[52],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(201:2) <svelte:component     this={component}     bind:this={rippleEl.current}     class={classes}     {disabled}     {...attrs}     on:click={onClick}   >",
    ctx
  });
  return block;
}
function create_dynamic_element2(ctx) {
  let svelte_element;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[49].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[52],
    null
  );
  let svelte_element_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    /*attrs*/
    ctx[5]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[0]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[0] || "null").toUpperCase(),
        { class: true, disabled: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file16, 189, 2, 4287);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[50](svelte_element);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          svelte_element,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[52],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[52]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[52],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*classes*/
        16) && { class: (
          /*classes*/
          ctx[4]
        ) },
        (!current || dirty[0] & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx[1]
        ) },
        dirty[0] & /*attrs*/
        32 && /*attrs*/
        ctx[5]
      ]);
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      ctx[50](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element2.name,
    type: "child_dynamic_element",
    source: "(190:2) <svelte:element     this={component}     bind:this={rippleEl.current}     class={classes}     {disabled}     {...attrs}     on:click={onClick}   >",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*component*/
    ctx2[0] === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let attrs;
  let isOutline;
  let isClear;
  let isTonal;
  let isRounded;
  let isSmall;
  let isLarge;
  let isRaised;
  let size;
  let style;
  let colors;
  let c;
  let classes;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "component",
    "href",
    "disabled",
    "outline",
    "outlineIos",
    "outlineMaterial",
    "clear",
    "clearIos",
    "clearMaterial",
    "tonal",
    "tonalIos",
    "tonalMaterial",
    "rounded",
    "roundedIos",
    "roundedMaterial",
    "small",
    "smallIos",
    "smallMaterial",
    "large",
    "largeIos",
    "largeMaterial",
    "raised",
    "raisedIos",
    "raisedMaterial",
    "inline",
    "segmented",
    "segmentedStrong",
    "segmentedActive",
    "touchRipple",
    "onClick"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "button" } = $$props;
  let { href = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { outline = void 0 } = $$props;
  let { outlineIos = void 0 } = $$props;
  let { outlineMaterial = void 0 } = $$props;
  let { clear = void 0 } = $$props;
  let { clearIos = void 0 } = $$props;
  let { clearMaterial = void 0 } = $$props;
  let { tonal = void 0 } = $$props;
  let { tonalIos = void 0 } = $$props;
  let { tonalMaterial = void 0 } = $$props;
  let { rounded = void 0 } = $$props;
  let { roundedIos = void 0 } = $$props;
  let { roundedMaterial = void 0 } = $$props;
  let { small = void 0 } = $$props;
  let { smallIos = void 0 } = $$props;
  let { smallMaterial = void 0 } = $$props;
  let { large = void 0 } = $$props;
  let { largeIos = void 0 } = $$props;
  let { largeMaterial = void 0 } = $$props;
  let { raised = void 0 } = $$props;
  let { raisedIos = void 0 } = $$props;
  let { raisedMaterial = void 0 } = $$props;
  let { inline = false } = $$props;
  let { segmented = false } = $$props;
  let { segmentedStrong = false } = $$props;
  let { segmentedActive = false } = $$props;
  let { touchRipple = true } = $$props;
  let { onClick = void 0 } = $$props;
  let theme;
  theme = useTheme({}, (v) => $$invalidate(37, theme = v));
  const rippleEl = { current: null };
  const dark = useDarkClasses();
  const getStyle = (isOutline2, isClear2, isTonal2, segmented2, segmentedActive2, segmentedStrong2) => {
    let s = isOutline2 ? "outline" : isClear2 || segmented2 && !segmentedActive2 ? "clear" : isTonal2 ? "tonal" : "fill";
    if (segmentedStrong2)
      s = "segmentedStrong";
    if (segmentedStrong2 && segmentedActive2)
      s = "segmentedStrongActive";
    return s;
  };
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(3, rippleEl);
    });
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(3, rippleEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(55, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(7, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(9, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(0, component = $$new_props.component);
    if ("href" in $$new_props)
      $$invalidate(10, href = $$new_props.href);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("outline" in $$new_props)
      $$invalidate(11, outline = $$new_props.outline);
    if ("outlineIos" in $$new_props)
      $$invalidate(12, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$new_props)
      $$invalidate(13, outlineMaterial = $$new_props.outlineMaterial);
    if ("clear" in $$new_props)
      $$invalidate(14, clear = $$new_props.clear);
    if ("clearIos" in $$new_props)
      $$invalidate(15, clearIos = $$new_props.clearIos);
    if ("clearMaterial" in $$new_props)
      $$invalidate(16, clearMaterial = $$new_props.clearMaterial);
    if ("tonal" in $$new_props)
      $$invalidate(17, tonal = $$new_props.tonal);
    if ("tonalIos" in $$new_props)
      $$invalidate(18, tonalIos = $$new_props.tonalIos);
    if ("tonalMaterial" in $$new_props)
      $$invalidate(19, tonalMaterial = $$new_props.tonalMaterial);
    if ("rounded" in $$new_props)
      $$invalidate(20, rounded = $$new_props.rounded);
    if ("roundedIos" in $$new_props)
      $$invalidate(21, roundedIos = $$new_props.roundedIos);
    if ("roundedMaterial" in $$new_props)
      $$invalidate(22, roundedMaterial = $$new_props.roundedMaterial);
    if ("small" in $$new_props)
      $$invalidate(23, small = $$new_props.small);
    if ("smallIos" in $$new_props)
      $$invalidate(24, smallIos = $$new_props.smallIos);
    if ("smallMaterial" in $$new_props)
      $$invalidate(25, smallMaterial = $$new_props.smallMaterial);
    if ("large" in $$new_props)
      $$invalidate(26, large = $$new_props.large);
    if ("largeIos" in $$new_props)
      $$invalidate(27, largeIos = $$new_props.largeIos);
    if ("largeMaterial" in $$new_props)
      $$invalidate(28, largeMaterial = $$new_props.largeMaterial);
    if ("raised" in $$new_props)
      $$invalidate(29, raised = $$new_props.raised);
    if ("raisedIos" in $$new_props)
      $$invalidate(30, raisedIos = $$new_props.raisedIos);
    if ("raisedMaterial" in $$new_props)
      $$invalidate(31, raisedMaterial = $$new_props.raisedMaterial);
    if ("inline" in $$new_props)
      $$invalidate(32, inline = $$new_props.inline);
    if ("segmented" in $$new_props)
      $$invalidate(33, segmented = $$new_props.segmented);
    if ("segmentedStrong" in $$new_props)
      $$invalidate(34, segmentedStrong = $$new_props.segmentedStrong);
    if ("segmentedActive" in $$new_props)
      $$invalidate(35, segmentedActive = $$new_props.segmentedActive);
    if ("touchRipple" in $$new_props)
      $$invalidate(36, touchRipple = $$new_props.touchRipple);
    if ("onClick" in $$new_props)
      $$invalidate(2, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(52, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cls,
    useTouchRipple,
    useThemeClasses,
    useTheme,
    useDarkClasses,
    ButtonClasses,
    ButtonColors,
    className,
    colorsProp,
    ios,
    material,
    component,
    href,
    disabled,
    outline,
    outlineIos,
    outlineMaterial,
    clear,
    clearIos,
    clearMaterial,
    tonal,
    tonalIos,
    tonalMaterial,
    rounded,
    roundedIos,
    roundedMaterial,
    small,
    smallIos,
    smallMaterial,
    large,
    largeIos,
    largeMaterial,
    raised,
    raisedIos,
    raisedMaterial,
    inline,
    segmented,
    segmentedStrong,
    segmentedActive,
    touchRipple,
    onClick,
    theme,
    rippleEl,
    dark,
    getStyle,
    c,
    isRaised,
    size,
    style,
    isRounded,
    classes,
    colors,
    isLarge,
    isSmall,
    isTonal,
    isClear,
    isOutline,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(7, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(9, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(0, component = $$new_props.component);
    if ("href" in $$props)
      $$invalidate(10, href = $$new_props.href);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("outline" in $$props)
      $$invalidate(11, outline = $$new_props.outline);
    if ("outlineIos" in $$props)
      $$invalidate(12, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$props)
      $$invalidate(13, outlineMaterial = $$new_props.outlineMaterial);
    if ("clear" in $$props)
      $$invalidate(14, clear = $$new_props.clear);
    if ("clearIos" in $$props)
      $$invalidate(15, clearIos = $$new_props.clearIos);
    if ("clearMaterial" in $$props)
      $$invalidate(16, clearMaterial = $$new_props.clearMaterial);
    if ("tonal" in $$props)
      $$invalidate(17, tonal = $$new_props.tonal);
    if ("tonalIos" in $$props)
      $$invalidate(18, tonalIos = $$new_props.tonalIos);
    if ("tonalMaterial" in $$props)
      $$invalidate(19, tonalMaterial = $$new_props.tonalMaterial);
    if ("rounded" in $$props)
      $$invalidate(20, rounded = $$new_props.rounded);
    if ("roundedIos" in $$props)
      $$invalidate(21, roundedIos = $$new_props.roundedIos);
    if ("roundedMaterial" in $$props)
      $$invalidate(22, roundedMaterial = $$new_props.roundedMaterial);
    if ("small" in $$props)
      $$invalidate(23, small = $$new_props.small);
    if ("smallIos" in $$props)
      $$invalidate(24, smallIos = $$new_props.smallIos);
    if ("smallMaterial" in $$props)
      $$invalidate(25, smallMaterial = $$new_props.smallMaterial);
    if ("large" in $$props)
      $$invalidate(26, large = $$new_props.large);
    if ("largeIos" in $$props)
      $$invalidate(27, largeIos = $$new_props.largeIos);
    if ("largeMaterial" in $$props)
      $$invalidate(28, largeMaterial = $$new_props.largeMaterial);
    if ("raised" in $$props)
      $$invalidate(29, raised = $$new_props.raised);
    if ("raisedIos" in $$props)
      $$invalidate(30, raisedIos = $$new_props.raisedIos);
    if ("raisedMaterial" in $$props)
      $$invalidate(31, raisedMaterial = $$new_props.raisedMaterial);
    if ("inline" in $$props)
      $$invalidate(32, inline = $$new_props.inline);
    if ("segmented" in $$props)
      $$invalidate(33, segmented = $$new_props.segmented);
    if ("segmentedStrong" in $$props)
      $$invalidate(34, segmentedStrong = $$new_props.segmentedStrong);
    if ("segmentedActive" in $$props)
      $$invalidate(35, segmentedActive = $$new_props.segmentedActive);
    if ("touchRipple" in $$props)
      $$invalidate(36, touchRipple = $$new_props.touchRipple);
    if ("onClick" in $$props)
      $$invalidate(2, onClick = $$new_props.onClick);
    if ("theme" in $$props)
      $$invalidate(37, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(38, c = $$new_props.c);
    if ("isRaised" in $$props)
      $$invalidate(39, isRaised = $$new_props.isRaised);
    if ("size" in $$props)
      $$invalidate(40, size = $$new_props.size);
    if ("style" in $$props)
      $$invalidate(41, style = $$new_props.style);
    if ("isRounded" in $$props)
      $$invalidate(42, isRounded = $$new_props.isRounded);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("colors" in $$props)
      $$invalidate(43, colors = $$new_props.colors);
    if ("isLarge" in $$props)
      $$invalidate(44, isLarge = $$new_props.isLarge);
    if ("isSmall" in $$props)
      $$invalidate(45, isSmall = $$new_props.isSmall);
    if ("isTonal" in $$props)
      $$invalidate(46, isTonal = $$new_props.isTonal);
    if ("isClear" in $$props)
      $$invalidate(47, isClear = $$new_props.isClear);
    if ("isOutline" in $$props)
      $$invalidate(48, isOutline = $$new_props.isOutline);
    if ("attrs" in $$props)
      $$invalidate(5, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, attrs = { href, ...$$restProps });
    if ($$self.$$.dirty[0] & /*rippleEl*/
    8 | $$self.$$.dirty[1] & /*touchRipple*/
    32) {
      $:
        useTouchRipple(rippleEl, touchRipple);
    }
    if ($$self.$$.dirty[0] & /*outline, outlineIos, outlineMaterial*/
    14336 | $$self.$$.dirty[1] & /*theme*/
    64) {
      $:
        $$invalidate(48, isOutline = typeof outline === "undefined" ? theme === "ios" ? outlineIos : outlineMaterial : outline);
    }
    if ($$self.$$.dirty[0] & /*clear, clearIos, clearMaterial*/
    114688 | $$self.$$.dirty[1] & /*theme*/
    64) {
      $:
        $$invalidate(47, isClear = typeof clear === "undefined" ? theme === "ios" ? clearIos : clearMaterial : clear);
    }
    if ($$self.$$.dirty[0] & /*tonal, tonalIos, tonalMaterial*/
    917504 | $$self.$$.dirty[1] & /*theme*/
    64) {
      $:
        $$invalidate(46, isTonal = typeof tonal === "undefined" ? theme === "ios" ? tonalIos : tonalMaterial : tonal);
    }
    if ($$self.$$.dirty[0] & /*rounded, roundedIos, roundedMaterial*/
    7340032 | $$self.$$.dirty[1] & /*theme*/
    64) {
      $:
        $$invalidate(42, isRounded = typeof rounded === "undefined" ? theme === "ios" ? roundedIos : roundedMaterial : rounded);
    }
    if ($$self.$$.dirty[0] & /*small, smallIos, smallMaterial*/
    58720256 | $$self.$$.dirty[1] & /*theme*/
    64) {
      $:
        $$invalidate(45, isSmall = typeof small === "undefined" ? theme === "ios" ? smallIos : smallMaterial : small);
    }
    if ($$self.$$.dirty[0] & /*large, largeIos, largeMaterial*/
    469762048 | $$self.$$.dirty[1] & /*theme*/
    64) {
      $:
        $$invalidate(44, isLarge = typeof large === "undefined" ? theme === "ios" ? largeIos : largeMaterial : large);
    }
    if ($$self.$$.dirty[0] & /*raised, raisedIos*/
    1610612736 | $$self.$$.dirty[1] & /*theme, raisedMaterial*/
    65) {
      $:
        $$invalidate(39, isRaised = typeof raised === "undefined" ? theme === "ios" ? raisedIos : raisedMaterial : raised);
    }
    if ($$self.$$.dirty[1] & /*isLarge, isSmall*/
    24576) {
      $:
        $$invalidate(40, size = isLarge ? "large" : isSmall ? "small" : "medium");
    }
    if ($$self.$$.dirty[1] & /*isOutline, isClear, isTonal, segmented, segmentedActive, segmentedStrong*/
    229404) {
      $:
        $$invalidate(41, style = getStyle(isOutline, isClear, isTonal, segmented, segmentedActive, segmentedStrong));
    }
    if ($$self.$$.dirty[0] & /*colorsProp*/
    128) {
      $:
        $$invalidate(43, colors = ButtonColors(colorsProp, dark));
    }
    if ($$self.$$.dirty[0] & /*ios, material, disabled, className*/
    834 | $$self.$$.dirty[1] & /*inline, segmented, segmentedStrong, segmentedActive, isOutline, isClear, isTonal, isRounded, isSmall, isLarge, isRaised, colors*/
    260382) {
      $:
        $$invalidate(38, c = useThemeClasses(
          { ios, material },
          ButtonClasses(
            {
              inline,
              segmented,
              segmentedStrong,
              segmentedActive,
              disabled,
              outline: isOutline,
              clear: isClear,
              tonal: isTonal,
              rounded: isRounded,
              small: isSmall,
              large: isLarge,
              raised: isRaised
            },
            colors,
            className,
            dark
          ),
          "",
          (v) => $$invalidate(38, c = v)
        ));
    }
    if ($$self.$$.dirty[0] & /*className*/
    64 | $$self.$$.dirty[1] & /*c, isRounded, style, size, isRaised*/
    3968) {
      $:
        $$invalidate(4, classes = cls(
          c.base[isRounded ? "rounded" : "square"],
          // style
          c.style[style],
          // size
          c.size[size],
          isRaised && c.raised,
          className
        ));
    }
  };
  return [
    component,
    disabled,
    onClick,
    rippleEl,
    classes,
    attrs,
    className,
    colorsProp,
    ios,
    material,
    href,
    outline,
    outlineIos,
    outlineMaterial,
    clear,
    clearIos,
    clearMaterial,
    tonal,
    tonalIos,
    tonalMaterial,
    rounded,
    roundedIos,
    roundedMaterial,
    small,
    smallIos,
    smallMaterial,
    large,
    largeIos,
    largeMaterial,
    raised,
    raisedIos,
    raisedMaterial,
    inline,
    segmented,
    segmentedStrong,
    segmentedActive,
    touchRipple,
    theme,
    c,
    isRaised,
    size,
    style,
    isRounded,
    colors,
    isLarge,
    isSmall,
    isTonal,
    isClear,
    isOutline,
    slots,
    svelte_element_binding,
    switch_instance_binding,
    $$scope
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        class: 6,
        colors: 7,
        ios: 8,
        material: 9,
        component: 0,
        href: 10,
        disabled: 1,
        outline: 11,
        outlineIos: 12,
        outlineMaterial: 13,
        clear: 14,
        clearIos: 15,
        clearMaterial: 16,
        tonal: 17,
        tonalIos: 18,
        tonalMaterial: 19,
        rounded: 20,
        roundedIos: 21,
        roundedMaterial: 22,
        small: 23,
        smallIos: 24,
        smallMaterial: 25,
        large: 26,
        largeIos: 27,
        largeMaterial: 28,
        raised: 29,
        raisedIos: 30,
        raisedMaterial: 31,
        inline: 32,
        segmented: 33,
        segmentedStrong: 34,
        segmentedActive: 35,
        touchRipple: 36,
        onClick: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment17.name
    });
  }
  get class() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineMaterial() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineMaterial(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clear() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clear(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearMaterial() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearMaterial(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tonal() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tonal(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tonalIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tonalIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tonalMaterial() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tonalMaterial(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundedIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundedIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundedMaterial() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundedMaterial(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallMaterial() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallMaterial(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get large() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeMaterial() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeMaterial(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raised() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raised(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedMaterial() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedMaterial(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get segmented() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set segmented(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get segmentedStrong() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set segmentedStrong(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get segmentedActive() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set segmentedActive(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/konsta/shared/esm/classes/CardClasses.js
var CardClasses = (props, colors) => {
  const {
    margin,
    headerDivider,
    footerDivider,
    contentWrapPadding
  } = props;
  return {
    base: {
      common: cls(margin, `overflow-hidden`),
      ios: cls("rounded-lg", colors.bgIos, colors.textIos),
      material: cls("rounded-2xl", colors.bgMaterial, colors.textMaterial),
      plain: "",
      raised: "shadow",
      outline: {
        common: cls(`border`),
        ios: colors.outlineIos,
        material: colors.outlineMaterial
      }
    },
    header: {
      common: cls(headerDivider && `border-b`, `p-4`),
      ios: cls(headerDivider && colors.outlineIos, props.headerFontSizeIos),
      material: cls(headerDivider && colors.outlineMaterial, props.headerFontSizeMaterial)
    },
    content: cls(contentWrapPadding, "text-sm"),
    footer: {
      common: cls(headerDivider && `border-t`, `text-sm p-4`),
      ios: cls(colors.footerTextIos, footerDivider && colors.outlineIos),
      material: cls(colors.footerTextMaterial, footerDivider && colors.outlineMaterial)
    }
  };
};

// node_modules/konsta/shared/esm/colors/CardColors.js
var CardColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    textIos: cls(""),
    textMaterial: cls("text-md-light-on-surface", dark("dark:text-md-dark-on-surface")),
    bgIos: cls(`bg-ios-light-surface-1`, dark("dark:bg-ios-dark-surface-1")),
    bgMaterial: cls("bg-md-light-surface-1", dark("dark:bg-md-dark-surface-1")),
    footerTextIos: cls(`text-black text-opacity-55`, dark("dark:text-white dark:text-opacity-55")),
    footerTextMaterial: cls(`text-md-light-on-surface-variant`, dark("dark:text-md-dark-on-surface-variant")),
    outlineIos: cls("border-black border-opacity-20", dark("dark:border-white dark:border-opacity-20")),
    outlineMaterial: cls("border-md-light-outline", dark("dark:border-md-dark-outline")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Card.svelte
var file17 = "node_modules/konsta/svelte/components/Card.svelte";
var get_footer_slot_changes_1 = (dirty) => ({});
var get_footer_slot_context_1 = (ctx) => ({});
var get_header_slot_changes_1 = (dirty) => ({});
var get_header_slot_context_1 = (ctx) => ({});
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_else_block_1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      class: (
        /*c*/
        ctx[4].base[
          /*style*/
          ctx[5]
        ]
      )
    },
    /*$$restProps*/
    ctx[6]
  ];
  var switch_value = (
    /*component*/
    ctx[0]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & /*c, style, $$restProps*/
      112 ? get_spread_update(switch_instance_spread_levels, [
        dirty & /*c, style*/
        48 && {
          class: (
            /*c*/
            ctx2[4].base[
              /*style*/
              ctx2[5]
            ]
          )
        },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]) : {};
      if (dirty & /*$$scope, c, footer, $$slots, contentWrap, header*/
      134217886) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = /*component*/
      ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(86:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let previous_tag = (
    /*component*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[0]
  );
  let svelte_element = (
    /*component*/
    ctx[0] && create_dynamic_element3(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*component*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element3(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element3(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[0];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(72:0) {#if typeof component === 'string'}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[26].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_header_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*header*/
        ctx[1]
      );
      if (header_slot)
        header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*header*/
        ctx[1]
      );
      if (header_slot)
        header_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[4].header);
      add_location(div, file17, 88, 6, 2388);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*header*/
      2)
        set_data_dev(
          t,
          /*header*/
          ctx2[1]
        );
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_header_slot_changes_1
            ),
            get_header_slot_context_1
          );
        }
      }
      if (!current || dirty & /*c*/
      16 && div_class_value !== (div_class_value = /*c*/
      ctx2[4].header)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(88:4) {#if header || $$slots.header}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(93:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[4].content);
      add_location(div, file17, 91, 6, 2485);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*c*/
      16 && div_class_value !== (div_class_value = /*c*/
      ctx2[4].content)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(91:4) {#if contentWrap}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[26].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_footer_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*footer*/
        ctx[2]
      );
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*footer*/
        ctx[2]
      );
      if (footer_slot)
        footer_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[4].footer);
      add_location(div, file17, 96, 6, 2601);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*footer*/
      4)
        set_data_dev(
          t,
          /*footer*/
          ctx2[2]
        );
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_footer_slot_changes_1
            ),
            get_footer_slot_context_1
          );
        }
      }
      if (!current || dirty & /*c*/
      16 && div_class_value !== (div_class_value = /*c*/
      ctx2[4].footer)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(96:4) {#if footer || $$slots.footer}",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*header*/
    (ctx[1] || /*$$slots*/
    ctx[7].header) && create_if_block_6(ctx)
  );
  const if_block_creators = [create_if_block_5, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*contentWrap*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = (
    /*footer*/
    (ctx[2] || /*$$slots*/
    ctx[7].footer) && create_if_block_4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*header*/
        ctx2[1] || /*$$slots*/
        ctx2[7].header
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*header, $$slots*/
          130) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(t1.parentNode, t1);
      }
      if (
        /*footer*/
        ctx2[2] || /*$$slots*/
        ctx2[7].footer
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*footer, $$slots*/
          132) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(87:2) <svelte:component this={component} class={c.base[style]} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[26].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_header_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*header*/
        ctx[1]
      );
      if (header_slot)
        header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*header*/
        ctx[1]
      );
      if (header_slot)
        header_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[4].header);
      add_location(div, file17, 74, 6, 1960);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*header*/
      2)
        set_data_dev(
          t,
          /*header*/
          ctx2[1]
        );
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (!current || dirty & /*c*/
      16 && div_class_value !== (div_class_value = /*c*/
      ctx2[4].header)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(74:4) {#if header || $$slots.header}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(79:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[4].content);
      add_location(div, file17, 77, 6, 2057);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*c*/
      16 && div_class_value !== (div_class_value = /*c*/
      ctx2[4].content)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(77:4) {#if contentWrap}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[26].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*footer*/
        ctx[2]
      );
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*footer*/
        ctx[2]
      );
      if (footer_slot)
        footer_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[4].footer);
      add_location(div, file17, 82, 6, 2173);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*footer*/
      4)
        set_data_dev(
          t,
          /*footer*/
          ctx2[2]
        );
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      if (!current || dirty & /*c*/
      16 && div_class_value !== (div_class_value = /*c*/
      ctx2[4].footer)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(82:4) {#if footer || $$slots.footer}",
    ctx
  });
  return block;
}
function create_dynamic_element3(ctx) {
  let svelte_element;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let svelte_element_class_value;
  let current;
  let if_block0 = (
    /*header*/
    (ctx[1] || /*$$slots*/
    ctx[7].header) && create_if_block_3(ctx)
  );
  const if_block_creators = [create_if_block_2, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*contentWrap*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = (
    /*footer*/
    (ctx[2] || /*$$slots*/
    ctx[7].footer) && create_if_block_1(ctx)
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*c*/
      ctx[4].base[
        /*style*/
        ctx[5]
      ]
    },
    /*$$restProps*/
    ctx[6]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[0]
      );
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[0] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (if_block0)
        if_block0.l(svelte_element_nodes);
      t0 = claim_space(svelte_element_nodes);
      if_block1.l(svelte_element_nodes);
      t1 = claim_space(svelte_element_nodes);
      if (if_block2)
        if_block2.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file17, 72, 2, 1846);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (if_block0)
        if_block0.m(svelte_element, null);
      append_hydration_dev(svelte_element, t0);
      if_blocks[current_block_type_index].m(svelte_element, null);
      append_hydration_dev(svelte_element, t1);
      if (if_block2)
        if_block2.m(svelte_element, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*header*/
        ctx2[1] || /*$$slots*/
        ctx2[7].header
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*header, $$slots*/
          130) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(svelte_element, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(svelte_element, t1);
      }
      if (
        /*footer*/
        ctx2[2] || /*$$slots*/
        ctx2[7].footer
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*footer, $$slots*/
          132) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(svelte_element, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*c, style*/
        48 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx2[4].base[
          /*style*/
          ctx2[5]
        ])) && { class: svelte_element_class_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]);
      if (/-/.test(
        /*component*/
        ctx2[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element3.name,
    type: "child_dynamic_element",
    source: "(73:2) <svelte:element this={component} class={c.base[style]} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*component*/
    ctx2[0] === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let isOutline;
  let isRaised;
  let colors;
  let style;
  let c;
  const omit_props_names = [
    "component",
    "class",
    "colors",
    "ios",
    "material",
    "margin",
    "header",
    "footer",
    "contentWrap",
    "contentWrapPadding",
    "raised",
    "raisedIos",
    "raisedMaterial",
    "outline",
    "outlineIos",
    "outlineMaterial",
    "headerDivider",
    "footerDivider"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card", slots, ["header", "default", "footer"]);
  const $$slots = compute_slots(slots);
  let { component = "div" } = $$props;
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { margin = "m-4" } = $$props;
  let { header = "" } = $$props;
  let { footer = "" } = $$props;
  let { contentWrap = true } = $$props;
  let { contentWrapPadding = "p-4" } = $$props;
  let { raised = void 0 } = $$props;
  let { raisedIos = void 0 } = $$props;
  let { raisedMaterial = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { outlineIos = void 0 } = $$props;
  let { outlineMaterial = void 0 } = $$props;
  let { headerDivider = false } = $$props;
  let { footerDivider = false } = $$props;
  const dark = useDarkClasses();
  let theme;
  theme = useTheme({}, (v) => $$invalidate(22, theme = v));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("component" in $$new_props)
      $$invalidate(0, component = $$new_props.component);
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(9, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(10, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(11, material = $$new_props.material);
    if ("margin" in $$new_props)
      $$invalidate(12, margin = $$new_props.margin);
    if ("header" in $$new_props)
      $$invalidate(1, header = $$new_props.header);
    if ("footer" in $$new_props)
      $$invalidate(2, footer = $$new_props.footer);
    if ("contentWrap" in $$new_props)
      $$invalidate(3, contentWrap = $$new_props.contentWrap);
    if ("contentWrapPadding" in $$new_props)
      $$invalidate(13, contentWrapPadding = $$new_props.contentWrapPadding);
    if ("raised" in $$new_props)
      $$invalidate(14, raised = $$new_props.raised);
    if ("raisedIos" in $$new_props)
      $$invalidate(15, raisedIos = $$new_props.raisedIos);
    if ("raisedMaterial" in $$new_props)
      $$invalidate(16, raisedMaterial = $$new_props.raisedMaterial);
    if ("outline" in $$new_props)
      $$invalidate(17, outline = $$new_props.outline);
    if ("outlineIos" in $$new_props)
      $$invalidate(18, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$new_props)
      $$invalidate(19, outlineMaterial = $$new_props.outlineMaterial);
    if ("headerDivider" in $$new_props)
      $$invalidate(20, headerDivider = $$new_props.headerDivider);
    if ("footerDivider" in $$new_props)
      $$invalidate(21, footerDivider = $$new_props.footerDivider);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    CardClasses,
    CardColors,
    useDarkClasses,
    useTheme,
    useThemeClasses,
    component,
    className,
    colorsProp,
    ios,
    material,
    margin,
    header,
    footer,
    contentWrap,
    contentWrapPadding,
    raised,
    raisedIos,
    raisedMaterial,
    outline,
    outlineIos,
    outlineMaterial,
    headerDivider,
    footerDivider,
    dark,
    theme,
    c,
    colors,
    isRaised,
    isOutline,
    style
  });
  $$self.$inject_state = ($$new_props) => {
    if ("component" in $$props)
      $$invalidate(0, component = $$new_props.component);
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(9, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(10, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(11, material = $$new_props.material);
    if ("margin" in $$props)
      $$invalidate(12, margin = $$new_props.margin);
    if ("header" in $$props)
      $$invalidate(1, header = $$new_props.header);
    if ("footer" in $$props)
      $$invalidate(2, footer = $$new_props.footer);
    if ("contentWrap" in $$props)
      $$invalidate(3, contentWrap = $$new_props.contentWrap);
    if ("contentWrapPadding" in $$props)
      $$invalidate(13, contentWrapPadding = $$new_props.contentWrapPadding);
    if ("raised" in $$props)
      $$invalidate(14, raised = $$new_props.raised);
    if ("raisedIos" in $$props)
      $$invalidate(15, raisedIos = $$new_props.raisedIos);
    if ("raisedMaterial" in $$props)
      $$invalidate(16, raisedMaterial = $$new_props.raisedMaterial);
    if ("outline" in $$props)
      $$invalidate(17, outline = $$new_props.outline);
    if ("outlineIos" in $$props)
      $$invalidate(18, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$props)
      $$invalidate(19, outlineMaterial = $$new_props.outlineMaterial);
    if ("headerDivider" in $$props)
      $$invalidate(20, headerDivider = $$new_props.headerDivider);
    if ("footerDivider" in $$props)
      $$invalidate(21, footerDivider = $$new_props.footerDivider);
    if ("theme" in $$props)
      $$invalidate(22, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(4, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(23, colors = $$new_props.colors);
    if ("isRaised" in $$props)
      $$invalidate(24, isRaised = $$new_props.isRaised);
    if ("isOutline" in $$props)
      $$invalidate(25, isOutline = $$new_props.isOutline);
    if ("style" in $$props)
      $$invalidate(5, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*outline, theme, outlineIos, outlineMaterial*/
    5111808) {
      $:
        $$invalidate(25, isOutline = typeof outline === "undefined" ? theme === "ios" ? outlineIos : outlineMaterial : outline);
    }
    if ($$self.$$.dirty & /*raised, theme, raisedIos, raisedMaterial*/
    4308992) {
      $:
        $$invalidate(24, isRaised = typeof raised === "undefined" ? theme === "ios" ? raisedIos : raisedMaterial : raised);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    512) {
      $:
        $$invalidate(23, colors = CardColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*isOutline, isRaised*/
    50331648) {
      $:
        $$invalidate(5, style = isOutline ? "outline" : isRaised ? "raised" : "plain");
    }
    if ($$self.$$.dirty & /*ios, material, margin, isOutline, isRaised, contentWrapPadding, headerDivider, footerDivider, colors, className*/
    61881600) {
      $:
        $$invalidate(4, c = useThemeClasses(
          { ios, material },
          CardClasses(
            {
              margin,
              outline: isOutline,
              raised: isRaised,
              contentWrapPadding,
              headerDivider,
              footerDivider
            },
            colors,
            dark
          ),
          className,
          (v) => $$invalidate(4, c = v)
        ));
    }
  };
  return [
    component,
    header,
    footer,
    contentWrap,
    c,
    style,
    $$restProps,
    $$slots,
    className,
    colorsProp,
    ios,
    material,
    margin,
    contentWrapPadding,
    raised,
    raisedIos,
    raisedMaterial,
    outline,
    outlineIos,
    outlineMaterial,
    headerDivider,
    footerDivider,
    theme,
    colors,
    isRaised,
    isOutline,
    slots,
    $$scope
  ];
}
var Card = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      component: 0,
      class: 8,
      colors: 9,
      ios: 10,
      material: 11,
      margin: 12,
      header: 1,
      footer: 2,
      contentWrap: 3,
      contentWrapPadding: 13,
      raised: 14,
      raisedIos: 15,
      raisedMaterial: 16,
      outline: 17,
      outlineIos: 18,
      outlineMaterial: 19,
      headerDivider: 20,
      footerDivider: 21
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card",
      options,
      id: create_fragment18.name
    });
  }
  get component() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get margin() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set margin(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footer() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footer(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentWrap() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentWrap(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentWrapPadding() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentWrapPadding(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raised() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raised(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedIos() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedIos(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedMaterial() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedMaterial(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineIos() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineIos(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineMaterial() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineMaterial(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerDivider() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerDivider(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footerDivider() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footerDivider(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Card_default = Card;

// node_modules/konsta/shared/esm/classes/CheckboxClasses.js
var CheckboxClasses = (props, colors, classes, darkClasses) => {
  return {
    base: cls(`cursor-pointer inline-flex align-middle`, positionClass("relative", classes), darkClasses("dark:touch-ripple-white")),
    iconWrap: {
      common: cls(`flex items-center justify-center text-white`, darkClasses("dark:text-black")),
      ios: "w-5.5 h-5.5 rounded-full border",
      material: "w-4.5 h-4.5 rounded-sm border-2",
      notChecked: {
        ios: colors.borderIos,
        material: colors.borderMaterial
      },
      checked: {
        ios: `${colors.bgCheckedIos} ${colors.borderCheckedIos}`,
        material: `${colors.bgCheckedMaterial} ${colors.borderCheckedMaterial}`
      }
    },
    icon: {
      notChecked: "opacity-0",
      checked: "opacity-100"
    },
    indeterminateIcon: {
      common: cls(`bg-white w-3/4`, darkClasses("dark:bg-black")),
      ios: "h-0.5 rounded-full",
      material: "h-0.5"
    },
    input: "hidden"
  };
};

// node_modules/konsta/shared/esm/colors/CheckboxColors.js
var CheckboxColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    borderIos: cls(`border-black border-opacity-30`, dark("dark:border-white dark:border-opacity-30")),
    borderMaterial: cls(`border-md-light-outline`, dark("dark:border-md-dark-outline")),
    bgCheckedIos: "bg-primary",
    bgCheckedMaterial: cls("bg-md-light-primary", dark("dark:bg-md-dark-primary")),
    borderCheckedIos: "border-primary",
    borderCheckedMaterial: cls("border-md-light-primary", dark("dark:border-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/icons/CheckboxIcon.svelte
var file18 = "node_modules/konsta/svelte/components/icons/CheckboxIcon.svelte";
function create_if_block_12(ctx) {
  let svg;
  let path;
  let path_fill_value;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "20" },
    { height: "20" },
    { viewBox: "0 0 20 20" },
    { fill: "currentcolor" },
    /*$$restProps*/
    ctx[2]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        fill: true,
        fillrule: true,
        d: true,
        transform: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", path_fill_value = /*fill*/
      ctx[0] || "currentColor");
      attr_dev(path, "fillrule", "evenodd");
      attr_dev(path, "d", "M10.6461792,0.119820016 C11.0022676,0.346673312 11.1070333,0.819240884 10.88018,1.17532923 L5.59004012,9.47918548 C5.44456028,9.70754308 5.19802823,9.83254199 4.94596825,9.83309245 C4.59813173,9.83364386 4.39457446,9.67360825 4.28105047,9.53831563 L1.17887189,5.84128316 C0.907480501,5.5178515 0.949667479,5.03565214 1.27309914,4.76426075 C1.59653081,4.49286936 2.07873017,4.53505633 2.35012156,4.858488 L4.8346263,7.81909046 L9.59067001,0.353820775 C9.81752331,-0.00226757161 10.2900909,-0.10703328 10.6461792,0.119820016 Z");
      attr_dev(path, "transform", "translate(4 5.483)");
      add_location(path, file18, 20, 4, 422);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file18, 12, 2, 270);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*fill*/
      1 && path_fill_value !== (path_fill_value = /*fill*/
      ctx2[0] || "currentColor")) {
        attr_dev(path, "fill", path_fill_value);
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "20" },
        { height: "20" },
        { viewBox: "0 0 20 20" },
        { fill: "currentcolor" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(12:0) {#if theme === 'ios'}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let svg;
  let polygon;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "18" },
    { height: "14" },
    { viewBox: "0 0 14 14" },
    { fill: "currentcolor" },
    /*$$restProps*/
    ctx[2]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { fill: true, points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        polygon,
        "fill",
        /*fill*/
        ctx[0]
      );
      attr_dev(polygon, "points", "6 11.17 1.83 7 .41 8.41 6 14 18 2 16.59 .59");
      add_location(polygon, file18, 37, 4, 1264);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file18, 29, 2, 1112);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*fill*/
      1) {
        attr_dev(
          polygon,
          "fill",
          /*fill*/
          ctx2[0]
        );
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "18" },
        { height: "14" },
        { viewBox: "0 0 14 14" },
        { fill: "currentcolor" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(29:0) {#if theme === 'material'}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = (
    /*theme*/
    ctx[1] === "ios" && create_if_block_12(ctx)
  );
  let if_block1 = (
    /*theme*/
    ctx[1] === "material" && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*theme*/
        ctx2[1] === "ios"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*theme*/
        ctx2[1] === "material"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  const omit_props_names = ["ios", "material", "fill"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckboxIcon", slots, []);
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(1, theme = v));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ios" in $$new_props)
      $$invalidate(3, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(4, material = $$new_props.material);
    if ("fill" in $$new_props)
      $$invalidate(0, fill = $$new_props.fill);
  };
  $$self.$capture_state = () => ({ useTheme, ios, material, fill, theme });
  $$self.$inject_state = ($$new_props) => {
    if ("ios" in $$props)
      $$invalidate(3, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(4, material = $$new_props.material);
    if ("fill" in $$props)
      $$invalidate(0, fill = $$new_props.fill);
    if ("theme" in $$props)
      $$invalidate(1, theme = $$new_props.theme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [fill, theme, $$restProps, ios, material];
}
var CheckboxIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { ios: 3, material: 4, fill: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckboxIcon",
      options,
      id: create_fragment19.name
    });
  }
  get ios() {
    throw new Error("<CheckboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<CheckboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<CheckboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<CheckboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<CheckboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<CheckboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckboxIcon_default = CheckboxIcon;

// node_modules/konsta/svelte/components/Checkbox.svelte
var file19 = "node_modules/konsta/svelte/components/Checkbox.svelte";
function create_else_block3(ctx) {
  let checkboxicon;
  let current;
  checkboxicon = new CheckboxIcon_default({
    props: {
      ios: (
        /*ios*/
        ctx[0]
      ),
      material: (
        /*material*/
        ctx[1]
      ),
      class: (
        /*c*/
        ctx[12].icon[
          /*state*/
          ctx[13]
        ]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkboxicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkboxicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxicon_changes = {};
      if (dirty & /*ios*/
      1)
        checkboxicon_changes.ios = /*ios*/
        ctx2[0];
      if (dirty & /*material*/
      2)
        checkboxicon_changes.material = /*material*/
        ctx2[1];
      if (dirty & /*c, state*/
      12288)
        checkboxicon_changes.class = /*c*/
        ctx2[12].icon[
          /*state*/
          ctx2[13]
        ];
      checkboxicon.$set(checkboxicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(74:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let span;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[12].indeterminateIcon);
      add_location(span, file19, 72, 6, 1820);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*c*/
      4096 && span_class_value !== (span_class_value = /*c*/
      ctx2[12].indeterminateIcon)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(72:4) {#if indeterminate}",
    ctx
  });
  return block;
}
function create_dynamic_element4(ctx) {
  let svelte_element;
  let input;
  let input_class_value;
  let t0;
  let i;
  let current_block_type_index;
  let if_block;
  let i_class_value;
  let t1;
  let svelte_element_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block5, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*indeterminate*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*c*/
      ctx[12].base
    },
    /*$$restProps*/
    ctx[14]
  ];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i2]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[2]
      );
      input = element("input");
      t0 = space();
      i = element("i");
      if_block.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[2] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      input = claim_element(svelte_element_nodes, "INPUT", { type: true, name: true, class: true });
      t0 = claim_space(svelte_element_nodes);
      i = claim_element(svelte_element_nodes, "I", { class: true });
      var i_nodes = children(i);
      if_block.l(i_nodes);
      i_nodes.forEach(detach_dev);
      t1 = claim_space(svelte_element_nodes);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[5]
      );
      input.value = /*value*/
      ctx[6];
      input.disabled = /*disabled*/
      ctx[7];
      input.readOnly = /*readonly*/
      ctx[8];
      input.checked = /*checked*/
      ctx[3];
      attr_dev(input, "class", input_class_value = /*c*/
      ctx[12].input);
      add_location(input, file19, 59, 2, 1590);
      attr_dev(i, "class", i_class_value = /*c*/
      ctx[12].iconWrap[
        /*state*/
        ctx[13]
      ]);
      add_location(i, file19, 70, 2, 1760);
      if (/-/.test(
        /*component*/
        ctx[2]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file19, 53, 0, 1484);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, input);
      ctx[21](input);
      append_hydration_dev(svelte_element, t0);
      append_hydration_dev(svelte_element, i);
      if_blocks[current_block_type_index].m(i, null);
      append_hydration_dev(svelte_element, t1);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[22](svelte_element);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          function() {
            if (is_function(
              /*onChange*/
              ctx[9]
            ))
              ctx[9].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*name*/
      32) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx[5]
        );
      }
      if (!current || dirty & /*value*/
      64) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx[6]
        );
      }
      if (!current || dirty & /*disabled*/
      128) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx[7]
        );
      }
      if (!current || dirty & /*readonly*/
      256) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx[8]
        );
      }
      if (!current || dirty & /*checked*/
      8) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx[3]
        );
      }
      if (!current || dirty & /*c*/
      4096 && input_class_value !== (input_class_value = /*c*/
      ctx[12].input)) {
        attr_dev(input, "class", input_class_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(i, null);
      }
      if (!current || dirty & /*c, state*/
      12288 && i_class_value !== (i_class_value = /*c*/
      ctx[12].iconWrap[
        /*state*/
        ctx[13]
      ])) {
        attr_dev(i, "class", i_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*c*/
        4096 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx[12].base)) && { class: svelte_element_class_value },
        dirty & /*$$restProps*/
        16384 && /*$$restProps*/
        ctx[14]
      ]);
      if (/-/.test(
        /*component*/
        ctx[2]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      ctx[21](null);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element4.name,
    type: "child_dynamic_element",
    source: "(54:0) <svelte:element   this={component}   bind:this={rippleEl.current}   class={c.base}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let previous_tag = (
    /*component*/
    ctx[2]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[2]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[2]
  );
  let svelte_element = (
    /*component*/
    ctx[2] && create_dynamic_element4(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*component*/
        ctx2[2]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element4(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[2]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[2]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[2]
          );
          svelte_element = create_dynamic_element4(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[2];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let colors;
  let state;
  let c;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "component",
    "checked",
    "indeterminate",
    "name",
    "value",
    "disabled",
    "readonly",
    "onChange",
    "touchRipple"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "label" } = $$props;
  let { checked = false } = $$props;
  let { indeterminate = false } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { readonly = false } = $$props;
  let { onChange = void 0 } = $$props;
  let { touchRipple = true } = $$props;
  let inputEl;
  const rippleEl = { current: null };
  const dark = useDarkClasses();
  function watchIndeterminate(indeterminatePassed) {
    if (inputEl) {
      $$invalidate(11, inputEl.indeterminate = !!indeterminate, inputEl);
    }
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(11, inputEl);
    });
  }
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(10, rippleEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(15, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(16, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(0, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(1, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(2, component = $$new_props.component);
    if ("checked" in $$new_props)
      $$invalidate(3, checked = $$new_props.checked);
    if ("indeterminate" in $$new_props)
      $$invalidate(4, indeterminate = $$new_props.indeterminate);
    if ("name" in $$new_props)
      $$invalidate(5, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props)
      $$invalidate(8, readonly = $$new_props.readonly);
    if ("onChange" in $$new_props)
      $$invalidate(9, onChange = $$new_props.onChange);
    if ("touchRipple" in $$new_props)
      $$invalidate(17, touchRipple = $$new_props.touchRipple);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    CheckboxClasses,
    CheckboxColors,
    useDarkClasses,
    useThemeClasses,
    useTouchRipple,
    CheckboxIcon: CheckboxIcon_default,
    className,
    colorsProp,
    ios,
    material,
    component,
    checked,
    indeterminate,
    name,
    value,
    disabled,
    readonly,
    onChange,
    touchRipple,
    inputEl,
    rippleEl,
    dark,
    watchIndeterminate,
    c,
    colors,
    state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(15, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(16, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(0, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(1, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(2, component = $$new_props.component);
    if ("checked" in $$props)
      $$invalidate(3, checked = $$new_props.checked);
    if ("indeterminate" in $$props)
      $$invalidate(4, indeterminate = $$new_props.indeterminate);
    if ("name" in $$props)
      $$invalidate(5, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(6, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("readonly" in $$props)
      $$invalidate(8, readonly = $$new_props.readonly);
    if ("onChange" in $$props)
      $$invalidate(9, onChange = $$new_props.onChange);
    if ("touchRipple" in $$props)
      $$invalidate(17, touchRipple = $$new_props.touchRipple);
    if ("inputEl" in $$props)
      $$invalidate(11, inputEl = $$new_props.inputEl);
    if ("c" in $$props)
      $$invalidate(12, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(18, colors = $$new_props.colors);
    if ("state" in $$props)
      $$invalidate(13, state = $$new_props.state);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*rippleEl, touchRipple*/
    132096) {
      $:
        useTouchRipple(rippleEl, touchRipple);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    65536) {
      $:
        $$invalidate(18, colors = CheckboxColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*checked, indeterminate*/
    24) {
      $:
        $$invalidate(13, state = checked || indeterminate ? "checked" : "notChecked");
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    294915) {
      $:
        $$invalidate(12, c = useThemeClasses({ ios, material }, CheckboxClasses({}, colors, className, dark), className, (v) => $$invalidate(12, c = v)));
    }
    if ($$self.$$.dirty & /*indeterminate*/
    16) {
      $:
        watchIndeterminate(indeterminate);
    }
  };
  return [
    ios,
    material,
    component,
    checked,
    indeterminate,
    name,
    value,
    disabled,
    readonly,
    onChange,
    rippleEl,
    inputEl,
    c,
    state,
    $$restProps,
    className,
    colorsProp,
    touchRipple,
    colors,
    $$scope,
    slots,
    input_binding,
    svelte_element_binding
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      class: 15,
      colors: 16,
      ios: 0,
      material: 1,
      component: 2,
      checked: 3,
      indeterminate: 4,
      name: 5,
      value: 6,
      disabled: 7,
      readonly: 8,
      onChange: 9,
      touchRipple: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment20.name
    });
  }
  get class() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// node_modules/konsta/shared/esm/classes/ChipClasses.js
var ChipClasses = (props, colors) => {
  return {
    base: {
      common: `text-sm inline-flex items-center justify-center align-middle rounded-full px-3`,
      ios: "rounded-full h-7",
      material: "rounded-lg h-8 font-medium",
      fill: {
        ios: cls(colors.fillBg || colors.fillBgIos, colors.fillText || colors.fillTextIos),
        material: cls(colors.fillBg || colors.fillBgMaterial, colors.fillText || colors.fillTextMaterial)
      },
      outline: {
        common: `border`,
        ios: cls(colors.outlineText || colors.outlineTextIos, colors.outlineBorder || colors.outlineBorderIos),
        material: cls(colors.outlineText || colors.outlineTextMaterial, colors.outlineBorder || colors.outlineBorderMaterial)
      }
    },
    media: {
      common: "-my-1 mr-1 select-none",
      ios: "-ml-3",
      material: "-ml-2"
    },
    deleteButton: "-mr-2 -my-1 ml-1 h-full flex items-center justify-center w-6 cursor-pointer opacity-50 active:opacity-100 select-none"
  };
};

// node_modules/konsta/shared/esm/colors/ChipColors.js
var ChipColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    fillTextIos: "text-current",
    fillTextMaterial: cls("text-md-light-on-secondary-container", dark("dark:text-md-dark-on-secondary-container")),
    fillBgIos: cls(`bg-black bg-opacity-10`, dark("dark:bg-white dark:bg-opacity-10")),
    fillBgMaterial: cls("bg-md-light-secondary-container", dark("dark:bg-md-dark-secondary-container")),
    outlineTextIos: cls("text-current"),
    outlineTextMaterial: cls("text-md-light-on-surface", dark("dark:text-md-dark-on-surface")),
    outlineBorderIos: cls(`border-black border-opacity-20`, dark("dark:border-white dark:border-opacity-20")),
    outlineBorderMaterial: cls(`border-md-light-outline`, dark("dark:border-md-dark-outline")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/icons/DeleteIcon.svelte
var file20 = "node_modules/konsta/svelte/components/icons/DeleteIcon.svelte";
function create_else_block4(ctx) {
  let svg;
  let path;
  let mounted;
  let dispose;
  let svg_levels = [
    { width: "24" },
    { height: "24" },
    { viewBox: "0 0 24 24" },
    { fill: "none" },
    { xmlns: "http://www.w3.org/2000/svg" },
    /*$$restProps*/
    ctx[2]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        "clip-rule": true,
        d: true,
        fill: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(path, "d", "M12 2C6.47 2 2 6.47 2 12C2 17.53 6.47 22 12 22C17.53 22 22 17.53 22 12C22 6.47 17.53 2 12 2ZM12 20C7.59 20 4 16.41 4 12C4 7.59 7.59 4 12 4C16.41 4 20 7.59 20 12C20 16.41 16.41 20 12 20ZM12 10.59L15.59 7L17 8.41L13.41 12L17 15.59L15.59 17L12 13.41L8.41 17L7 15.59L10.59 12L7 8.41L8.41 7L12 10.59Z");
      attr_dev(path, "fill", "currentcolor");
      add_location(path, file20, 29, 4, 877);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file20, 20, 2, 710);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = listen_dev(
          svg,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { width: "24" },
        { height: "24" },
        { viewBox: "0 0 24 24" },
        { fill: "none" },
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx[2]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(20:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let svg;
  let path;
  let mounted;
  let dispose;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "28" },
    { height: "28" },
    { viewBox: "0 0 28 28" },
    { fill: "currentcolor" },
    /*$$restProps*/
    ctx[2]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14,0 C21.7319865,0 28,6.2680135 28,14 C28,21.7319865 21.7319865,28 14,28 C6.2680135,28 0,21.7319865 0,14 C0,6.2680135 6.2680135,0 14,0 Z M18.9393398,6.93933983 L14,11.8786797 L9.06066017,6.93933983 L6.93933983,9.06066017 L11.8786797,14 L6.93933983,18.9393398 L9.06066017,21.0606602 L14,16.1213203 L18.9393398,21.0606602 L21.0606602,18.9393398 L16.1213203,14 L21.0606602,9.06066017 L18.9393398,6.93933983 Z");
      add_location(path, file20, 15, 4, 261);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file20, 6, 2, 86);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = listen_dev(
          svg,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "28" },
        { height: "28" },
        { viewBox: "0 0 28 28" },
        { fill: "currentcolor" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx[2]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(6:0) {#if theme === 'ios'}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*theme*/
      ctx2[1] === "ios"
    )
      return create_if_block6;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  const omit_props_names = ["onClick", "theme"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DeleteIcon", slots, []);
  let { onClick } = $$props;
  let { theme } = $$props;
  $$self.$$.on_mount.push(function() {
    if (onClick === void 0 && !("onClick" in $$props || $$self.$$.bound[$$self.$$.props["onClick"]])) {
      console.warn("<DeleteIcon> was created without expected prop 'onClick'");
    }
    if (theme === void 0 && !("theme" in $$props || $$self.$$.bound[$$self.$$.props["theme"]])) {
      console.warn("<DeleteIcon> was created without expected prop 'theme'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("onClick" in $$new_props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("theme" in $$new_props)
      $$invalidate(1, theme = $$new_props.theme);
  };
  $$self.$capture_state = () => ({ onClick, theme });
  $$self.$inject_state = ($$new_props) => {
    if ("onClick" in $$props)
      $$invalidate(0, onClick = $$new_props.onClick);
    if ("theme" in $$props)
      $$invalidate(1, theme = $$new_props.theme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [onClick, theme, $$restProps];
}
var DeleteIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { onClick: 0, theme: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DeleteIcon",
      options,
      id: create_fragment21.name
    });
  }
  get onClick() {
    throw new Error("<DeleteIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<DeleteIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<DeleteIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<DeleteIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DeleteIcon_default = DeleteIcon;

// node_modules/konsta/svelte/components/Chip.svelte
var file21 = "node_modules/konsta/svelte/components/Chip.svelte";
var get_media_slot_changes = (dirty) => ({});
var get_media_slot_context = (ctx) => ({});
function create_if_block_13(ctx) {
  let div;
  let div_class_value;
  let current;
  const media_slot_template = (
    /*#slots*/
    ctx[15].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_media_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (media_slot)
        media_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (media_slot)
        media_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[4].media);
      add_location(div, file21, 40, 4, 1126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (media_slot) {
        if (media_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_media_slot_changes
            ),
            get_media_slot_context
          );
        }
      }
      if (!current || dirty & /*c*/
      16 && div_class_value !== (div_class_value = /*c*/
      ctx2[4].media)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(40:2) {#if $$slots.media}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let div;
  let deleteicon;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  deleteicon = new DeleteIcon_default({
    props: {
      theme: (
        /*theme*/
        ctx[3]
      ),
      class: "h-4 w-4"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(deleteicon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(deleteicon.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[4].deleteButton);
      add_location(div, file21, 44, 4, 1219);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(deleteicon, div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onDelete*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const deleteicon_changes = {};
      if (dirty & /*theme*/
      8)
        deleteicon_changes.theme = /*theme*/
        ctx[3];
      deleteicon.$set(deleteicon_changes);
      if (!current || dirty & /*c*/
      16 && div_class_value !== (div_class_value = /*c*/
      ctx[4].deleteButton)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(deleteicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(deleteicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(deleteicon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(44:2) {#if deleteButton}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let div;
  let t0;
  let t1;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[7].media && create_if_block_13(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let if_block1 = (
    /*deleteButton*/
    ctx[0] && create_if_block7(ctx)
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[4].base[
        /*style*/
        ctx[5]
      ]
    },
    /*$$restProps*/
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file21, 38, 0, 1036);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*$$slots*/
        ctx[7].media
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*deleteButton*/
        ctx[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*deleteButton*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block7(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c, style*/
        48 && div_class_value !== (div_class_value = /*c*/
        ctx[4].base[
          /*style*/
          ctx[5]
        ])) && { class: div_class_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let style;
  let colors;
  let c;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "deleteButton",
    "onDelete",
    "outline",
    "onClick"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chip", slots, ["media", "default"]);
  const $$slots = compute_slots(slots);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { deleteButton = void 0 } = $$props;
  let { onDelete = void 0 } = $$props;
  let { outline = false } = $$props;
  let { onClick = void 0 } = $$props;
  const dark = useDarkClasses();
  let theme;
  theme = useTheme({}, (v) => $$invalidate(3, theme = v));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(9, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(10, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(11, material = $$new_props.material);
    if ("deleteButton" in $$new_props)
      $$invalidate(0, deleteButton = $$new_props.deleteButton);
    if ("onDelete" in $$new_props)
      $$invalidate(1, onDelete = $$new_props.onDelete);
    if ("outline" in $$new_props)
      $$invalidate(12, outline = $$new_props.outline);
    if ("onClick" in $$new_props)
      $$invalidate(2, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ChipClasses,
    ChipColors,
    useDarkClasses,
    useThemeClasses,
    useTheme,
    DeleteIcon: DeleteIcon_default,
    className,
    colorsProp,
    ios,
    material,
    deleteButton,
    onDelete,
    outline,
    onClick,
    dark,
    theme,
    c,
    colors,
    style
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(9, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(10, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(11, material = $$new_props.material);
    if ("deleteButton" in $$props)
      $$invalidate(0, deleteButton = $$new_props.deleteButton);
    if ("onDelete" in $$props)
      $$invalidate(1, onDelete = $$new_props.onDelete);
    if ("outline" in $$props)
      $$invalidate(12, outline = $$new_props.outline);
    if ("onClick" in $$props)
      $$invalidate(2, onClick = $$new_props.onClick);
    if ("theme" in $$props)
      $$invalidate(3, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(4, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(13, colors = $$new_props.colors);
    if ("style" in $$props)
      $$invalidate(5, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*outline*/
    4096) {
      $:
        $$invalidate(5, style = outline ? "outline" : "fill");
    }
    if ($$self.$$.dirty & /*colorsProp*/
    512) {
      $:
        $$invalidate(13, colors = ChipColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    11520) {
      $:
        $$invalidate(4, c = useThemeClasses({ ios, material }, ChipClasses({}, colors), className, (v) => $$invalidate(4, c = v)));
    }
  };
  return [
    deleteButton,
    onDelete,
    onClick,
    theme,
    c,
    style,
    $$restProps,
    $$slots,
    className,
    colorsProp,
    ios,
    material,
    outline,
    colors,
    $$scope,
    slots
  ];
}
var Chip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      class: 8,
      colors: 9,
      ios: 10,
      material: 11,
      deleteButton: 0,
      onDelete: 1,
      outline: 12,
      onClick: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chip",
      options,
      id: create_fragment22.name
    });
  }
  get class() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteButton() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteButton(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDelete() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDelete(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Chip_default = Chip;

// node_modules/konsta/shared/esm/classes/DialogClasses.js
var DialogClasses = (props, colors, classes, _ref) => {
  let {
    hasButtons
  } = _ref;
  const {
    titleFontSizeMaterial,
    titleFontSizeIos,
    translucent,
    sizeIos,
    sizeMaterial
  } = props;
  return {
    base: {
      common: cls("left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 z-40 max-h-full overflow-hidden duration-400", positionClass("fixed", classes)),
      ios: cls("rounded-xl max-w-full", sizeIos, colors.bgIos, translucent && "translucent"),
      material: cls("rounded-[1.75rem] p-6 max-w-[90%]", sizeMaterial, colors.bgMaterial),
      opened: "",
      closed: "scale-[0.85] opacity-0 pointer-events-none"
    },
    contentWrap: {
      common: "flex flex-col items-center justify-center",
      material: "space-y-3",
      ios: cls("p-4 space-y-1 relative", hasButtons && "hairline-b")
    },
    title: {
      common: cls("w-full"),
      ios: cls(colors.titleIos, titleFontSizeIos, "font-semibold text-center"),
      material: cls(colors.titleMaterial, titleFontSizeMaterial)
    },
    content: {
      common: cls("text-sm w-full"),
      ios: cls(colors.contentTextIos, "text-center"),
      material: cls(colors.contentTextMaterial)
    },
    buttons: {
      common: "flex items-center",
      ios: cls("justify-center last-child-hairline-r-none"),
      material: cls("justify-end pt-6 space-x-2")
    },
    backdrop: {
      common: "fixed z-40 w-full h-full left-0 top-0 bg-black bg-opacity-50 duration-400",
      opened: "",
      closed: "opacity-0 pointer-events-none"
    }
  };
};

// node_modules/konsta/shared/esm/colors/DialogColors.js
var DialogColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: cls("bg-white", dark("dark:bg-neutral-800")),
    bgMaterial: cls("bg-md-light-surface-3", dark("dark:bg-md-dark-surface-3")),
    titleIos: "",
    titleMaterial: cls("text-md-light-on-surface", dark("dark:text-md-dark-on-surface")),
    contentTextIos: "",
    contentTextMaterial: cls("text-md-light-on-surface-variant", dark("dark:text-md-dark-on-surface-variant")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Dialog.svelte
var file22 = "node_modules/konsta/svelte/components/Dialog.svelte";
var get_buttons_slot_changes = (dirty) => ({});
var get_buttons_slot_context = (ctx) => ({});
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
function create_if_block_32(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[2].backdrop[
        /*state*/
        ctx[3]
      ]);
      add_location(div, file22, 49, 2, 1276);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onBackdropClick*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*c, state*/
      12 && div_class_value !== (div_class_value = /*c*/
      ctx[2].backdrop[
        /*state*/
        ctx[3]
      ])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(49:0) {#if backdrop}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let div;
  let div_class_value;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[18].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_title_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (title_slot)
        title_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[2].title);
      add_location(div, file22, 55, 6, 1449);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      }
      if (!current || dirty & /*c*/
      4 && div_class_value !== (div_class_value = /*c*/
      ctx2[2].title)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(55:4) {#if $$slots.title}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[2].content);
      add_location(div, file22, 58, 6, 1540);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*c*/
      4 && div_class_value !== (div_class_value = /*c*/
      ctx2[2].content)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(58:4) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let div;
  let div_class_value;
  let current;
  const buttons_slot_template = (
    /*#slots*/
    ctx[18].buttons
  );
  const buttons_slot = create_slot(
    buttons_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_buttons_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (buttons_slot)
        buttons_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (buttons_slot)
        buttons_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[2].buttons);
      add_location(div, file22, 64, 4, 1641);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (buttons_slot) {
        buttons_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              buttons_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_buttons_slot_changes
            ),
            get_buttons_slot_context
          );
        }
      }
      if (!current || dirty & /*c*/
      4 && div_class_value !== (div_class_value = /*c*/
      ctx2[2].buttons)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (buttons_slot)
        buttons_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(64:2) {#if $$slots.buttons}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let t0;
  let div1;
  let div0;
  let t1;
  let div0_class_value;
  let t2;
  let div1_class_value;
  let current;
  let if_block0 = (
    /*backdrop*/
    ctx[0] && create_if_block_32(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[4].title && create_if_block_22(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[4].default && create_if_block_14(ctx)
  );
  let if_block3 = (
    /*$$slots*/
    ctx[4].buttons && create_if_block8(ctx)
  );
  let div1_levels = [
    {
      class: div1_class_value = /*c*/
      ctx[2].base[
        /*state*/
        ctx[3]
      ]
    },
    /*$$restProps*/
    ctx[5]
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block3)
        if_block3.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*c*/
      ctx[2].contentWrap);
      add_location(div0, file22, 53, 2, 1391);
      set_attributes(div1, div1_data);
      add_location(div1, file22, 52, 0, 1344);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div1, t2);
      if (if_block3)
        if_block3.m(div1, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*backdrop*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$$slots*/
        ctx2[4].title
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[4].default
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_14(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*c*/
      4 && div0_class_value !== (div0_class_value = /*c*/
      ctx2[2].contentWrap)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$$slots*/
        ctx2[4].buttons
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block8(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty & /*c, state*/
        12 && div1_class_value !== (div1_class_value = /*c*/
        ctx2[2].base[
          /*state*/
          ctx2[3]
        ])) && { class: div1_class_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div1);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let state;
  let colors;
  let c;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "translucent",
    "sizeIos",
    "sizeMaterial",
    "titleFontSizeIos",
    "titleFontSizeMaterial",
    "opened",
    "backdrop",
    "onBackdropClick"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dialog", slots, ["title", "default", "buttons"]);
  const $$slots = compute_slots(slots);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { translucent = true } = $$props;
  let { sizeIos = "w-[16.875rem]" } = $$props;
  let { sizeMaterial = "w-[19.5rem]" } = $$props;
  let { titleFontSizeIos = "text-[18px]" } = $$props;
  let { titleFontSizeMaterial = "text-[24px]" } = $$props;
  let { opened = false } = $$props;
  let { backdrop = true } = $$props;
  let { onBackdropClick = void 0 } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(7, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(9, material = $$new_props.material);
    if ("translucent" in $$new_props)
      $$invalidate(10, translucent = $$new_props.translucent);
    if ("sizeIos" in $$new_props)
      $$invalidate(11, sizeIos = $$new_props.sizeIos);
    if ("sizeMaterial" in $$new_props)
      $$invalidate(12, sizeMaterial = $$new_props.sizeMaterial);
    if ("titleFontSizeIos" in $$new_props)
      $$invalidate(13, titleFontSizeIos = $$new_props.titleFontSizeIos);
    if ("titleFontSizeMaterial" in $$new_props)
      $$invalidate(14, titleFontSizeMaterial = $$new_props.titleFontSizeMaterial);
    if ("opened" in $$new_props)
      $$invalidate(15, opened = $$new_props.opened);
    if ("backdrop" in $$new_props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$new_props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    DialogClasses,
    DialogColors,
    useDarkClasses,
    useThemeClasses,
    className,
    colorsProp,
    ios,
    material,
    translucent,
    sizeIos,
    sizeMaterial,
    titleFontSizeIos,
    titleFontSizeMaterial,
    opened,
    backdrop,
    onBackdropClick,
    dark,
    c,
    colors,
    state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(7, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(9, material = $$new_props.material);
    if ("translucent" in $$props)
      $$invalidate(10, translucent = $$new_props.translucent);
    if ("sizeIos" in $$props)
      $$invalidate(11, sizeIos = $$new_props.sizeIos);
    if ("sizeMaterial" in $$props)
      $$invalidate(12, sizeMaterial = $$new_props.sizeMaterial);
    if ("titleFontSizeIos" in $$props)
      $$invalidate(13, titleFontSizeIos = $$new_props.titleFontSizeIos);
    if ("titleFontSizeMaterial" in $$props)
      $$invalidate(14, titleFontSizeMaterial = $$new_props.titleFontSizeMaterial);
    if ("opened" in $$props)
      $$invalidate(15, opened = $$new_props.opened);
    if ("backdrop" in $$props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("c" in $$props)
      $$invalidate(2, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(16, colors = $$new_props.colors);
    if ("state" in $$props)
      $$invalidate(3, state = $$new_props.state);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*opened*/
    32768) {
      $:
        $$invalidate(3, state = opened ? "opened" : "closed");
    }
    if ($$self.$$.dirty & /*colorsProp*/
    128) {
      $:
        $$invalidate(16, colors = DialogColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, translucent, sizeIos, sizeMaterial, titleFontSizeIos, titleFontSizeMaterial, colors, className*/
    98112) {
      $:
        $$invalidate(2, c = useThemeClasses(
          { ios, material },
          DialogClasses(
            {
              translucent,
              sizeIos,
              sizeMaterial,
              titleFontSizeIos,
              titleFontSizeMaterial
            },
            colors,
            className,
            { hasButtons: $$slots.buttons }
          ),
          className,
          (v) => $$invalidate(2, c = v)
        ));
    }
  };
  return [
    backdrop,
    onBackdropClick,
    c,
    state,
    $$slots,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    translucent,
    sizeIos,
    sizeMaterial,
    titleFontSizeIos,
    titleFontSizeMaterial,
    opened,
    colors,
    $$scope,
    slots
  ];
}
var Dialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      class: 6,
      colors: 7,
      ios: 8,
      material: 9,
      translucent: 10,
      sizeIos: 11,
      sizeMaterial: 12,
      titleFontSizeIos: 13,
      titleFontSizeMaterial: 14,
      opened: 15,
      backdrop: 0,
      onBackdropClick: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dialog",
      options,
      id: create_fragment23.name
    });
  }
  get class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translucent() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translucent(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sizeIos() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sizeIos(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sizeMaterial() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sizeMaterial(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontSizeIos() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontSizeIos(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontSizeMaterial() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontSizeMaterial(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBackdropClick() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBackdropClick(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dialog_default = Dialog;

// node_modules/konsta/shared/esm/classes/DialogButtonClasses.js
var DialogButtonClasses = (props, colors) => {
  const {
    strong,
    disabled
  } = props;
  return {
    base: {
      ios: cls("text-center text-[17px] flex items-center justify-center h-11 w-full hairline-r relative first:rounded-bl-xl last:rounded-br-xl", disabled ? colors.disabledTextIos : colors.textIos, strong && "font-semibold", !disabled && colors.activeBgIos)
    }
  };
};

// node_modules/konsta/shared/esm/colors/DialogButtonColors.js
var DialogButtonColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    activeBgIos: cls("active:bg-black active:bg-opacity-10", dark("dark:active:bg-white dark:active:bg-opacity-10")),
    textIos: "text-primary",
    disabledTextIos: cls("text-black text-opacity-30", dark("dark:text-white dark:text-opacity-30")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/DialogButton.svelte
var file23 = "node_modules/konsta/svelte/components/DialogButton.svelte";
function create_else_block_12(ctx) {
  let button;
  let current;
  const button_spread_levels = [
    { component: (
      /*component*/
      ctx[1]
    ) },
    { inline: true },
    { rounded: true },
    { disabled: (
      /*disabled*/
      ctx[2]
    ) },
    { clear: !/*isStrong*/
    ctx[5] },
    { class: (
      /*className*/
      ctx[0]
    ) },
    { onClick: (
      /*onClick*/
      ctx[3]
    ) },
    /*attrs*/
    ctx[7]
  ];
  let button_props = {
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  button = new Button_default({ props: button_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = dirty & /*component, disabled, isStrong, className, onClick, attrs*/
      175 ? get_spread_update(button_spread_levels, [
        dirty & /*component*/
        2 && { component: (
          /*component*/
          ctx2[1]
        ) },
        button_spread_levels[1],
        button_spread_levels[2],
        dirty & /*disabled*/
        4 && { disabled: (
          /*disabled*/
          ctx2[2]
        ) },
        dirty & /*isStrong*/
        32 && { clear: !/*isStrong*/
        ctx2[5] },
        dirty & /*className*/
        1 && { class: (
          /*className*/
          ctx2[0]
        ) },
        dirty & /*onClick*/
        8 && { onClick: (
          /*onClick*/
          ctx2[3]
        ) },
        dirty & /*attrs*/
        128 && get_spread_object(
          /*attrs*/
          ctx2[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      65536) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(79:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_15, create_else_block5];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (typeof /*component*/
    ctx2[1] === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(57:0) {#if theme === 'ios'}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(80:2) <Button     {component}     inline     rounded     {disabled}     clear={!isStrong}     class={className}     {onClick}     {...attrs}   >",
    ctx
  });
  return block;
}
function create_else_block5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { class: (
      /*c*/
      ctx[6].base
    ) },
    { disabled: (
      /*disabled*/
      ctx[2]
    ) },
    /*attrs*/
    ctx[7]
  ];
  var switch_value = (
    /*component*/
    ctx[1]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on("click", function() {
      if (is_function(
        /*onClick*/
        ctx[3]
      ))
        ctx[3].apply(this, arguments);
    });
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = dirty & /*c, disabled, attrs*/
      196 ? get_spread_update(switch_instance_spread_levels, [
        dirty & /*c*/
        64 && { class: (
          /*c*/
          ctx[6].base
        ) },
        dirty & /*disabled*/
        4 && { disabled: (
          /*disabled*/
          ctx[2]
        ) },
        dirty & /*attrs*/
        128 && get_spread_object(
          /*attrs*/
          ctx[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      65536) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (switch_value !== (switch_value = /*component*/
      ctx[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          switch_instance.$on("click", function() {
            if (is_function(
              /*onClick*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          });
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(68:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let previous_tag = (
    /*component*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[1]
  );
  let svelte_element = (
    /*component*/
    ctx[1] && create_dynamic_element5(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*component*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element5(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element5(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[1];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(58:2) {#if typeof component === 'string'}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(69:4) <svelte:component       this={component}       class={c.base}       {disabled}       {...attrs}       on:click={onClick}     >",
    ctx
  });
  return block;
}
function create_dynamic_element5(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*c*/
      ctx[6].base
    },
    { disabled: (
      /*disabled*/
      ctx[2]
    ) },
    /*attrs*/
    ctx[7]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[1]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[1] || "null").toUpperCase(),
        { class: true, disabled: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*component*/
        ctx[1]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file23, 58, 4, 1419);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          svelte_element,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*c*/
        64 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx[6].base)) && { class: svelte_element_class_value },
        (!current || dirty & /*disabled*/
        4) && { disabled: (
          /*disabled*/
          ctx[2]
        ) },
        dirty & /*attrs*/
        128 && /*attrs*/
        ctx[7]
      ]);
      if (/-/.test(
        /*component*/
        ctx[1]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element5.name,
    type: "child_dynamic_element",
    source: "(59:4) <svelte:element       this={component}       class={c.base}       {disabled}       {...attrs}       on:click={onClick}     >",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block9, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*theme*/
      ctx2[4] === "ios"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let isStrong;
  let attrs;
  let colors;
  let c;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "component",
    "disabled",
    "strong",
    "strongIos",
    "strongMaterial",
    "onClick"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogButton", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "button" } = $$props;
  let { disabled = false } = $$props;
  let { strong = void 0 } = $$props;
  let { strongIos = void 0 } = $$props;
  let { strongMaterial = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let theme;
  theme = useTheme({}, (v) => $$invalidate(4, theme = v));
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(8, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(9, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(10, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(1, component = $$new_props.component);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("strong" in $$new_props)
      $$invalidate(11, strong = $$new_props.strong);
    if ("strongIos" in $$new_props)
      $$invalidate(12, strongIos = $$new_props.strongIos);
    if ("strongMaterial" in $$new_props)
      $$invalidate(13, strongMaterial = $$new_props.strongMaterial);
    if ("onClick" in $$new_props)
      $$invalidate(3, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useThemeClasses,
    useTheme,
    useDarkClasses,
    DialogButtonClasses,
    DialogButtonColors,
    Button: Button_default,
    className,
    colorsProp,
    ios,
    material,
    component,
    disabled,
    strong,
    strongIos,
    strongMaterial,
    onClick,
    theme,
    dark,
    c,
    colors,
    isStrong,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(8, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(9, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(10, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(1, component = $$new_props.component);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("strong" in $$props)
      $$invalidate(11, strong = $$new_props.strong);
    if ("strongIos" in $$props)
      $$invalidate(12, strongIos = $$new_props.strongIos);
    if ("strongMaterial" in $$props)
      $$invalidate(13, strongMaterial = $$new_props.strongMaterial);
    if ("onClick" in $$props)
      $$invalidate(3, onClick = $$new_props.onClick);
    if ("theme" in $$props)
      $$invalidate(4, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(6, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(14, colors = $$new_props.colors);
    if ("isStrong" in $$props)
      $$invalidate(5, isStrong = $$new_props.isStrong);
    if ("attrs" in $$props)
      $$invalidate(7, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*strong, theme, strongIos, strongMaterial*/
    14352) {
      $:
        $$invalidate(5, isStrong = typeof strong === "undefined" ? theme === "ios" ? strongIos : strongMaterial : strong);
    }
    $:
      $$invalidate(7, attrs = { ...$$restProps });
    if ($$self.$$.dirty & /*colorsProp*/
    256) {
      $:
        $$invalidate(14, colors = DialogButtonColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, disabled, isStrong, colors, className*/
    17957) {
      $:
        $$invalidate(6, c = useThemeClasses({ ios, material }, DialogButtonClasses({ disabled, strong: isStrong }, colors, className, dark), "", (v) => $$invalidate(6, c = v)));
    }
  };
  return [
    className,
    component,
    disabled,
    onClick,
    theme,
    isStrong,
    c,
    attrs,
    colorsProp,
    ios,
    material,
    strong,
    strongIos,
    strongMaterial,
    colors,
    slots,
    $$scope
  ];
}
var DialogButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      class: 0,
      colors: 8,
      ios: 9,
      material: 10,
      component: 1,
      disabled: 2,
      strong: 11,
      strongIos: 12,
      strongMaterial: 13,
      onClick: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogButton",
      options,
      id: create_fragment24.name
    });
  }
  get class() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strong() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strong(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongIos() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongIos(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongMaterial() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongMaterial(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<DialogButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<DialogButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogButton_default = DialogButton;

// node_modules/konsta/shared/esm/classes/FabClasses.js
var FabClasses = (props, colors) => {
  return {
    base: {
      common: `flex items-center justify-center space-x-2 cursor-pointer overflow-hidden select-none`,
      ios: `h-12 duration-100 rounded-full shadow-lg ${colors.bgIos} ${colors.activeBgIos} ${colors.textIos}`,
      material: `duration-300 rounded-2xl shadow ${colors.bgMaterial} ${colors.activeBgMaterial} ${colors.textMaterial} ${colors.touchRipple}`,
      iconOnly: {
        ios: "w-12",
        material: "w-14 h-14"
      },
      withText: {
        common: "px-4",
        material: "h-14"
      }
    },
    text: {
      common: "text-sm",
      ios: "font-semibold uppercase",
      material: "font-medium"
    },
    icon: {
      common: "h-1em w-1em",
      ios: "text-icon-ios",
      material: "text-icon-material"
    }
  };
};

// node_modules/konsta/shared/esm/colors/FabColors.js
var FabColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: "bg-primary",
    bgMaterial: cls("bg-md-light-primary-container", dark("dark:bg-md-dark-primary-container")),
    activeBgIos: "active:bg-ios-primary-shade",
    activeBgMaterial: "",
    textIos: "text-white",
    textMaterial: cls("text-md-light-on-primary-container", dark("dark:text-md-dark-on-primary-container")),
    touchRipple: cls("touch-ripple-primary", dark("dark:touch-ripple-white")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Fab.svelte
var file24 = "node_modules/konsta/svelte/components/Fab.svelte";
var get_text_slot_changes_1 = (dirty) => ({});
var get_text_slot_context_1 = (ctx) => ({});
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx) => ({});
var get_text_slot_changes = (dirty) => ({});
var get_text_slot_context = (ctx) => ({});
function create_if_block_23(ctx) {
  let span;
  let t;
  let span_class_value;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[15].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_text_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*text*/
        ctx[1]
      );
      if (text_slot)
        text_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*text*/
        ctx[1]
      );
      if (text_slot)
        text_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[5].text);
      add_location(span, file24, 45, 4, 1199);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
      if (text_slot) {
        text_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*text*/
      2)
        set_data_dev(
          t,
          /*text*/
          ctx2[1]
        );
      if (text_slot) {
        if (text_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_text_slot_changes
            ),
            get_text_slot_context
          );
        }
      }
      if (!current || dirty & /*c*/
      32 && span_class_value !== (span_class_value = /*c*/
      ctx2[5].text)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(45:2) {#if (text || $$slots.text) && textPosition === 'before'}",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let span;
  let span_class_value;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[15].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_icon_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (icon_slot)
        icon_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (icon_slot)
        icon_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[5].icon);
      add_location(span, file24, 48, 4, 1287);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (icon_slot) {
        icon_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_icon_slot_changes
            ),
            get_icon_slot_context
          );
        }
      }
      if (!current || dirty & /*c*/
      32 && span_class_value !== (span_class_value = /*c*/
      ctx2[5].icon)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(48:2) {#if $$slots.icon}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let span;
  let t;
  let span_class_value;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[15].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_text_slot_context_1
  );
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*text*/
        ctx[1]
      );
      if (text_slot)
        text_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*text*/
        ctx[1]
      );
      if (text_slot)
        text_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[5].text);
      add_location(span, file24, 51, 4, 1407);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
      if (text_slot) {
        text_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*text*/
      2)
        set_data_dev(
          t,
          /*text*/
          ctx2[1]
        );
      if (text_slot) {
        if (text_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_text_slot_changes_1
            ),
            get_text_slot_context_1
          );
        }
      }
      if (!current || dirty & /*c*/
      32 && span_class_value !== (span_class_value = /*c*/
      ctx2[5].text)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(51:2) {#if (text || $$slots.text) && textPosition === 'after'}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let a;
  let t0;
  let t1;
  let t2;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*text*/
    (ctx[1] || /*$$slots*/
    ctx[7].text) && /*textPosition*/
    ctx[2] === "before" && create_if_block_23(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[7].icon && create_if_block_16(ctx)
  );
  let if_block2 = (
    /*text*/
    (ctx[1] || /*$$slots*/
    ctx[7].text) && /*textPosition*/
    ctx[2] === "after" && create_if_block10(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let a_levels = [
    {
      class: a_class_value = /*text*/
      ctx[1] ? (
        /*c*/
        ctx[5].base.withText
      ) : (
        /*c*/
        ctx[5].base.iconOnly
      )
    },
    { href: (
      /*href*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      if (if_block0)
        if_block0.l(a_nodes);
      t0 = claim_space(a_nodes);
      if (if_block1)
        if_block1.l(a_nodes);
      t1 = claim_space(a_nodes);
      if (if_block2)
        if_block2.l(a_nodes);
      t2 = claim_space(a_nodes);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file24, 37, 0, 999);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (if_block0)
        if_block0.m(a, null);
      append_hydration_dev(a, t0);
      if (if_block1)
        if_block1.m(a, null);
      append_hydration_dev(a, t1);
      if (if_block2)
        if_block2.m(a, null);
      append_hydration_dev(a, t2);
      if (default_slot) {
        default_slot.m(a, null);
      }
      ctx[16](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*text*/
        (ctx[1] || /*$$slots*/
        ctx[7].text) && /*textPosition*/
        ctx[2] === "before"
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*text, $$slots, textPosition*/
          134) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_23(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(a, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx[7].icon
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_16(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(a, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*text*/
        (ctx[1] || /*$$slots*/
        ctx[7].text) && /*textPosition*/
        ctx[2] === "after"
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty & /*text, $$slots, textPosition*/
          134) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block10(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(a, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*text, c*/
        34 && a_class_value !== (a_class_value = /*text*/
        ctx[1] ? (
          /*c*/
          ctx[5].base.withText
        ) : (
          /*c*/
          ctx[5].base.iconOnly
        ))) && { class: a_class_value },
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx[0]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[16](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let colors;
  let c;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "href",
    "text",
    "textPosition",
    "touchRipple",
    "onClick"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fab", slots, ["text", "icon", "default"]);
  const $$slots = compute_slots(slots);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { textPosition = "after" } = $$props;
  let { touchRipple = true } = $$props;
  let { onClick = void 0 } = $$props;
  const rippleEl = { current: null };
  const dark = useDarkClasses();
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(4, rippleEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(9, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(10, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(11, material = $$new_props.material);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("text" in $$new_props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("textPosition" in $$new_props)
      $$invalidate(2, textPosition = $$new_props.textPosition);
    if ("touchRipple" in $$new_props)
      $$invalidate(12, touchRipple = $$new_props.touchRipple);
    if ("onClick" in $$new_props)
      $$invalidate(3, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useThemeClasses,
    useTouchRipple,
    useDarkClasses,
    FabClasses,
    FabColors,
    className,
    colorsProp,
    ios,
    material,
    href,
    text: text2,
    textPosition,
    touchRipple,
    onClick,
    rippleEl,
    dark,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(9, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(10, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(11, material = $$new_props.material);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("text" in $$props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("textPosition" in $$props)
      $$invalidate(2, textPosition = $$new_props.textPosition);
    if ("touchRipple" in $$props)
      $$invalidate(12, touchRipple = $$new_props.touchRipple);
    if ("onClick" in $$props)
      $$invalidate(3, onClick = $$new_props.onClick);
    if ("c" in $$props)
      $$invalidate(5, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(13, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*rippleEl, touchRipple*/
    4112) {
      $:
        useTouchRipple(rippleEl, touchRipple);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    512) {
      $:
        $$invalidate(13, colors = FabColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    11520) {
      $:
        $$invalidate(5, c = useThemeClasses({ ios, material }, FabClasses({}, colors), className, (v) => $$invalidate(5, c = v)));
    }
  };
  return [
    href,
    text2,
    textPosition,
    onClick,
    rippleEl,
    c,
    $$restProps,
    $$slots,
    className,
    colorsProp,
    ios,
    material,
    touchRipple,
    colors,
    $$scope,
    slots,
    a_binding
  ];
}
var Fab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      class: 8,
      colors: 9,
      ios: 10,
      material: 11,
      href: 0,
      text: 1,
      textPosition: 2,
      touchRipple: 12,
      onClick: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fab",
      options,
      id: create_fragment25.name
    });
  }
  get class() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textPosition() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textPosition(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Fab_default = Fab;

// node_modules/konsta/shared/esm/classes/IconClasses.js
var IconClasses = (props, classes) => {
  return {
    base: `${positionClass("relative", classes)} inline-block not-italic`,
    badge: "absolute -right-1.5 -top-0.5"
  };
};

// node_modules/konsta/svelte/components/Icon.svelte
var file25 = "node_modules/konsta/svelte/components/Icon.svelte";
var get_material_slot_changes = (dirty) => ({});
var get_material_slot_context = (ctx) => ({});
var get_ios_slot_changes = (dirty) => ({});
var get_ios_slot_context = (ctx) => ({});
function create_else_block6(ctx) {
  let t0_value = (
    /*material*/
    (ctx[1] || "") + ""
  );
  let t0;
  let t1;
  let current;
  const material_slot_template = (
    /*#slots*/
    ctx[8].material
  );
  const material_slot = create_slot(
    material_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_material_slot_context
  );
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      if (material_slot)
        material_slot.c();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
      if (material_slot)
        material_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (material_slot) {
        material_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*material*/
      2) && t0_value !== (t0_value = /*material*/
      (ctx2[1] || "") + ""))
        set_data_dev(t0, t0_value);
      if (material_slot) {
        if (material_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            material_slot,
            material_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              material_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_material_slot_changes
            ),
            get_material_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(material_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(material_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (material_slot)
        material_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(30:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let t0_value = (
    /*ios*/
    (ctx[0] || "") + ""
  );
  let t0;
  let t1;
  let current;
  const ios_slot_template = (
    /*#slots*/
    ctx[8].ios
  );
  const ios_slot = create_slot(
    ios_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_ios_slot_context
  );
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      if (ios_slot)
        ios_slot.c();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
      if (ios_slot)
        ios_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (ios_slot) {
        ios_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*ios*/
      1) && t0_value !== (t0_value = /*ios*/
      (ctx2[0] || "") + ""))
        set_data_dev(t0, t0_value);
      if (ios_slot) {
        if (ios_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            ios_slot,
            ios_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              ios_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_ios_slot_changes
            ),
            get_ios_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(ios_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(ios_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (ios_slot)
        ios_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(27:2) {#if theme === 'ios'}",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge_default({
    props: {
      small: true,
      class: (
        /*c*/
        ctx[5].badge
      ),
      colors: (
        /*badgeColors*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(badge_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty & /*c*/
      32)
        badge_1_changes.class = /*c*/
        ctx2[5].badge;
      if (dirty & /*badgeColors*/
      8)
        badge_1_changes.colors = /*badgeColors*/
        ctx2[3];
      if (dirty & /*$$scope, badge*/
      516) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(35:2) {#if typeof badge !== 'undefined' && badge !== null && badge !== ''}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*badge*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*badge*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*badge*/
      4)
        set_data_dev(
          t,
          /*badge*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(36:4) <Badge small class={c.badge} colors={badgeColors}>",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let i;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let i_class_value;
  let current;
  const if_block_creators = [create_if_block_17, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*theme*/
      ctx2[4] === "ios"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = typeof /*badge*/
  ctx[2] !== "undefined" && /*badge*/
  ctx[2] !== null && /*badge*/
  ctx[2] !== "" && create_if_block11(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let i_levels = [
    { class: i_class_value = /*c*/
    ctx[5].base },
    /*$$restProps*/
    ctx[6]
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      var i_nodes = children(i);
      if_block0.l(i_nodes);
      t0 = claim_space(i_nodes);
      if (if_block1)
        if_block1.l(i_nodes);
      t1 = claim_space(i_nodes);
      if (default_slot)
        default_slot.l(i_nodes);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(i, i_data);
      add_location(i, file25, 25, 0, 608);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      if_blocks[current_block_type_index].m(i, null);
      append_hydration_dev(i, t0);
      if (if_block1)
        if_block1.m(i, null);
      append_hydration_dev(i, t1);
      if (default_slot) {
        default_slot.m(i, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(i, t0);
      }
      if (typeof /*badge*/
      ctx2[2] !== "undefined" && /*badge*/
      ctx2[2] !== null && /*badge*/
      ctx2[2] !== "") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*badge*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block11(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(i, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*c*/
        32 && i_class_value !== (i_class_value = /*c*/
        ctx2[5].base)) && { class: i_class_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let c;
  const omit_props_names = ["class", "ios", "material", "badge", "badgeColors"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, ["ios", "material", "default"]);
  let { class: className = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { badge = "" } = $$props;
  let { badgeColors = void 0 } = $$props;
  let theme;
  theme = useTheme({}, (v) => $$invalidate(4, theme = v));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("ios" in $$new_props)
      $$invalidate(0, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(1, material = $$new_props.material);
    if ("badge" in $$new_props)
      $$invalidate(2, badge = $$new_props.badge);
    if ("badgeColors" in $$new_props)
      $$invalidate(3, badgeColors = $$new_props.badgeColors);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useTheme,
    useThemeClasses,
    Badge: Badge_default,
    IconClasses,
    className,
    ios,
    material,
    badge,
    badgeColors,
    theme,
    c
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("ios" in $$props)
      $$invalidate(0, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(1, material = $$new_props.material);
    if ("badge" in $$props)
      $$invalidate(2, badge = $$new_props.badge);
    if ("badgeColors" in $$props)
      $$invalidate(3, badgeColors = $$new_props.badgeColors);
    if ("theme" in $$props)
      $$invalidate(4, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(5, c = $$new_props.c);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    128) {
      $:
        $$invalidate(5, c = useThemeClasses({}, IconClasses({}, className), className, (v) => $$invalidate(5, c = v)));
    }
  };
  return [
    ios,
    material,
    badge,
    badgeColors,
    theme,
    c,
    $$restProps,
    className,
    slots,
    $$scope
  ];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      class: 7,
      ios: 0,
      material: 1,
      badge: 2,
      badgeColors: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment26.name
    });
  }
  get class() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get badge() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set badge(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get badgeColors() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set badgeColors(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;

// node_modules/konsta/shared/esm/classes/LinkClasses.js
var LinkClasses = (props, _ref, classes) => {
  let {
    textColor,
    needsTouchRipple
  } = _ref;
  const {
    iconOnly,
    tabbar
  } = props;
  return {
    base: {
      common: cls(!tabbar && textColor, `inline-flex space-x-1 justify-center items-center cursor-pointer select-none`, needsTouchRipple && `touch-ripple-primary ${positionClass("relative", classes)} z-10`),
      notTabbar: {
        ios: `active:opacity-30 duration-300 active:duration-0`,
        material: needsTouchRipple ? "" : `active:opacity-55`
      }
    },
    tabbar: {
      common: cls(positionClass("relative", classes), `w-full h-full duration-300`),
      material: "font-medium text-sm z-10",
      active: "k-tabbar-link-active",
      inactive: ""
    },
    toolbar: {
      common: cls(`h-full max-h-12`, iconOnly && "k-touch-ripple-inset"),
      material: "px-3 text-sm font-medium"
    },
    navbar: {
      common: cls(`h-full max-h-12`, iconOnly && "k-touch-ripple-inset"),
      material: "px-3"
    }
  };
};

// node_modules/konsta/shared/esm/colors/LinkColors.js
var LinkColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    textIos: "text-primary",
    textMaterial: cls("text-md-light-primary", dark("dark:text-md-dark-primary")),
    navbarTextIos: "text-primary",
    navbarTextMaterial: "",
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Link.svelte
var file26 = "node_modules/konsta/svelte/components/Link.svelte";
function create_dynamic_element6(ctx) {
  let svelte_element;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  let svelte_element_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[0]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[0] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file26, 82, 0, 2093);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[24](svelte_element);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          svelte_element,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[22],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx[3]
        ) },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx[4]
      ]);
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element6.name,
    type: "child_dynamic_element",
    source: "(83:0) <svelte:element   this={component}   bind:this={rippleEl.current}   class={classes}   {...$$restProps}   on:click={onClick} >",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let previous_tag = (
    /*component*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[0]
  );
  let svelte_element = (
    /*component*/
    ctx[0] && create_dynamic_element6(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*component*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element6(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element6(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[0];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let needsTouchRipple;
  let colors;
  let themeTextColor;
  let textColor;
  let tabbarState;
  let c;
  let classes;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "component",
    "navbar",
    "toolbar",
    "iconOnly",
    "tabbar",
    "tabbarActive",
    "touchRipple",
    "onClick"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "a" } = $$props;
  let { navbar = false } = $$props;
  let { toolbar = false } = $$props;
  let { iconOnly = false } = $$props;
  let { tabbar = false } = $$props;
  let { tabbarActive = false } = $$props;
  let { touchRipple = true } = $$props;
  let { onClick = void 0 } = $$props;
  const rippleEl = { current: null };
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(15, theme = v));
  const dark = useDarkClasses();
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(2, rippleEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(6, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(8, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(0, component = $$new_props.component);
    if ("navbar" in $$new_props)
      $$invalidate(9, navbar = $$new_props.navbar);
    if ("toolbar" in $$new_props)
      $$invalidate(10, toolbar = $$new_props.toolbar);
    if ("iconOnly" in $$new_props)
      $$invalidate(11, iconOnly = $$new_props.iconOnly);
    if ("tabbar" in $$new_props)
      $$invalidate(12, tabbar = $$new_props.tabbar);
    if ("tabbarActive" in $$new_props)
      $$invalidate(13, tabbarActive = $$new_props.tabbarActive);
    if ("touchRipple" in $$new_props)
      $$invalidate(14, touchRipple = $$new_props.touchRipple);
    if ("onClick" in $$new_props)
      $$invalidate(1, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cls,
    useTheme,
    useThemeClasses,
    useTouchRipple,
    useDarkClasses,
    LinkClasses,
    LinkColors,
    className,
    colorsProp,
    ios,
    material,
    component,
    navbar,
    toolbar,
    iconOnly,
    tabbar,
    tabbarActive,
    touchRipple,
    onClick,
    rippleEl,
    theme,
    dark,
    tabbarState,
    c,
    classes,
    needsTouchRipple,
    textColor,
    themeTextColor,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(6, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(8, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(0, component = $$new_props.component);
    if ("navbar" in $$props)
      $$invalidate(9, navbar = $$new_props.navbar);
    if ("toolbar" in $$props)
      $$invalidate(10, toolbar = $$new_props.toolbar);
    if ("iconOnly" in $$props)
      $$invalidate(11, iconOnly = $$new_props.iconOnly);
    if ("tabbar" in $$props)
      $$invalidate(12, tabbar = $$new_props.tabbar);
    if ("tabbarActive" in $$props)
      $$invalidate(13, tabbarActive = $$new_props.tabbarActive);
    if ("touchRipple" in $$props)
      $$invalidate(14, touchRipple = $$new_props.touchRipple);
    if ("onClick" in $$props)
      $$invalidate(1, onClick = $$new_props.onClick);
    if ("theme" in $$props)
      $$invalidate(15, theme = $$new_props.theme);
    if ("tabbarState" in $$props)
      $$invalidate(16, tabbarState = $$new_props.tabbarState);
    if ("c" in $$props)
      $$invalidate(17, c = $$new_props.c);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
    if ("needsTouchRipple" in $$props)
      $$invalidate(18, needsTouchRipple = $$new_props.needsTouchRipple);
    if ("textColor" in $$props)
      $$invalidate(19, textColor = $$new_props.textColor);
    if ("themeTextColor" in $$props)
      $$invalidate(20, themeTextColor = $$new_props.themeTextColor);
    if ("colors" in $$props)
      $$invalidate(21, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*theme, touchRipple, toolbar, tabbar, navbar*/
    54784) {
      $:
        $$invalidate(18, needsTouchRipple = theme === "material" && (touchRipple || typeof touchRipple === "undefined" && (toolbar || tabbar || navbar)));
    }
    if ($$self.$$.dirty & /*rippleEl, needsTouchRipple*/
    262148) {
      $:
        useTouchRipple(rippleEl, needsTouchRipple);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    64) {
      $:
        $$invalidate(21, colors = LinkColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*navbar, theme, colors*/
    2130432) {
      $:
        $$invalidate(20, themeTextColor = navbar ? theme === "material" ? colors.navbarTextMaterial : colors.navbarTextIos : theme === "material" ? colors.textMaterial : colors.textIos);
    }
    if ($$self.$$.dirty & /*tabbar, tabbarActive, colors, themeTextColor*/
    3158016) {
      $:
        $$invalidate(19, textColor = tabbar && !tabbarActive ? colors.tabbarInactive : themeTextColor);
    }
    if ($$self.$$.dirty & /*tabbarActive*/
    8192) {
      $:
        $$invalidate(16, tabbarState = tabbarActive ? "active" : "inactive");
    }
    if ($$self.$$.dirty & /*ios, material, iconOnly, textColor, needsTouchRipple, className*/
    788896) {
      $:
        $$invalidate(17, c = useThemeClasses({ ios, material }, LinkClasses({ iconOnly }, { textColor, needsTouchRipple }, className), "", (v) => $$invalidate(17, c = v)));
    }
    if ($$self.$$.dirty & /*c, tabbar, toolbar, navbar, tabbarState, className*/
    202272) {
      $:
        $$invalidate(3, classes = cls(
          // base
          c.base[tabbar ? "default" : "notTabbar"],
          toolbar && c.toolbar,
          navbar && c.navbar,
          tabbar && c.tabbar[tabbarState],
          className
        ));
    }
  };
  return [
    component,
    onClick,
    rippleEl,
    classes,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    navbar,
    toolbar,
    iconOnly,
    tabbar,
    tabbarActive,
    touchRipple,
    theme,
    tabbarState,
    c,
    needsTouchRipple,
    textColor,
    themeTextColor,
    colors,
    $$scope,
    slots,
    svelte_element_binding
  ];
}
var Link = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      class: 5,
      colors: 6,
      ios: 7,
      material: 8,
      component: 0,
      navbar: 9,
      toolbar: 10,
      iconOnly: 11,
      tabbar: 12,
      tabbarActive: 13,
      touchRipple: 14,
      onClick: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link",
      options,
      id: create_fragment27.name
    });
  }
  get class() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbar() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbar(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toolbar() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toolbar(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconOnly() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconOnly(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabbar() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabbar(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabbarActive() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabbarActive(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Link_default = Link;

// node_modules/konsta/shared/esm/classes/ListClasses.js
var ListClasses = (props, colors, classes) => {
  const {
    nested,
    margin,
    inset,
    strong,
    outline
  } = props;
  return {
    base: {
      common: cls(!nested && margin, !inset && !nested && outline && "hairline-t hairline-b", inset && outline && "border", positionClass("relative", classes), "z-10"),
      ios: cls(strong && colors.strongBgIos, inset && outline && colors.outlineIos),
      material: cls(strong && colors.strongBgMaterial, inset && outline && colors.outlineMaterial)
    },
    ul: {
      common: cls(inset && "no-safe-areas", "last-child-hairline-b-none")
    },
    inset: {
      common: `ml-4-safe mr-4-safe overflow-hidden`,
      ios: `rounded-lg`,
      material: `rounded-2xl`
    },
    menuList: {
      common: "py-1"
    }
  };
};

// node_modules/konsta/shared/esm/colors/ListColors.js
var ListColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    outlineIos: cls("border-black border-opacity-20", dark("dark:border-white dark:border-opacity-15")),
    outlineMaterial: cls("border-md-light-outline", dark("border-md-dark-outline")),
    strongBgIos: cls(`bg-ios-light-surface-1`, dark("dark:bg-ios-dark-surface-1")),
    strongBgMaterial: cls("bg-md-light-surface-1", dark("dark:bg-md-dark-surface-1")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/shared/set-reactive-context.js
var setReactiveContext = (name, getValue) => {
  const contextCallbacks = [];
  const contextSubscribe = (callback) => {
    contextCallbacks.push(callback);
  };
  const contextUnsubscribe = (callback) => {
    if (contextCallbacks.indexOf(callback) >= 0) {
      contextCallbacks.splice(contextCallbacks.indexOf, callback);
    }
  };
  const contextRunCallbacks = () => {
    contextCallbacks.forEach((callback) => {
      callback(getValue());
    });
  };
  setContext(name, {
    value: getValue(),
    subscribe: contextSubscribe,
    unsubscribe: contextUnsubscribe
  });
  beforeUpdate(() => {
    contextRunCallbacks();
  });
};

// node_modules/konsta/svelte/components/List.svelte
var file27 = "node_modules/konsta/svelte/components/List.svelte";
function create_fragment28(ctx) {
  let div;
  let ul;
  let ul_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = /*c*/
      ctx[0].ul);
      add_location(ul, file27, 91, 2, 2332);
      set_attributes(div, div_data);
      add_location(div, file27, 90, 0, 2291);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*c*/
      1 && ul_class_value !== (ul_class_value = /*c*/
      ctx2[0].ul)) {
        attr_dev(ul, "class", ul_class_value);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let hasDividers;
  let isStrong;
  let isOutline;
  let isInset;
  let colors;
  let c;
  let classes;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "margin",
    "dividers",
    "dividersIos",
    "dividersMaterial",
    "inset",
    "insetIos",
    "insetMaterial",
    "strong",
    "strongIos",
    "strongMaterial",
    "outline",
    "outlineIos",
    "outlineMaterial",
    "nested",
    "menuList"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { margin = "my-8" } = $$props;
  let { dividers = void 0 } = $$props;
  let { dividersIos = true } = $$props;
  let { dividersMaterial = false } = $$props;
  let { inset = void 0 } = $$props;
  let { insetIos = void 0 } = $$props;
  let { insetMaterial = void 0 } = $$props;
  let { strong = void 0 } = $$props;
  let { strongIos = void 0 } = $$props;
  let { strongMaterial = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { outlineIos = void 0 } = $$props;
  let { outlineMaterial = void 0 } = $$props;
  let { nested = false } = $$props;
  let { menuList = false } = $$props;
  let theme;
  theme = useTheme({}, (v) => $$invalidate(22, theme = v));
  const dark = useDarkClasses();
  setReactiveContext("ListDividersContext", () => ({ value: hasDividers }));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(4, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(5, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(6, material = $$new_props.material);
    if ("margin" in $$new_props)
      $$invalidate(7, margin = $$new_props.margin);
    if ("dividers" in $$new_props)
      $$invalidate(8, dividers = $$new_props.dividers);
    if ("dividersIos" in $$new_props)
      $$invalidate(9, dividersIos = $$new_props.dividersIos);
    if ("dividersMaterial" in $$new_props)
      $$invalidate(10, dividersMaterial = $$new_props.dividersMaterial);
    if ("inset" in $$new_props)
      $$invalidate(11, inset = $$new_props.inset);
    if ("insetIos" in $$new_props)
      $$invalidate(12, insetIos = $$new_props.insetIos);
    if ("insetMaterial" in $$new_props)
      $$invalidate(13, insetMaterial = $$new_props.insetMaterial);
    if ("strong" in $$new_props)
      $$invalidate(14, strong = $$new_props.strong);
    if ("strongIos" in $$new_props)
      $$invalidate(15, strongIos = $$new_props.strongIos);
    if ("strongMaterial" in $$new_props)
      $$invalidate(16, strongMaterial = $$new_props.strongMaterial);
    if ("outline" in $$new_props)
      $$invalidate(17, outline = $$new_props.outline);
    if ("outlineIos" in $$new_props)
      $$invalidate(18, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$new_props)
      $$invalidate(19, outlineMaterial = $$new_props.outlineMaterial);
    if ("nested" in $$new_props)
      $$invalidate(20, nested = $$new_props.nested);
    if ("menuList" in $$new_props)
      $$invalidate(21, menuList = $$new_props.menuList);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cls,
    ListClasses,
    ListColors,
    useDarkClasses,
    useThemeClasses,
    useTheme,
    setReactiveContext,
    className,
    colorsProp,
    ios,
    material,
    margin,
    dividers,
    dividersIos,
    dividersMaterial,
    inset,
    insetIos,
    insetMaterial,
    strong,
    strongIos,
    strongMaterial,
    outline,
    outlineIos,
    outlineMaterial,
    nested,
    menuList,
    theme,
    dark,
    c,
    isInset,
    classes,
    colors,
    isStrong,
    isOutline,
    hasDividers
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(4, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(5, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(6, material = $$new_props.material);
    if ("margin" in $$props)
      $$invalidate(7, margin = $$new_props.margin);
    if ("dividers" in $$props)
      $$invalidate(8, dividers = $$new_props.dividers);
    if ("dividersIos" in $$props)
      $$invalidate(9, dividersIos = $$new_props.dividersIos);
    if ("dividersMaterial" in $$props)
      $$invalidate(10, dividersMaterial = $$new_props.dividersMaterial);
    if ("inset" in $$props)
      $$invalidate(11, inset = $$new_props.inset);
    if ("insetIos" in $$props)
      $$invalidate(12, insetIos = $$new_props.insetIos);
    if ("insetMaterial" in $$props)
      $$invalidate(13, insetMaterial = $$new_props.insetMaterial);
    if ("strong" in $$props)
      $$invalidate(14, strong = $$new_props.strong);
    if ("strongIos" in $$props)
      $$invalidate(15, strongIos = $$new_props.strongIos);
    if ("strongMaterial" in $$props)
      $$invalidate(16, strongMaterial = $$new_props.strongMaterial);
    if ("outline" in $$props)
      $$invalidate(17, outline = $$new_props.outline);
    if ("outlineIos" in $$props)
      $$invalidate(18, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$props)
      $$invalidate(19, outlineMaterial = $$new_props.outlineMaterial);
    if ("nested" in $$props)
      $$invalidate(20, nested = $$new_props.nested);
    if ("menuList" in $$props)
      $$invalidate(21, menuList = $$new_props.menuList);
    if ("theme" in $$props)
      $$invalidate(22, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(0, c = $$new_props.c);
    if ("isInset" in $$props)
      $$invalidate(23, isInset = $$new_props.isInset);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("colors" in $$props)
      $$invalidate(24, colors = $$new_props.colors);
    if ("isStrong" in $$props)
      $$invalidate(25, isStrong = $$new_props.isStrong);
    if ("isOutline" in $$props)
      $$invalidate(26, isOutline = $$new_props.isOutline);
    if ("hasDividers" in $$props)
      hasDividers = $$new_props.hasDividers;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dividers, theme, dividersIos, dividersMaterial*/
    4196096) {
      $:
        hasDividers = typeof dividers === "undefined" ? theme === "ios" ? dividersIos : dividersMaterial : dividers;
    }
    if ($$self.$$.dirty & /*strong, theme, strongIos, strongMaterial*/
    4308992) {
      $:
        $$invalidate(25, isStrong = typeof strong === "undefined" ? theme === "ios" ? strongIos : strongMaterial : strong);
    }
    if ($$self.$$.dirty & /*outline, theme, outlineIos, outlineMaterial*/
    5111808) {
      $:
        $$invalidate(26, isOutline = typeof outline === "undefined" ? theme === "ios" ? outlineIos : outlineMaterial : outline);
    }
    if ($$self.$$.dirty & /*inset, theme, insetIos, insetMaterial*/
    4208640) {
      $:
        $$invalidate(23, isInset = typeof inset === "undefined" ? theme === "ios" ? insetIos : insetMaterial : inset);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    16) {
      $:
        $$invalidate(24, colors = ListColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, nested, margin, isInset, isOutline, isStrong, colors, className*/
    126877928) {
      $:
        $$invalidate(0, c = useThemeClasses(
          { ios, material },
          ListClasses(
            {
              nested,
              margin,
              inset: isInset,
              outline: isOutline,
              strong: isStrong
            },
            colors,
            className
          ),
          "",
          (v) => $$invalidate(0, c = v)
        ));
    }
    if ($$self.$$.dirty & /*c, isInset, menuList, className*/
    10485769) {
      $:
        $$invalidate(1, classes = cls(c.base, isInset && c.inset, menuList && c.menuList, className));
    }
  };
  return [
    c,
    classes,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    margin,
    dividers,
    dividersIos,
    dividersMaterial,
    inset,
    insetIos,
    insetMaterial,
    strong,
    strongIos,
    strongMaterial,
    outline,
    outlineIos,
    outlineMaterial,
    nested,
    menuList,
    theme,
    isInset,
    colors,
    isStrong,
    isOutline,
    $$scope,
    slots
  ];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      class: 3,
      colors: 4,
      ios: 5,
      material: 6,
      margin: 7,
      dividers: 8,
      dividersIos: 9,
      dividersMaterial: 10,
      inset: 11,
      insetIos: 12,
      insetMaterial: 13,
      strong: 14,
      strongIos: 15,
      strongMaterial: 16,
      outline: 17,
      outlineIos: 18,
      outlineMaterial: 19,
      nested: 20,
      menuList: 21
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment28.name
    });
  }
  get class() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get margin() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set margin(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dividers() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dividers(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dividersIos() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dividersIos(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dividersMaterial() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dividersMaterial(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inset() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inset(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetIos() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetIos(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetMaterial() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetMaterial(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strong() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strong(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongIos() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongIos(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongMaterial() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongMaterial(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineIos() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineIos(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineMaterial() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineMaterial(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nested() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nested(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var List_default = List;

// node_modules/konsta/svelte/components/ListGroup.svelte
var file28 = "node_modules/konsta/svelte/components/ListGroup.svelte";
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(6:2) <List nested {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let li;
  let list;
  let current;
  const list_spread_levels = [
    { nested: true },
    /*$$restProps*/
    ctx[0]
  ];
  let list_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < list_spread_levels.length; i += 1) {
    list_props = assign(list_props, list_spread_levels[i]);
  }
  list = new List_default({ props: list_props, $$inline: true });
  const block = {
    c: function create() {
      li = element("li");
      create_component(list.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      claim_component(list.$$.fragment, li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(li, file28, 4, 0, 56);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      mount_component(list, li, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const list_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(list_spread_levels, [list_spread_levels[0], get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      destroy_component(list);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListGroup", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ List: List_default });
  return [$$restProps, slots, $$scope];
}
var ListGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListGroup",
      options,
      id: create_fragment29.name
    });
  }
};
var ListGroup_default = ListGroup;

// node_modules/konsta/shared/esm/classes/ListButtonClasses.js
var ListButtonClasses = (props, colors, classes) => {
  const {
    dividers
  } = props;
  return {
    base: ``,
    button: {
      common: cls(positionClass("relative", classes), dividers && "hairline-b active:hairline-transparent", `flex items-center justify-center px-4 space-x-1 w-full duration-300 active:duration-0 focus:outline-none ${colors.touchRipple} overflow-hidden select-none`),
      ios: cls("h-11", colors.textIos, colors.activeBgIos, colors.activeBgIos),
      material: cls("h-12", colors.textMaterial, colors.activeBgMaterial)
    }
  };
};

// node_modules/konsta/shared/esm/colors/ListButtonColors.js
var ListButtonColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    textIos: "text-primary",
    textMaterial: cls("text-md-light-primary", dark("dark:text-md-dark-primary")),
    activeBgIos: "active:bg-primary active:bg-opacity-15",
    activeBgMaterial: "",
    touchRipple: "touch-ripple-primary",
    ...colorsProp
  };
};

// node_modules/konsta/svelte/shared/get-reactive-context.js
var getReactiveContext = (name, setValue) => {
  const ctx = getContext(name);
  if (!ctx)
    return void 0;
  const { value, subscribe, unsubscribe } = ctx;
  subscribe(setValue);
  onDestroy(() => {
    unsubscribe(setValue);
  });
  return value;
};

// node_modules/konsta/svelte/components/ListButton.svelte
var file29 = "node_modules/konsta/svelte/components/ListButton.svelte";
function create_else_block7(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { class: (
      /*c*/
      ctx[2].button
    ) },
    /*buttonAttrs*/
    ctx[1]
  ];
  var switch_value = (
    /*ButtonComponent*/
    ctx[3]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[23](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & /*c, buttonAttrs*/
      6 ? get_spread_update(switch_instance_spread_levels, [
        dirty & /*c*/
        4 && { class: (
          /*c*/
          ctx2[2].button
        ) },
        dirty & /*buttonAttrs*/
        2 && get_spread_object(
          /*buttonAttrs*/
          ctx2[1]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      16777216) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = /*ButtonComponent*/
      ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[23](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[23](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(80:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block12(ctx) {
  let previous_tag = (
    /*ButtonComponent*/
    ctx[3]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*ButtonComponent*/
    ctx[3]
  );
  validate_void_dynamic_element(
    /*ButtonComponent*/
    ctx[3]
  );
  let svelte_element = (
    /*ButtonComponent*/
    ctx[3] && create_dynamic_element7(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*ButtonComponent*/
        ctx2[3]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element7(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*ButtonComponent*/
          ctx2[3]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*ButtonComponent*/
            ctx2[3]
          );
          validate_void_dynamic_element(
            /*ButtonComponent*/
            ctx2[3]
          );
          svelte_element = create_dynamic_element7(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*ButtonComponent*/
      ctx2[3];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(70:2) {#if typeof ButtonComponent === 'string'}",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[24],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(81:4) <svelte:component       this={ButtonComponent}       bind:this={rippleEl.current}       class={c.button}       {...buttonAttrs}     >",
    ctx
  });
  return block;
}
function create_dynamic_element7(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*c*/
      ctx[2].button
    },
    /*buttonAttrs*/
    ctx[1]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*ButtonComponent*/
        ctx[3]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*ButtonComponent*/
        (ctx[3] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*ButtonComponent*/
        ctx[3]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file29, 71, 4, 1991);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[22](svelte_element);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[24],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*c*/
        4 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx2[2].button)) && { class: svelte_element_class_value },
        dirty & /*buttonAttrs*/
        2 && /*buttonAttrs*/
        ctx2[1]
      ]);
      if (/-/.test(
        /*ButtonComponent*/
        ctx2[3]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element7.name,
    type: "child_dynamic_element",
    source: "(72:4) <svelte:element       this={ButtonComponent}       bind:this={rippleEl.current}       class={c.button}       {...buttonAttrs}     >",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let li_class_value;
  let current;
  const if_block_creators = [create_if_block12, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*ButtonComponent*/
    ctx2[3] === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [
    {
      class: li_class_value = /*c*/
      ctx[2].base
    },
    /*$$restProps*/
    ctx[4]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      if_block.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      add_location(li, file29, 68, 0, 1856);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*c*/
        4 && li_class_value !== (li_class_value = /*c*/
        ctx2[2].base)) && { class: li_class_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let colors;
  let c;
  let isLink;
  let hrefComputed;
  let buttonAttrs;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "href",
    "target",
    "type",
    "value",
    "linkProps",
    "touchRipple",
    "linkComponent"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListButton", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { linkProps = {} } = $$props;
  let { touchRipple = true } = $$props;
  let { linkComponent = "a" } = $$props;
  let ListDividersContext = getReactiveContext("ListDividersContext", (value2) => {
    $$invalidate(16, ListDividersContext = value2 || {});
  }) || { value: false };
  const rippleEl = { current: null };
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(17, theme = v));
  const dark = useDarkClasses();
  const ButtonComponent = isLink ? linkComponent : "button";
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(0, rippleEl);
    });
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(0, rippleEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(6, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(8, material = $$new_props.material);
    if ("href" in $$new_props)
      $$invalidate(9, href = $$new_props.href);
    if ("target" in $$new_props)
      $$invalidate(10, target = $$new_props.target);
    if ("type" in $$new_props)
      $$invalidate(11, type = $$new_props.type);
    if ("value" in $$new_props)
      $$invalidate(12, value = $$new_props.value);
    if ("linkProps" in $$new_props)
      $$invalidate(13, linkProps = $$new_props.linkProps);
    if ("touchRipple" in $$new_props)
      $$invalidate(14, touchRipple = $$new_props.touchRipple);
    if ("linkComponent" in $$new_props)
      $$invalidate(15, linkComponent = $$new_props.linkComponent);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useThemeClasses,
    useDarkClasses,
    useTouchRipple,
    ListButtonClasses,
    ListButtonColors,
    useTheme,
    getReactiveContext,
    className,
    colorsProp,
    ios,
    material,
    href,
    target,
    type,
    value,
    linkProps,
    touchRipple,
    linkComponent,
    ListDividersContext,
    rippleEl,
    theme,
    dark,
    ButtonComponent,
    isLink,
    hrefComputed,
    buttonAttrs,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(6, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(8, material = $$new_props.material);
    if ("href" in $$props)
      $$invalidate(9, href = $$new_props.href);
    if ("target" in $$props)
      $$invalidate(10, target = $$new_props.target);
    if ("type" in $$props)
      $$invalidate(11, type = $$new_props.type);
    if ("value" in $$props)
      $$invalidate(12, value = $$new_props.value);
    if ("linkProps" in $$props)
      $$invalidate(13, linkProps = $$new_props.linkProps);
    if ("touchRipple" in $$props)
      $$invalidate(14, touchRipple = $$new_props.touchRipple);
    if ("linkComponent" in $$props)
      $$invalidate(15, linkComponent = $$new_props.linkComponent);
    if ("ListDividersContext" in $$props)
      $$invalidate(16, ListDividersContext = $$new_props.ListDividersContext);
    if ("theme" in $$props)
      $$invalidate(17, theme = $$new_props.theme);
    if ("isLink" in $$props)
      $$invalidate(18, isLink = $$new_props.isLink);
    if ("hrefComputed" in $$props)
      $$invalidate(19, hrefComputed = $$new_props.hrefComputed);
    if ("buttonAttrs" in $$props)
      $$invalidate(1, buttonAttrs = $$new_props.buttonAttrs);
    if ("c" in $$props)
      $$invalidate(2, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(20, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*rippleEl, touchRipple*/
    16385) {
      $:
        useTouchRipple(rippleEl, touchRipple);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    64) {
      $:
        $$invalidate(20, colors = ListButtonColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, ListDividersContext, colors, className, theme*/
    1245600) {
      $:
        $$invalidate(2, c = useThemeClasses({ ios, material }, ListButtonClasses({ dividers: ListDividersContext.value }, colors, className, theme), className, (v) => $$invalidate(2, c = v)));
    }
    if ($$self.$$.dirty & /*href*/
    512) {
      $:
        $$invalidate(18, isLink = !!href || href === "");
    }
    if ($$self.$$.dirty & /*isLink, href*/
    262656) {
      $:
        $$invalidate(19, hrefComputed = !isLink || href === true || href === false ? void 0 : href || "");
    }
    if ($$self.$$.dirty & /*hrefComputed, target, type, value, linkProps*/
    539648) {
      $:
        $$invalidate(1, buttonAttrs = {
          href: hrefComputed,
          target,
          type,
          value,
          ...linkProps
        });
    }
  };
  return [
    rippleEl,
    buttonAttrs,
    c,
    ButtonComponent,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    href,
    target,
    type,
    value,
    linkProps,
    touchRipple,
    linkComponent,
    ListDividersContext,
    theme,
    isLink,
    hrefComputed,
    colors,
    slots,
    svelte_element_binding,
    switch_instance_binding,
    $$scope
  ];
}
var ListButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      class: 5,
      colors: 6,
      ios: 7,
      material: 8,
      href: 9,
      target: 10,
      type: 11,
      value: 12,
      linkProps: 13,
      touchRipple: 14,
      linkComponent: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListButton",
      options,
      id: create_fragment30.name
    });
  }
  get class() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linkProps() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linkProps(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linkComponent() {
    throw new Error("<ListButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linkComponent(value) {
    throw new Error("<ListButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListButton_default = ListButton;

// node_modules/konsta/shared/esm/classes/ListItemClasses.js
var ListItemClasses = (props, colors, _ref) => {
  let {
    className,
    isMediaItem,
    theme,
    textColor,
    needsTouchRipple,
    isMenuListItemActive,
    autoStrongTitle
  } = _ref;
  const {
    menuListItem,
    dividers,
    mediaClassName = "",
    mediaClass = "",
    innerClassName = "",
    innerClass = "",
    contentClassName = "",
    contentClass = "",
    titleWrapClassName = "",
    titleWrapClass = "",
    titleFontSizeIos,
    titleFontSizeMaterial,
    strongTitle
  } = props;
  return {
    base: menuListItem ? `${textColor} py-1` : "",
    itemContent: {
      common: cls(`flex items-center ${contentClassName || contentClass}`),
      ios: cls(!menuListItem && cls(colors.primaryTextIos, "pl-4-safe"), menuListItem && "rounded-lg ml-2-safe mr-2-safe pl-2"),
      material: cls(!menuListItem && cls(colors.primaryTextMaterial, isMediaItem ? "ml-2-safe mr-2-safe rounded-2xl pl-2" : "pl-4-safe"), menuListItem && "rounded-full min-h-[3.5rem] ml-4-safe mr-4-safe pl-4"),
      link: cls("duration-300 active:duration-0 cursor-pointer select-none", dividers && theme === "ios" && "active:hairline-transparent", needsTouchRipple && cls(`relative overflow-hidden z-10`, colors.touchRipple), isMenuListItemActive ? cls(theme === "ios" ? colors.menuListItemActiveBgIos : colors.menuListItemActiveBgMaterial) : menuListItem ? cls(theme === "ios" ? colors.menuListItemBgIos : colors.menuListItemBgMaterial) : cls(theme === "ios" ? colors.activeBgIos : colors.activeBgMaterial))
    },
    media: {
      common: `shrink-0 flex ${mediaClassName || mediaClass}`,
      ios: "py-2 mr-4",
      material: cls("py-3", menuListItem ? "mr-3" : "mr-4")
    },
    inner: {
      common: cls("w-full relative", !menuListItem && dividers && "hairline-b", innerClassName || innerClass),
      ios: "py-2.5 pr-4-safe",
      material: cls("py-3", isMediaItem && !menuListItem ? "pr-2" : "pr-4-safe")
    },
    titleWrap: {
      common: cls(`flex justify-between items-center ${titleWrapClassName || titleWrapClass}`),
      ios: cls(!menuListItem && titleFontSizeIos),
      material: cls(!menuListItem && titleFontSizeMaterial)
    },
    title: {
      common: `shrink`,
      menuListItem: cls("text-sm", strongTitle === true || autoStrongTitle ? "font-semibold" : "font-medium"),
      strong: {
        common: "",
        ios: "font-semibold",
        material: "font-medium"
      }
    },
    after: {
      common: cls(`shrink-0 ml-auto pl-1 flex items-center space-x-1`),
      ios: colors.secondaryTextIos,
      material: cls(colors.secondaryTextMaterial, "text-sm")
    },
    chevron: "opacity-20 shrink-0 ml-3",
    subtitle: "text-sm",
    text: {
      common: cls(`text-sm line-clamp-2`),
      ios: colors.secondaryTextIos,
      material: colors.secondaryTextMaterial
    },
    header: {
      common: "text-xs mb-0.5",
      ios: colors.secondaryTextIos,
      material: colors.secondaryTextMaterial
    },
    footer: {
      common: cls(`text-xs mt-0.5`),
      ios: colors.secondaryTextIos,
      material: colors.secondaryTextMaterial
    },
    groupTitle: {
      common: cls(
        `pl-4-safe pr-4-safe py-1 flex items-center z-20`,
        positionClass("relative", className)
        // divider ? 'relative' : 'sticky top-0'
      ),
      ios: `h-8${dividers ? " hairline-t" : ""} -mt-px ${titleFontSizeIos} ${colors.secondaryTextIos} ${colors.groupTitleBgIos}`,
      material: `h-12 ${titleFontSizeMaterial} ${colors.secondaryTextMaterial} ${colors.groupTitleBgMaterial}`
    }
  };
};

// node_modules/konsta/shared/esm/colors/ListItemColors.js
var ListItemColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    primaryTextIos: cls(`text-black`, dark("dark:text-white")),
    primaryTextMaterial: cls(`text-md-light-on-surface`, dark("dark:text-md-dark-on-surface")),
    secondaryTextIos: cls("text-black text-opacity-55", dark("dark:text-white dark:text-opacity-55")),
    secondaryTextMaterial: cls("text-md-light-on-surface-variant", dark("dark:text-md-dark-on-surface-variant")),
    activeBgIos: cls(`active:bg-black active:bg-opacity-10`, dark("dark:active:bg-white dark:active:bg-opacity-10")),
    activeBgMaterial: "",
    groupTitleBgIos: cls("bg-ios-light-surface-variant", dark("dark:bg-ios-dark-surface-variant")),
    groupTitleBgMaterial: cls("bg-md-light-surface-2", dark("dark:bg-md-dark-surface-2")),
    menuListItemTextIos: cls(`text-black`, dark("dark:text-white")),
    menuListItemTextMaterial: cls(`text-md-light-on-surface-variant`, dark("dark:text-md-dark-on-surface-variant")),
    menuListItemBgIos: cls(`active:bg-black active:bg-opacity-10`, dark("dark:active:bg-white dark:active:bg-opacity-10")),
    menuListItemBgMaterial: cls("bg-md-light-surface-1", dark("dark:bg-md-dark-surface-1")),
    menuListItemActiveTextIos: cls(`text-primary`, dark("dark:text-white")),
    menuListItemActiveTextMaterial: cls(`text-md-light-on-secondary-container`, dark("dark:text-md-dark-on-secondary-container")),
    menuListItemActiveBgIos: cls(`bg-primary bg-opacity-15`, dark("dark:bg-primary")),
    menuListItemActiveBgMaterial: cls(`bg-md-light-secondary-container`, dark("dark:bg-md-dark-secondary-container")),
    touchRipple: cls("touch-ripple-black", dark("dark:touch-ripple-white")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/ListItem.svelte
var file30 = "node_modules/konsta/svelte/components/ListItem.svelte";
var get_content_slot_changes_1 = (dirty) => ({});
var get_content_slot_context_1 = (ctx) => ({});
var get_inner_slot_changes_1 = (dirty) => ({});
var get_inner_slot_context_1 = (ctx) => ({});
var get_footer_slot_changes_12 = (dirty) => ({});
var get_footer_slot_context_12 = (ctx) => ({});
var get_text_slot_changes_12 = (dirty) => ({});
var get_text_slot_context_12 = (ctx) => ({});
var get_subtitle_slot_changes_1 = (dirty) => ({});
var get_subtitle_slot_context_1 = (ctx) => ({});
var get_after_slot_changes_1 = (dirty) => ({});
var get_after_slot_context_1 = (ctx) => ({});
var get_title_slot_changes_2 = (dirty) => ({});
var get_title_slot_context_2 = (ctx) => ({});
var get_header_slot_changes_12 = (dirty) => ({});
var get_header_slot_context_12 = (ctx) => ({});
var get_media_slot_changes_1 = (dirty) => ({});
var get_media_slot_context_1 = (ctx) => ({});
var get_content_slot_changes = (dirty) => ({});
var get_content_slot_context = (ctx) => ({});
var get_inner_slot_changes = (dirty) => ({});
var get_inner_slot_context = (ctx) => ({});
var get_footer_slot_changes2 = (dirty) => ({});
var get_footer_slot_context2 = (ctx) => ({});
var get_text_slot_changes2 = (dirty) => ({});
var get_text_slot_context2 = (ctx) => ({});
var get_subtitle_slot_changes = (dirty) => ({});
var get_subtitle_slot_context = (ctx) => ({});
var get_after_slot_changes = (dirty) => ({});
var get_after_slot_context = (ctx) => ({});
var get_title_slot_changes_1 = (dirty) => ({});
var get_title_slot_context_1 = (ctx) => ({});
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
var get_media_slot_changes2 = (dirty) => ({});
var get_media_slot_context2 = (ctx) => ({});
var get_title_slot_changes2 = (dirty) => ({});
var get_title_slot_context2 = (ctx) => ({});
function create_else_block8(ctx) {
  let previous_tag = (
    /*component*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[1]
  );
  let svelte_element = (
    /*component*/
    ctx[1] && create_dynamic_element_1(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*component*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_1(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element_1(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[1];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(183:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let previous_tag = (
    /*component*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[1]
  );
  let svelte_element = (
    /*component*/
    ctx[1] && create_dynamic_element8(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*component*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element8(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element8(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[1];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(173:0) {#if groupTitle}",
    ctx
  });
  return block;
}
function create_else_block_13(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { class: (
      /*itemContentClasses*/
      ctx[17]
    ) },
    /*linkPropsComputed*/
    ctx[18]
  ];
  var switch_value = (
    /*ItemContentComponent*/
    ctx[19]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[57](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*itemContentClasses, linkPropsComputed*/
      393216 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*itemContentClasses*/
        131072 && { class: (
          /*itemContentClasses*/
          ctx2[17]
        ) },
        dirty[0] & /*linkPropsComputed*/
        262144 && get_spread_object(
          /*linkPropsComputed*/
          ctx2[18]
        )
      ]) : {};
      if (dirty[0] & /*c, footer, $$slots, text, subtitle, isLink, hasChevron, menuListItem, after, titleClasses, title, withTitle, header*/
      3262456 | dirty[1] & /*$$scope*/
      134217728) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = /*ItemContentComponent*/
      ctx2[19])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[57](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[57](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(236:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let previous_tag = (
    /*ItemContentComponent*/
    ctx[19]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*ItemContentComponent*/
    ctx[19]
  );
  validate_void_dynamic_element(
    /*ItemContentComponent*/
    ctx[19]
  );
  let svelte_element = (
    /*ItemContentComponent*/
    ctx[19] && create_dynamic_element_2(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*ItemContentComponent*/
        ctx2[19]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_2(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*ItemContentComponent*/
          ctx2[19]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*ItemContentComponent*/
            ctx2[19]
          );
          validate_void_dynamic_element(
            /*ItemContentComponent*/
            ctx2[19]
          );
          svelte_element = create_dynamic_element_2(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*ItemContentComponent*/
      ctx2[19];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(190:4) {#if typeof ItemContentComponent === 'string'}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let div;
  let div_class_value;
  let current;
  const media_slot_template = (
    /*#slots*/
    ctx[55].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_media_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      if (media_slot)
        media_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (media_slot)
        media_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].media);
      add_location(div, file30, 243, 10, 6655);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (media_slot) {
        if (media_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_media_slot_changes_1
            ),
            get_media_slot_context_1
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].media)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(243:8) {#if $$slots.media}",
    ctx
  });
  return block;
}
function create_if_block_182(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[55].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_header_slot_context_12
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*header*/
        ctx[8]
      );
      if (header_slot)
        header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*header*/
        ctx[8]
      );
      if (header_slot)
        header_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].header);
      add_location(div, file30, 247, 12, 6801);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*header*/
      256)
        set_data_dev(
          t,
          /*header*/
          ctx2[8]
        );
      if (header_slot) {
        if (header_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_header_slot_changes_12
            ),
            get_header_slot_context_12
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].header)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_182.name,
    type: "if",
    source: "(247:10) {#if header || $$slots.header}",
    ctx
  });
  return block;
}
function create_if_block_142(ctx) {
  let div;
  let t0;
  let t1;
  let div_class_value;
  let current;
  let if_block0 = (
    /*title*/
    (ctx[4] || /*$$slots*/
    ctx[21].title) && /*withTitle*/
    ctx[3] !== false && create_if_block_172(ctx)
  );
  let if_block1 = (
    /*after*/
    (ctx[7] || /*$$slots*/
    ctx[21].after) && create_if_block_162(ctx)
  );
  let if_block2 = (
    /*isLink*/
    ctx[15] && /*hasChevron*/
    ctx[20] && !/*menuListItem*/
    ctx[10] && create_if_block_152(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].titleWrap);
      add_location(div, file30, 250, 12, 6980);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*title*/
        (ctx2[4] || /*$$slots*/
        ctx2[21].title) && /*withTitle*/
        ctx2[3] !== false
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*title, $$slots, withTitle*/
          2097176) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_172(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*after*/
        ctx2[7] || /*$$slots*/
        ctx2[21].after
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*after, $$slots*/
          2097280) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_162(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*isLink*/
        ctx2[15] && /*hasChevron*/
        ctx2[20] && !/*menuListItem*/
        ctx2[10]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*isLink, hasChevron, menuListItem*/
          1082368) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_152(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].titleWrap)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(250:10) {#if ((title || $$slots.title) && withTitle !== false) || after || $$slots.after}",
    ctx
  });
  return block;
}
function create_if_block_172(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[55].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_title_slot_context_2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*title*/
        ctx[4]
      );
      t1 = space();
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(
        div_nodes,
        /*title*/
        ctx[4]
      );
      t1 = claim_space(div_nodes);
      if (title_slot)
        title_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*titleClasses*/
        ctx[16]
      );
      add_location(div, file30, 252, 16, 7090);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*title*/
      16)
        set_data_dev(
          t0,
          /*title*/
          ctx2[4]
        );
      if (title_slot) {
        if (title_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_title_slot_changes_2
            ),
            get_title_slot_context_2
          );
        }
      }
      if (!current || dirty[0] & /*titleClasses*/
      65536) {
        attr_dev(
          div,
          "class",
          /*titleClasses*/
          ctx2[16]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_172.name,
    type: "if",
    source: "(252:14) {#if (title || $$slots.title) && withTitle !== false}",
    ctx
  });
  return block;
}
function create_if_block_162(ctx) {
  let div;
  let t0;
  let t1;
  let div_class_value;
  let current;
  const after_slot_template = (
    /*#slots*/
    ctx[55].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_after_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*after*/
        ctx[7]
      );
      t1 = space();
      if (after_slot)
        after_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(
        div_nodes,
        /*after*/
        ctx[7]
      );
      t1 = claim_space(div_nodes);
      if (after_slot)
        after_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].after);
      add_location(div, file30, 258, 16, 7285);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      if (after_slot) {
        after_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*after*/
      128)
        set_data_dev(
          t0,
          /*after*/
          ctx2[7]
        );
      if (after_slot) {
        if (after_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_after_slot_changes_1
            ),
            get_after_slot_context_1
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].after)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_slot)
        after_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_162.name,
    type: "if",
    source: "(258:14) {#if after || $$slots.after}",
    ctx
  });
  return block;
}
function create_if_block_152(ctx) {
  let chevronicon;
  let current;
  chevronicon = new ChevronIcon_default({
    props: { class: (
      /*c*/
      ctx[14].chevron
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chevronicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chevronicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chevronicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chevronicon_changes = {};
      if (dirty[0] & /*c*/
      16384)
        chevronicon_changes.class = /*c*/
        ctx2[14].chevron;
      chevronicon.$set(chevronicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chevronicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(264:14) {#if isLink && hasChevron && !menuListItem}",
    ctx
  });
  return block;
}
function create_if_block_132(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[55].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_subtitle_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*subtitle*/
        ctx[5]
      );
      if (subtitle_slot)
        subtitle_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*subtitle*/
        ctx[5]
      );
      if (subtitle_slot)
        subtitle_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].subtitle);
      add_location(div, file30, 269, 12, 7636);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*subtitle*/
      32)
        set_data_dev(
          t,
          /*subtitle*/
          ctx2[5]
        );
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_subtitle_slot_changes_1
            ),
            get_subtitle_slot_context_1
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].subtitle)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(269:10) {#if subtitle || $$slots.subtitle}",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[55].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_text_slot_context_12
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*text*/
        ctx[6]
      );
      if (text_slot)
        text_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*text*/
        ctx[6]
      );
      if (text_slot)
        text_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].text);
      add_location(div, file30, 272, 12, 7766);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*text*/
      64)
        set_data_dev(
          t,
          /*text*/
          ctx2[6]
        );
      if (text_slot) {
        if (text_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_text_slot_changes_12
            ),
            get_text_slot_context_12
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].text)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(272:10) {#if text || $$slots.text}",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[55].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_footer_slot_context_12
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*footer*/
        ctx[9]
      );
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*footer*/
        ctx[9]
      );
      if (footer_slot)
        footer_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].footer);
      add_location(div, file30, 275, 12, 7888);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*footer*/
      512)
        set_data_dev(
          t,
          /*footer*/
          ctx2[9]
        );
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_footer_slot_changes_12
            ),
            get_footer_slot_context_12
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].footer)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(275:10) {#if footer || $$slots.footer}",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let div_class_value;
  let t6;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[21].media && create_if_block_19(ctx)
  );
  let if_block1 = (
    /*header*/
    (ctx[8] || /*$$slots*/
    ctx[21].header) && create_if_block_182(ctx)
  );
  let if_block2 = (
    /*title*/
    ((ctx[4] || /*$$slots*/
    ctx[21].title) && /*withTitle*/
    ctx[3] !== false || /*after*/
    ctx[7] || /*$$slots*/
    ctx[21].after) && create_if_block_142(ctx)
  );
  let if_block3 = (
    /*subtitle*/
    (ctx[5] || /*$$slots*/
    ctx[21].subtitle) && create_if_block_132(ctx)
  );
  let if_block4 = (
    /*text*/
    (ctx[6] || /*$$slots*/
    ctx[21].text) && create_if_block_122(ctx)
  );
  let if_block5 = (
    /*footer*/
    (ctx[9] || /*$$slots*/
    ctx[21].footer) && create_if_block_11(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[55].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_inner_slot_context_1
  );
  const content_slot_template = (
    /*#slots*/
    ctx[55].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_content_slot_context_1
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      t5 = space();
      if (inner_slot)
        inner_slot.c();
      t6 = space();
      if (content_slot)
        content_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block3)
        if_block3.l(div_nodes);
      t3 = claim_space(div_nodes);
      if (if_block4)
        if_block4.l(div_nodes);
      t4 = claim_space(div_nodes);
      if (if_block5)
        if_block5.l(div_nodes);
      t5 = claim_space(div_nodes);
      if (inner_slot)
        inner_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t6 = claim_space(nodes);
      if (content_slot)
        content_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].inner);
      add_location(div, file30, 245, 8, 6726);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_hydration_dev(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      append_hydration_dev(div, t3);
      if (if_block4)
        if_block4.m(div, null);
      append_hydration_dev(div, t4);
      if (if_block5)
        if_block5.m(div, null);
      append_hydration_dev(div, t5);
      if (inner_slot) {
        inner_slot.m(div, null);
      }
      insert_hydration_dev(target, t6, anchor);
      if (content_slot) {
        content_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[21].media
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          2097152) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_19(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*header*/
        ctx2[8] || /*$$slots*/
        ctx2[21].header
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*header, $$slots*/
          2097408) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_182(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*title*/
        (ctx2[4] || /*$$slots*/
        ctx2[21].title) && /*withTitle*/
        ctx2[3] !== false || /*after*/
        ctx2[7] || /*$$slots*/
        ctx2[21].after
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*title, $$slots, withTitle, after*/
          2097304) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_142(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*subtitle*/
        ctx2[5] || /*$$slots*/
        ctx2[21].subtitle
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*subtitle, $$slots*/
          2097184) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_132(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*text*/
        ctx2[6] || /*$$slots*/
        ctx2[21].text
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*text, $$slots*/
          2097216) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_122(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*footer*/
        ctx2[9] || /*$$slots*/
        ctx2[21].footer
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*footer, $$slots*/
          2097664) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_11(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div, t5);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_inner_slot_changes_1
            ),
            get_inner_slot_context_1
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].inner)) {
        attr_dev(div, "class", div_class_value);
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_content_slot_changes_1
            ),
            get_content_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(inner_slot, local);
      transition_in(content_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(inner_slot, local);
      transition_out(content_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t6);
      if (content_slot)
        content_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(237:6) <svelte:component         this={ItemContentComponent}         bind:this={rippleEl.current}         class={itemContentClasses}         {...linkPropsComputed}       >",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let div;
  let div_class_value;
  let current;
  const media_slot_template = (
    /*#slots*/
    ctx[55].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_media_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (media_slot)
        media_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (media_slot)
        media_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].media);
      add_location(div, file30, 197, 10, 5023);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (media_slot) {
        if (media_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_media_slot_changes2
            ),
            get_media_slot_context2
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].media)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(197:8) {#if $$slots.media && withMedia !== false}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[55].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_header_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*header*/
        ctx[8]
      );
      if (header_slot)
        header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*header*/
        ctx[8]
      );
      if (header_slot)
        header_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].header);
      add_location(div, file30, 201, 12, 5169);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*header*/
      256)
        set_data_dev(
          t,
          /*header*/
          ctx2[8]
        );
      if (header_slot) {
        if (header_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_header_slot_changes2
            ),
            get_header_slot_context2
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].header)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(201:10) {#if header || $$slots.header}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let div;
  let t0;
  let t1;
  let div_class_value;
  let current;
  let if_block0 = (
    /*title*/
    (ctx[4] || /*$$slots*/
    ctx[21].title) && /*withTitle*/
    ctx[3] !== false && create_if_block_8(ctx)
  );
  let if_block1 = (
    /*after*/
    (ctx[7] || /*$$slots*/
    ctx[21].after) && create_if_block_7(ctx)
  );
  let if_block2 = (
    /*isLink*/
    ctx[15] && /*hasChevron*/
    ctx[20] && !/*menuListItem*/
    ctx[10] && create_if_block_62(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].titleWrap);
      add_location(div, file30, 204, 12, 5348);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*title*/
        (ctx2[4] || /*$$slots*/
        ctx2[21].title) && /*withTitle*/
        ctx2[3] !== false
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*title, $$slots, withTitle*/
          2097176) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*after*/
        ctx2[7] || /*$$slots*/
        ctx2[21].after
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*after, $$slots*/
          2097280) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*isLink*/
        ctx2[15] && /*hasChevron*/
        ctx2[20] && !/*menuListItem*/
        ctx2[10]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*isLink, hasChevron, menuListItem*/
          1082368) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_62(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].titleWrap)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(204:10) {#if ((title || $$slots.title) && withTitle !== false) || after || $$slots.after}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[55].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_title_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*title*/
        ctx[4]
      );
      t1 = space();
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(
        div_nodes,
        /*title*/
        ctx[4]
      );
      t1 = claim_space(div_nodes);
      if (title_slot)
        title_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*titleClasses*/
        ctx[16]
      );
      add_location(div, file30, 206, 16, 5458);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*title*/
      16)
        set_data_dev(
          t0,
          /*title*/
          ctx2[4]
        );
      if (title_slot) {
        if (title_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_title_slot_changes_1
            ),
            get_title_slot_context_1
          );
        }
      }
      if (!current || dirty[0] & /*titleClasses*/
      65536) {
        attr_dev(
          div,
          "class",
          /*titleClasses*/
          ctx2[16]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(206:14) {#if (title || $$slots.title) && withTitle !== false}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let div;
  let t0;
  let t1;
  let div_class_value;
  let current;
  const after_slot_template = (
    /*#slots*/
    ctx[55].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_after_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*after*/
        ctx[7]
      );
      t1 = space();
      if (after_slot)
        after_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(
        div_nodes,
        /*after*/
        ctx[7]
      );
      t1 = claim_space(div_nodes);
      if (after_slot)
        after_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].after);
      add_location(div, file30, 212, 16, 5653);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      if (after_slot) {
        after_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*after*/
      128)
        set_data_dev(
          t0,
          /*after*/
          ctx2[7]
        );
      if (after_slot) {
        if (after_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_after_slot_changes
            ),
            get_after_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].after)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_slot)
        after_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(212:14) {#if after || $$slots.after}",
    ctx
  });
  return block;
}
function create_if_block_62(ctx) {
  let chevronicon;
  let current;
  chevronicon = new ChevronIcon_default({
    props: { class: (
      /*c*/
      ctx[14].chevron
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chevronicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chevronicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chevronicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chevronicon_changes = {};
      if (dirty[0] & /*c*/
      16384)
        chevronicon_changes.class = /*c*/
        ctx2[14].chevron;
      chevronicon.$set(chevronicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chevronicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: "(218:14) {#if isLink && hasChevron && !menuListItem}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[55].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_subtitle_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*subtitle*/
        ctx[5]
      );
      if (subtitle_slot)
        subtitle_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*subtitle*/
        ctx[5]
      );
      if (subtitle_slot)
        subtitle_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].subtitle);
      add_location(div, file30, 223, 12, 6004);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*subtitle*/
      32)
        set_data_dev(
          t,
          /*subtitle*/
          ctx2[5]
        );
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_subtitle_slot_changes
            ),
            get_subtitle_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].subtitle)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(223:10) {#if subtitle || $$slots.subtitle}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[55].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_text_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*text*/
        ctx[6]
      );
      if (text_slot)
        text_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*text*/
        ctx[6]
      );
      if (text_slot)
        text_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].text);
      add_location(div, file30, 226, 12, 6134);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*text*/
      64)
        set_data_dev(
          t,
          /*text*/
          ctx2[6]
        );
      if (text_slot) {
        if (text_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_text_slot_changes2
            ),
            get_text_slot_context2
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].text)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(226:10) {#if text || $$slots.text}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[55].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_footer_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*footer*/
        ctx[9]
      );
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*footer*/
        ctx[9]
      );
      if (footer_slot)
        footer_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].footer);
      add_location(div, file30, 229, 12, 6256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*footer*/
      512)
        set_data_dev(
          t,
          /*footer*/
          ctx2[9]
        );
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_footer_slot_changes2
            ),
            get_footer_slot_context2
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].footer)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(229:10) {#if footer || $$slots.footer}",
    ctx
  });
  return block;
}
function create_dynamic_element_2(ctx) {
  let svelte_element;
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let div_class_value;
  let t6;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[21].media && /*withMedia*/
    ctx[2] !== false && create_if_block_10(ctx)
  );
  let if_block1 = (
    /*header*/
    (ctx[8] || /*$$slots*/
    ctx[21].header) && create_if_block_9(ctx)
  );
  let if_block2 = (
    /*title*/
    ((ctx[4] || /*$$slots*/
    ctx[21].title) && /*withTitle*/
    ctx[3] !== false || /*after*/
    ctx[7] || /*$$slots*/
    ctx[21].after) && create_if_block_52(ctx)
  );
  let if_block3 = (
    /*subtitle*/
    (ctx[5] || /*$$slots*/
    ctx[21].subtitle) && create_if_block_42(ctx)
  );
  let if_block4 = (
    /*text*/
    (ctx[6] || /*$$slots*/
    ctx[21].text) && create_if_block_33(ctx)
  );
  let if_block5 = (
    /*footer*/
    (ctx[9] || /*$$slots*/
    ctx[21].footer) && create_if_block_24(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[55].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_inner_slot_context
  );
  const content_slot_template = (
    /*#slots*/
    ctx[55].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_content_slot_context
  );
  let svelte_element_levels = [
    { class: (
      /*itemContentClasses*/
      ctx[17]
    ) },
    /*linkPropsComputed*/
    ctx[18]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*ItemContentComponent*/
        ctx[19]
      );
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      t5 = space();
      if (inner_slot)
        inner_slot.c();
      t6 = space();
      if (content_slot)
        content_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*ItemContentComponent*/
        (ctx[19] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (if_block0)
        if_block0.l(svelte_element_nodes);
      t0 = claim_space(svelte_element_nodes);
      div = claim_element(svelte_element_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block3)
        if_block3.l(div_nodes);
      t3 = claim_space(div_nodes);
      if (if_block4)
        if_block4.l(div_nodes);
      t4 = claim_space(div_nodes);
      if (if_block5)
        if_block5.l(div_nodes);
      t5 = claim_space(div_nodes);
      if (inner_slot)
        inner_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t6 = claim_space(svelte_element_nodes);
      if (content_slot)
        content_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[14].inner);
      add_location(div, file30, 199, 8, 5094);
      if (/-/.test(
        /*ItemContentComponent*/
        ctx[19]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file30, 190, 6, 4799);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (if_block0)
        if_block0.m(svelte_element, null);
      append_hydration_dev(svelte_element, t0);
      append_hydration_dev(svelte_element, div);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_hydration_dev(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      append_hydration_dev(div, t3);
      if (if_block4)
        if_block4.m(div, null);
      append_hydration_dev(div, t4);
      if (if_block5)
        if_block5.m(div, null);
      append_hydration_dev(div, t5);
      if (inner_slot) {
        inner_slot.m(div, null);
      }
      append_hydration_dev(svelte_element, t6);
      if (content_slot) {
        content_slot.m(svelte_element, null);
      }
      ctx[56](svelte_element);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[21].media && /*withMedia*/
        ctx2[2] !== false
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots, withMedia*/
          2097156) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(svelte_element, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*header*/
        ctx2[8] || /*$$slots*/
        ctx2[21].header
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*header, $$slots*/
          2097408) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*title*/
        (ctx2[4] || /*$$slots*/
        ctx2[21].title) && /*withTitle*/
        ctx2[3] !== false || /*after*/
        ctx2[7] || /*$$slots*/
        ctx2[21].after
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*title, $$slots, withTitle, after*/
          2097304) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_52(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*subtitle*/
        ctx2[5] || /*$$slots*/
        ctx2[21].subtitle
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*subtitle, $$slots*/
          2097184) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_42(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*text*/
        ctx2[6] || /*$$slots*/
        ctx2[21].text
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*text, $$slots*/
          2097216) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_33(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*footer*/
        ctx2[9] || /*$$slots*/
        ctx2[21].footer
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*footer, $$slots*/
          2097664) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_24(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div, t5);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_inner_slot_changes
            ),
            get_inner_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      16384 && div_class_value !== (div_class_value = /*c*/
      ctx2[14].inner)) {
        attr_dev(div, "class", div_class_value);
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_content_slot_changes
            ),
            get_content_slot_context
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*itemContentClasses*/
        131072) && { class: (
          /*itemContentClasses*/
          ctx2[17]
        ) },
        dirty[0] & /*linkPropsComputed*/
        262144 && /*linkPropsComputed*/
        ctx2[18]
      ]);
      if (/-/.test(
        /*ItemContentComponent*/
        ctx2[19]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(inner_slot, local);
      transition_in(content_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(inner_slot, local);
      transition_out(content_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (inner_slot)
        inner_slot.d(detaching);
      if (content_slot)
        content_slot.d(detaching);
      ctx[56](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element_2.name,
    type: "child_dynamic_element",
    source: "(191:6) <svelte:element         this={ItemContentComponent}         bind:this={rippleEl.current}         class={itemContentClasses}         {...linkPropsComputed}       >",
    ctx
  });
  return block;
}
function create_dynamic_element_1(ctx) {
  let svelte_element;
  let current_block_type_index;
  let if_block;
  let t;
  let svelte_element_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_18, create_else_block_13];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (typeof /*ItemContentComponent*/
    ctx2[19] === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[55].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*c*/
      ctx[14].base
    },
    /*$$restProps*/
    ctx[22]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[1]
      );
      if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[1] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if_block.l(svelte_element_nodes);
      t = claim_space(svelte_element_nodes);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*component*/
        ctx[1]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file30, 183, 2, 4638);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if_blocks[current_block_type_index].m(svelte_element, null);
      append_hydration_dev(svelte_element, t);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          svelte_element,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[12]
            ))
              ctx[12].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(svelte_element, t);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[58]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[58],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*c*/
        16384 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx[14].base)) && { class: svelte_element_class_value },
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx[22]
      ]);
      if (/-/.test(
        /*component*/
        ctx[1]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element_1.name,
    type: "child_dynamic_element",
    source: "(184:2) <svelte:element     this={component}     class={c.base}     {...$$restProps}     on:click={onClick}   >",
    ctx
  });
  return block;
}
function create_dynamic_element8(ctx) {
  let svelte_element;
  let t0;
  let t1;
  let t2;
  let svelte_element_class_value;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[55].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_title_slot_context2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[55].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = cls(
        /*c*/
        ctx[14].groupTitle,
        /*className*/
        ctx[0]
      )
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[1]
      );
      t0 = text(
        /*title*/
        ctx[4]
      );
      t1 = space();
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[1] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      t0 = claim_text(
        svelte_element_nodes,
        /*title*/
        ctx[4]
      );
      t1 = claim_space(svelte_element_nodes);
      if (title_slot)
        title_slot.l(svelte_element_nodes);
      t2 = claim_space(svelte_element_nodes);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*component*/
        ctx[1]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file30, 173, 2, 4452);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, t0);
      append_hydration_dev(svelte_element, t1);
      if (title_slot) {
        title_slot.m(svelte_element, null);
      }
      append_hydration_dev(svelte_element, t2);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          svelte_element,
          "click",
          function() {
            if (is_function(
              /*onClick*/
              ctx[12]
            ))
              ctx[12].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*title*/
      16)
        set_data_dev(
          t0,
          /*title*/
          ctx[4]
        );
      if (title_slot) {
        if (title_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx,
            /*$$scope*/
            ctx[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[58]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx[58],
              dirty,
              get_title_slot_changes2
            ),
            get_title_slot_context2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[58]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[58],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*c, className*/
        16385 && svelte_element_class_value !== (svelte_element_class_value = cls(
          /*c*/
          ctx[14].groupTitle,
          /*className*/
          ctx[0]
        ))) && { class: svelte_element_class_value }
      ]);
      if (/-/.test(
        /*component*/
        ctx[1]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (title_slot)
        title_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element8.name,
    type: "child_dynamic_element",
    source: "(174:2) <svelte:element     this={component}     class={cls(c.groupTitle, className)}     on:click={onClick}   >",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block13, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*groupTitle*/
      ctx2[11]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let hasChevron;
  let colors;
  let isMenuListItemActive;
  let textColor;
  let isLink;
  let isLabel;
  let needsTouchRipple;
  let hrefComputed;
  let ItemContentComponent;
  let linkPropsComputed;
  let isMediaItem;
  let autoStrongTitle;
  let c;
  let itemContentClasses;
  let titleClasses;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "component",
    "mediaClass",
    "innerClass",
    "contentClass",
    "titleWrapClass",
    "titleFontSizeIos",
    "titleFontSizeMaterial",
    "withMedia",
    "withTitle",
    "title",
    "subtitle",
    "text",
    "after",
    "header",
    "footer",
    "menuListItem",
    "menuListItemActive",
    "groupTitle",
    "strongTitle",
    "label",
    "chevron",
    "chevronIos",
    "chevronMaterial",
    "href",
    "target",
    "dividers",
    "link",
    "linkComponent",
    "linkProps",
    "touchRipple",
    "onClick"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListItem", slots, [
    "title",
    "default",
    "media",
    "header",
    "after",
    "subtitle",
    "text",
    "footer",
    "inner",
    "content"
  ]);
  const $$slots = compute_slots(slots);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "li" } = $$props;
  let { mediaClass = "" } = $$props;
  let { innerClass = "" } = $$props;
  let { contentClass = "" } = $$props;
  let { titleWrapClass = "" } = $$props;
  let { titleFontSizeIos = "text-[17px]" } = $$props;
  let { titleFontSizeMaterial = "text-[16px]" } = $$props;
  let { withMedia = void 0 } = $$props;
  let { withTitle = void 0 } = $$props;
  let { title = "" } = $$props;
  let { subtitle = "" } = $$props;
  let { text: text2 = "" } = $$props;
  let { after = "" } = $$props;
  let { header = "" } = $$props;
  let { footer = "" } = $$props;
  let { menuListItem = false } = $$props;
  let { menuListItemActive = false } = $$props;
  let { groupTitle = false } = $$props;
  let { strongTitle = "auto" } = $$props;
  let { label = false } = $$props;
  let { chevron = void 0 } = $$props;
  let { chevronIos = true } = $$props;
  let { chevronMaterial = true } = $$props;
  let { href = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { dividers = void 0 } = $$props;
  let { link = false } = $$props;
  let { linkComponent = "a" } = $$props;
  let { linkProps = {} } = $$props;
  let { touchRipple = true } = $$props;
  let { onClick = void 0 } = $$props;
  let ListDividersContext = getReactiveContext("ListDividersContext", (value) => {
    $$invalidate(45, ListDividersContext = value || {});
  }) || { value: false };
  const rippleEl = { current: null };
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(46, theme = v));
  const dark = useDarkClasses();
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(13, rippleEl);
    });
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(13, rippleEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(23, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(24, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(25, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(1, component = $$new_props.component);
    if ("mediaClass" in $$new_props)
      $$invalidate(26, mediaClass = $$new_props.mediaClass);
    if ("innerClass" in $$new_props)
      $$invalidate(27, innerClass = $$new_props.innerClass);
    if ("contentClass" in $$new_props)
      $$invalidate(28, contentClass = $$new_props.contentClass);
    if ("titleWrapClass" in $$new_props)
      $$invalidate(29, titleWrapClass = $$new_props.titleWrapClass);
    if ("titleFontSizeIos" in $$new_props)
      $$invalidate(30, titleFontSizeIos = $$new_props.titleFontSizeIos);
    if ("titleFontSizeMaterial" in $$new_props)
      $$invalidate(31, titleFontSizeMaterial = $$new_props.titleFontSizeMaterial);
    if ("withMedia" in $$new_props)
      $$invalidate(2, withMedia = $$new_props.withMedia);
    if ("withTitle" in $$new_props)
      $$invalidate(3, withTitle = $$new_props.withTitle);
    if ("title" in $$new_props)
      $$invalidate(4, title = $$new_props.title);
    if ("subtitle" in $$new_props)
      $$invalidate(5, subtitle = $$new_props.subtitle);
    if ("text" in $$new_props)
      $$invalidate(6, text2 = $$new_props.text);
    if ("after" in $$new_props)
      $$invalidate(7, after = $$new_props.after);
    if ("header" in $$new_props)
      $$invalidate(8, header = $$new_props.header);
    if ("footer" in $$new_props)
      $$invalidate(9, footer = $$new_props.footer);
    if ("menuListItem" in $$new_props)
      $$invalidate(10, menuListItem = $$new_props.menuListItem);
    if ("menuListItemActive" in $$new_props)
      $$invalidate(32, menuListItemActive = $$new_props.menuListItemActive);
    if ("groupTitle" in $$new_props)
      $$invalidate(11, groupTitle = $$new_props.groupTitle);
    if ("strongTitle" in $$new_props)
      $$invalidate(33, strongTitle = $$new_props.strongTitle);
    if ("label" in $$new_props)
      $$invalidate(34, label = $$new_props.label);
    if ("chevron" in $$new_props)
      $$invalidate(35, chevron = $$new_props.chevron);
    if ("chevronIos" in $$new_props)
      $$invalidate(36, chevronIos = $$new_props.chevronIos);
    if ("chevronMaterial" in $$new_props)
      $$invalidate(37, chevronMaterial = $$new_props.chevronMaterial);
    if ("href" in $$new_props)
      $$invalidate(38, href = $$new_props.href);
    if ("target" in $$new_props)
      $$invalidate(39, target = $$new_props.target);
    if ("dividers" in $$new_props)
      $$invalidate(40, dividers = $$new_props.dividers);
    if ("link" in $$new_props)
      $$invalidate(41, link = $$new_props.link);
    if ("linkComponent" in $$new_props)
      $$invalidate(42, linkComponent = $$new_props.linkComponent);
    if ("linkProps" in $$new_props)
      $$invalidate(43, linkProps = $$new_props.linkProps);
    if ("touchRipple" in $$new_props)
      $$invalidate(44, touchRipple = $$new_props.touchRipple);
    if ("onClick" in $$new_props)
      $$invalidate(12, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(58, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cls,
    useTheme,
    useThemeClasses,
    useTouchRipple,
    ChevronIcon: ChevronIcon_default,
    useDarkClasses,
    ListItemClasses,
    ListItemColors,
    getReactiveContext,
    className,
    colorsProp,
    ios,
    material,
    component,
    mediaClass,
    innerClass,
    contentClass,
    titleWrapClass,
    titleFontSizeIos,
    titleFontSizeMaterial,
    withMedia,
    withTitle,
    title,
    subtitle,
    text: text2,
    after,
    header,
    footer,
    menuListItem,
    menuListItemActive,
    groupTitle,
    strongTitle,
    label,
    chevron,
    chevronIos,
    chevronMaterial,
    href,
    target,
    dividers,
    link,
    linkComponent,
    linkProps,
    touchRipple,
    onClick,
    ListDividersContext,
    rippleEl,
    theme,
    dark,
    c,
    autoStrongTitle,
    titleClasses,
    isLabel,
    isLink,
    itemContentClasses,
    isMenuListItemActive,
    needsTouchRipple,
    textColor,
    isMediaItem,
    colors,
    hrefComputed,
    linkPropsComputed,
    ItemContentComponent,
    hasChevron
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(23, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(24, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(25, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(1, component = $$new_props.component);
    if ("mediaClass" in $$props)
      $$invalidate(26, mediaClass = $$new_props.mediaClass);
    if ("innerClass" in $$props)
      $$invalidate(27, innerClass = $$new_props.innerClass);
    if ("contentClass" in $$props)
      $$invalidate(28, contentClass = $$new_props.contentClass);
    if ("titleWrapClass" in $$props)
      $$invalidate(29, titleWrapClass = $$new_props.titleWrapClass);
    if ("titleFontSizeIos" in $$props)
      $$invalidate(30, titleFontSizeIos = $$new_props.titleFontSizeIos);
    if ("titleFontSizeMaterial" in $$props)
      $$invalidate(31, titleFontSizeMaterial = $$new_props.titleFontSizeMaterial);
    if ("withMedia" in $$props)
      $$invalidate(2, withMedia = $$new_props.withMedia);
    if ("withTitle" in $$props)
      $$invalidate(3, withTitle = $$new_props.withTitle);
    if ("title" in $$props)
      $$invalidate(4, title = $$new_props.title);
    if ("subtitle" in $$props)
      $$invalidate(5, subtitle = $$new_props.subtitle);
    if ("text" in $$props)
      $$invalidate(6, text2 = $$new_props.text);
    if ("after" in $$props)
      $$invalidate(7, after = $$new_props.after);
    if ("header" in $$props)
      $$invalidate(8, header = $$new_props.header);
    if ("footer" in $$props)
      $$invalidate(9, footer = $$new_props.footer);
    if ("menuListItem" in $$props)
      $$invalidate(10, menuListItem = $$new_props.menuListItem);
    if ("menuListItemActive" in $$props)
      $$invalidate(32, menuListItemActive = $$new_props.menuListItemActive);
    if ("groupTitle" in $$props)
      $$invalidate(11, groupTitle = $$new_props.groupTitle);
    if ("strongTitle" in $$props)
      $$invalidate(33, strongTitle = $$new_props.strongTitle);
    if ("label" in $$props)
      $$invalidate(34, label = $$new_props.label);
    if ("chevron" in $$props)
      $$invalidate(35, chevron = $$new_props.chevron);
    if ("chevronIos" in $$props)
      $$invalidate(36, chevronIos = $$new_props.chevronIos);
    if ("chevronMaterial" in $$props)
      $$invalidate(37, chevronMaterial = $$new_props.chevronMaterial);
    if ("href" in $$props)
      $$invalidate(38, href = $$new_props.href);
    if ("target" in $$props)
      $$invalidate(39, target = $$new_props.target);
    if ("dividers" in $$props)
      $$invalidate(40, dividers = $$new_props.dividers);
    if ("link" in $$props)
      $$invalidate(41, link = $$new_props.link);
    if ("linkComponent" in $$props)
      $$invalidate(42, linkComponent = $$new_props.linkComponent);
    if ("linkProps" in $$props)
      $$invalidate(43, linkProps = $$new_props.linkProps);
    if ("touchRipple" in $$props)
      $$invalidate(44, touchRipple = $$new_props.touchRipple);
    if ("onClick" in $$props)
      $$invalidate(12, onClick = $$new_props.onClick);
    if ("ListDividersContext" in $$props)
      $$invalidate(45, ListDividersContext = $$new_props.ListDividersContext);
    if ("theme" in $$props)
      $$invalidate(46, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(14, c = $$new_props.c);
    if ("autoStrongTitle" in $$props)
      $$invalidate(47, autoStrongTitle = $$new_props.autoStrongTitle);
    if ("titleClasses" in $$props)
      $$invalidate(16, titleClasses = $$new_props.titleClasses);
    if ("isLabel" in $$props)
      $$invalidate(48, isLabel = $$new_props.isLabel);
    if ("isLink" in $$props)
      $$invalidate(15, isLink = $$new_props.isLink);
    if ("itemContentClasses" in $$props)
      $$invalidate(17, itemContentClasses = $$new_props.itemContentClasses);
    if ("isMenuListItemActive" in $$props)
      $$invalidate(49, isMenuListItemActive = $$new_props.isMenuListItemActive);
    if ("needsTouchRipple" in $$props)
      $$invalidate(50, needsTouchRipple = $$new_props.needsTouchRipple);
    if ("textColor" in $$props)
      $$invalidate(51, textColor = $$new_props.textColor);
    if ("isMediaItem" in $$props)
      $$invalidate(52, isMediaItem = $$new_props.isMediaItem);
    if ("colors" in $$props)
      $$invalidate(53, colors = $$new_props.colors);
    if ("hrefComputed" in $$props)
      $$invalidate(54, hrefComputed = $$new_props.hrefComputed);
    if ("linkPropsComputed" in $$props)
      $$invalidate(18, linkPropsComputed = $$new_props.linkPropsComputed);
    if ("ItemContentComponent" in $$props)
      $$invalidate(19, ItemContentComponent = $$new_props.ItemContentComponent);
    if ("hasChevron" in $$props)
      $$invalidate(20, hasChevron = $$new_props.hasChevron);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*chevron, theme, chevronIos, chevronMaterial*/
    32880) {
      $:
        $$invalidate(20, hasChevron = typeof chevron === "undefined" ? theme === "ios" ? chevronIos : chevronMaterial : chevron);
    }
    if ($$self.$$.dirty[0] & /*colorsProp*/
    8388608) {
      $:
        $$invalidate(53, colors = ListItemColors(colorsProp, dark));
    }
    if ($$self.$$.dirty[0] & /*menuListItem*/
    1024 | $$self.$$.dirty[1] & /*menuListItemActive*/
    2) {
      $:
        $$invalidate(49, isMenuListItemActive = menuListItem && menuListItemActive);
    }
    if ($$self.$$.dirty[0] & /*menuListItem*/
    1024 | $$self.$$.dirty[1] & /*colors, isMenuListItemActive, theme*/
    4489216) {
      $:
        $$invalidate(51, textColor = colors[`${isMenuListItemActive ? "menuListItemActiveText" : menuListItem ? "menuListItemText" : "text"}${theme === "ios" ? "Ios" : "Material"}`]);
    }
    if ($$self.$$.dirty[0] & /*menuListItem*/
    1024 | $$self.$$.dirty[1] & /*href, link*/
    1152) {
      $:
        $$invalidate(15, isLink = !!href || href === "" || menuListItem || link);
    }
    if ($$self.$$.dirty[1] & /*label*/
    8) {
      $:
        $$invalidate(48, isLabel = !!label);
    }
    if ($$self.$$.dirty[0] & /*isLink*/
    32768 | $$self.$$.dirty[1] & /*theme, isLabel, touchRipple*/
    172032) {
      $:
        $$invalidate(50, needsTouchRipple = theme === "material" && (isLabel || isLink) && touchRipple);
    }
    if ($$self.$$.dirty[0] & /*rippleEl*/
    8192 | $$self.$$.dirty[1] & /*needsTouchRipple*/
    524288) {
      $:
        useTouchRipple(rippleEl, needsTouchRipple);
    }
    if ($$self.$$.dirty[1] & /*href*/
    128) {
      $:
        $$invalidate(54, hrefComputed = href === true || href === false || typeof href === "undefined" ? void 0 : href || "");
    }
    if ($$self.$$.dirty[0] & /*isLink*/
    32768 | $$self.$$.dirty[1] & /*linkComponent, isLabel*/
    133120) {
      $:
        $$invalidate(19, ItemContentComponent = isLink ? linkComponent : isLabel ? "label" : "div");
    }
    if ($$self.$$.dirty[0] & /*isLink*/
    32768 | $$self.$$.dirty[1] & /*hrefComputed, target, linkProps*/
    8392960) {
      $:
        $$invalidate(18, linkPropsComputed = isLink ? { href: hrefComputed, target, ...linkProps } : {});
    }
    if ($$self.$$.dirty[0] & /*title, withTitle, subtitle, text*/
    120) {
      $:
        $$invalidate(52, isMediaItem = (title || $$slots.title) && withTitle !== false && (subtitle || text2 || $$slots.subtitle || $$slots.text));
    }
    if ($$self.$$.dirty[0] & /*title, withTitle, subtitle, text*/
    120 | $$self.$$.dirty[1] & /*strongTitle*/
    4) {
      $:
        $$invalidate(47, autoStrongTitle = strongTitle === "auto" && (title || $$slots.title) && withTitle !== false && (subtitle || text2 || $$slots.subtitle || $$slots.text));
    }
    if ($$self.$$.dirty[0] & /*ios, material, menuListItem, mediaClass, innerClass, contentClass, titleWrapClass, titleFontSizeIos, className*/
    2130707457 | $$self.$$.dirty[1] & /*dividers, ListDividersContext, titleFontSizeMaterial, strongTitle, colors, isMediaItem, theme, textColor, needsTouchRipple, isMenuListItemActive, autoStrongTitle*/
    8241669) {
      $:
        $$invalidate(14, c = useThemeClasses(
          { ios, material },
          ListItemClasses(
            {
              menuListItem,
              dividers: typeof dividers === "undefined" ? ListDividersContext.value : dividers,
              mediaClass,
              innerClass,
              contentClass,
              titleWrapClass,
              titleFontSizeIos,
              titleFontSizeMaterial,
              strongTitle
            },
            colors,
            {
              isMediaItem,
              theme,
              textColor,
              needsTouchRipple,
              isMenuListItemActive,
              darkClasses: dark,
              autoStrongTitle,
              className
            }
          ),
          className,
          (v) => $$invalidate(14, c = v)
        ));
    }
    if ($$self.$$.dirty[0] & /*isLink, c*/
    49152 | $$self.$$.dirty[1] & /*isLabel*/
    131072) {
      $:
        $$invalidate(17, itemContentClasses = isLink || isLabel ? c.itemContent.link : c.itemContent.default);
    }
    if ($$self.$$.dirty[0] & /*menuListItem, c*/
    17408 | $$self.$$.dirty[1] & /*strongTitle, autoStrongTitle*/
    65540) {
      $:
        $$invalidate(16, titleClasses = menuListItem ? c.title.menuListItem : strongTitle === true || autoStrongTitle ? c.title.strong : c.title.default);
    }
  };
  return [
    className,
    component,
    withMedia,
    withTitle,
    title,
    subtitle,
    text2,
    after,
    header,
    footer,
    menuListItem,
    groupTitle,
    onClick,
    rippleEl,
    c,
    isLink,
    titleClasses,
    itemContentClasses,
    linkPropsComputed,
    ItemContentComponent,
    hasChevron,
    $$slots,
    $$restProps,
    colorsProp,
    ios,
    material,
    mediaClass,
    innerClass,
    contentClass,
    titleWrapClass,
    titleFontSizeIos,
    titleFontSizeMaterial,
    menuListItemActive,
    strongTitle,
    label,
    chevron,
    chevronIos,
    chevronMaterial,
    href,
    target,
    dividers,
    link,
    linkComponent,
    linkProps,
    touchRipple,
    ListDividersContext,
    theme,
    autoStrongTitle,
    isLabel,
    isMenuListItemActive,
    needsTouchRipple,
    textColor,
    isMediaItem,
    colors,
    hrefComputed,
    slots,
    svelte_element_binding,
    switch_instance_binding,
    $$scope
  ];
}
var ListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance31,
      create_fragment31,
      safe_not_equal,
      {
        class: 0,
        colors: 23,
        ios: 24,
        material: 25,
        component: 1,
        mediaClass: 26,
        innerClass: 27,
        contentClass: 28,
        titleWrapClass: 29,
        titleFontSizeIos: 30,
        titleFontSizeMaterial: 31,
        withMedia: 2,
        withTitle: 3,
        title: 4,
        subtitle: 5,
        text: 6,
        after: 7,
        header: 8,
        footer: 9,
        menuListItem: 10,
        menuListItemActive: 32,
        groupTitle: 11,
        strongTitle: 33,
        label: 34,
        chevron: 35,
        chevronIos: 36,
        chevronMaterial: 37,
        href: 38,
        target: 39,
        dividers: 40,
        link: 41,
        linkComponent: 42,
        linkProps: 43,
        touchRipple: 44,
        onClick: 12
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListItem",
      options,
      id: create_fragment31.name
    });
  }
  get class() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mediaClass() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mediaClass(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerClass() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerClass(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentClass() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentClass(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleWrapClass() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleWrapClass(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontSizeIos() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontSizeIos(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontSizeMaterial() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontSizeMaterial(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withMedia() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withMedia(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withTitle() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withTitle(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get after() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set after(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footer() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footer(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuListItem() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuListItem(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuListItemActive() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuListItemActive(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupTitle() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupTitle(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongTitle() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongTitle(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chevron() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chevron(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chevronIos() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chevronIos(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chevronMaterial() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chevronMaterial(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dividers() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dividers(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linkComponent() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linkComponent(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linkProps() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linkProps(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListItem_default = ListItem;

// node_modules/konsta/svelte/components/icons/DropdownIcon.svelte
var file31 = "node_modules/konsta/svelte/components/icons/DropdownIcon.svelte";
function create_fragment32(ctx) {
  let svg;
  let polygon;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "8" },
    { height: "5" },
    { viewBox: "0 0 8 5" },
    { fill: "currentcolor" },
    /*$$restProps*/
    ctx[0]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { fillrule: true, points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "fillrule", "evenodd");
      attr_dev(polygon, "points", "0 0 8 0 4 5");
      add_location(polygon, file31, 11, 2, 152);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file31, 3, 0, 20);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "8" },
        { height: "5" },
        { viewBox: "0 0 8 5" },
        { fill: "currentcolor" },
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownIcon", slots, []);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
var DropdownIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownIcon",
      options,
      id: create_fragment32.name
    });
  }
};
var DropdownIcon_default = DropdownIcon;

// node_modules/konsta/shared/esm/classes/ListInputClasses.js
var ListInputClasses = (props, colors, _ref) => {
  let {
    isFloatingTransformed,
    isFocused,
    darkClasses,
    getLabelColor,
    hasLabel
  } = _ref;
  const {
    error,
    type,
    outline,
    inputClassName = "",
    inputClass = ""
  } = props;
  return {
    base: {
      common: "",
      ios: cls(outline && "my-4"),
      material: cls("py-2")
    },
    itemContent: {
      common: "relative",
      ios: cls(outline && "ml-4 mr-4 rounded-lg", !outline && colors.bgIos),
      material: cls("min-h-[56px] ml-4 mr-4", outline ? cls("rounded") : cls(colors.bgMaterial, "rounded-t relative "))
    },
    inner: {
      common: "",
      material: cls(!outline ? "pt-2 pb-2" : "pt-4 pb-4"),
      stacked: "",
      floating: ""
    },
    label: {
      common: cls(`duration-200 text-xs`, getLabelColor(), outline && "flex"),
      ios: cls(outline && "-mt-4"),
      material: cls(outline && "-mt-4"),
      stacked: "",
      floating: {
        common: cls(`pointer-events-none duration-200 transform origin-left max-w-[66%]`, isFloatingTransformed && "scale-133"),
        ios: isFloatingTransformed ? outline ? "translate-y-6" : "translate-y-4" : "",
        material: isFloatingTransformed ? outline ? "translate-y-8" : "translate-y-3" : ""
      }
    },
    labelText: {
      common: cls(outline && "relative p-1 block -m-1"),
      ios: cls(outline && cls("-top-1", colors.outlineLabelBgIos)),
      material: cls(outline && cls("-top-2", colors.outlineLabelBgMaterial))
    },
    inputWrap: {
      common: "relative",
      ios: cls((!hasLabel || outline) && "-mt-2.5", "-mb-2.5"),
      stacked: "",
      floating: ""
    },
    media: {
      material: ""
    },
    titleWrap: {
      material: `duration-200 ${getLabelColor()}`
    },
    input: {
      common: `block text-base appearance-none w-full focus:outline-none bg-transparent ${inputClassName || inputClass}`,
      ios: "h-10",
      material: "h-6",
      notFloating: {
        common: cls("placeholder-black placeholder-opacity-30", darkClasses("dark:placeholder-white dark:placeholder-opacity-30")),
        material: cls(type === "textarea" && "py-1"),
        ios: cls(type === "textarea" && "py-2")
      },
      floating: isFloatingTransformed ? "placeholder-transparent" : cls(`placeholder-black placeholder-opacity-30`, darkClasses("dark:placeholder-white dark:placeholder-opacity-30"))
    },
    errorInfo: {
      common: "text-xs relative z-10",
      ios: "mt-1",
      material: ""
    },
    error: colors.errorText,
    info: "opacity-50",
    clearButton: {
      common: "absolute right-0 top-1/2 transform -translate-y-1/2 cursor-pointer",
      ios: cls("w-3.5 h-3.5 opacity-45 active:opacity-30", colors.labelTextIos),
      material: cls("w-6 h-6 active:opacity-55", colors.labelTextMaterial)
    },
    dropdown: "absolute right-0 top-1/2 transform -translate-y-1/2 pointer-events-none opacity-50",
    border: {
      common: "pointer-events-none absolute left-0 bottom-0 duration-200 w-full",
      ios: outline && cls(error ? colors.errorBorder : isFocused ? colors.outlineBorderFocusIos : colors.outlineBorderIos, "h-full border rounded-lg -z-10"),
      material: cls(error ? colors.errorBorder : isFocused ? colors.outlineBorderFocusMaterial : colors.outlineBorderMaterial, outline && cls("h-full border rounded -z-10", isFocused && "border-2"), !outline && cls("border-b h-px origin-bottom", isFocused && "scale-y-[2]"))
    }
  };
};

// node_modules/konsta/shared/esm/colors/ListInputColors.js
var ListInputColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: "",
    bgMaterial: cls("bg-md-light-surface-variant", dark("dark:bg-md-dark-surface-variant")),
    outlineBorderIos: cls("border-black border-opacity-30", dark("dark:border-white dark:border-opacity-30")),
    outlineBorderFocusIos: "border-primary",
    outlineBorderMaterial: cls("border-md-light-on-surface", dark("dark:border-md-dark-on-surface")),
    outlineBorderFocusMaterial: cls("border-md-light-primary", dark("dark:border-md-dark-primary")),
    outlineLabelBgIos: cls("bg-ios-light-surface-1", dark("dark:bg-ios-dark-surface-1")),
    outlineLabelBgMaterial: cls("bg-md-light-surface", dark("dark:bg-md-dark-surface")),
    labelTextIos: "",
    labelTextFocusIos: "",
    labelTextMaterial: cls("text-md-light-on-surface-variant", dark("dark:text-md-dark-on-surface-variant")),
    labelTextFocusMaterial: cls("text-md-light-primary", dark("dark:text-md-dark-primary")),
    errorText: "text-red-500",
    errorBorder: "border-red-500",
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/ListInput.svelte
var file32 = "node_modules/konsta/svelte/components/ListInput.svelte";
var get_media_slot_changes3 = (dirty) => ({});
var get_media_slot_context3 = (ctx) => ({});
var get_info_slot_changes = (dirty) => ({});
var get_info_slot_context = (ctx) => ({});
var get_error_slot_changes = (dirty) => ({});
var get_error_slot_context = (ctx) => ({});
var get_input_slot_changes = (dirty) => ({});
var get_input_slot_context = (ctx) => ({});
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_if_block_102(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[61].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[64],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[64],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[64]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[64],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_102.name,
    type: "if",
    source: "(294:2) {#if type !== 'select'}",
    ctx
  });
  return block;
}
function create_default_slot9(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*type*/
    ctx[10] !== "select" && create_if_block_102(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*type*/
        ctx2[10] !== "select"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*type*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_102(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(156:0) <ListItem   {component}   class={c.base}   title={undefined}   mediaClass={c.media}   innerClass={c.inner[labelStyle]}   contentClass={c.itemContent}   titleWrapClass={c.titleWrap}   withMedia={!!$$slots.media}   withTitle={!!$$slots.label || !!label}   dividers={theme === 'material' || isOutline ? false : undefined}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_if_block_92(ctx) {
  let span;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[41].border);
      add_location(span, file32, 170, 6, 4648);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & /*c*/
      1024 && span_class_value !== (span_class_value = /*c*/
      ctx2[41].border)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_92.name,
    type: "if",
    source: "(170:4) {#if isOutline || theme === 'material'}",
    ctx
  });
  return block;
}
function create_content_slot(ctx) {
  let if_block_anchor;
  let if_block = (
    /*isOutline*/
    (ctx[37] || /*theme*/
    ctx[35] === "material") && create_if_block_92(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*isOutline*/
        ctx2[37] || /*theme*/
        ctx2[35] === "material"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_92(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_content_slot.name,
    type: "slot",
    source: '(169:2) <svelte:fragment slot=\\"content\\">',
    ctx
  });
  return block;
}
function create_if_block_82(ctx) {
  let current;
  const media_slot_template = (
    /*#slots*/
    ctx[61].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[64],
    get_media_slot_context3
  );
  const block = {
    c: function create() {
      if (media_slot)
        media_slot.c();
    },
    l: function claim(nodes) {
      if (media_slot)
        media_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (media_slot) {
        media_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        4)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[64],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[64]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[64],
              dirty,
              get_media_slot_changes3
            ),
            get_media_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_82.name,
    type: "if",
    source: "(175:4) {#if $$slots.media}",
    ctx
  });
  return block;
}
function create_media_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[45].media && create_if_block_82(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[45].media
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          16384) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_82(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_media_slot.name,
    type: "slot",
    source: '(174:2) <svelte:fragment slot=\\"media\\">',
    ctx
  });
  return block;
}
function create_if_block_72(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let div0_class_value;
  let div1_class_value;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[61].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[64],
    get_label_slot_context
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(
        /*label*/
        ctx[1]
      );
      t1 = space();
      if (label_slot)
        label_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*label*/
        ctx[1]
      );
      t1 = claim_space(div0_nodes);
      if (label_slot)
        label_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*c*/
      ctx[41].labelText);
      add_location(div0, file32, 182, 8, 4936);
      attr_dev(div1, "class", div1_class_value = /*c*/
      ctx[41].label[
        /*labelStyle*/
        ctx[38]
      ]);
      add_location(div1, file32, 181, 6, 4894);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div0, t1);
      if (label_slot) {
        label_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*label*/
      2)
        set_data_dev(
          t0,
          /*label*/
          ctx2[1]
        );
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & /*$$scope*/
        4)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[64],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[64]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[64],
              dirty,
              get_label_slot_changes
            ),
            get_label_slot_context
          );
        }
      }
      if (!current || dirty[1] & /*c*/
      1024 && div0_class_value !== (div0_class_value = /*c*/
      ctx2[41].labelText)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[1] & /*c, labelStyle*/
      1152 && div1_class_value !== (div1_class_value = /*c*/
      ctx2[41].label[
        /*labelStyle*/
        ctx2[38]
      ])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_72.name,
    type: "if",
    source: "(181:4) {#if label || $$slots.label}",
    ctx
  });
  return block;
}
function create_else_block9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_63, create_else_block_14];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[10] === "select"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(192:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_53(ctx) {
  let current;
  const input_slot_template = (
    /*#slots*/
    ctx[61].input
  );
  const input_slot = create_slot(
    input_slot_template,
    ctx,
    /*$$scope*/
    ctx[64],
    get_input_slot_context
  );
  const block = {
    c: function create() {
      if (input_slot)
        input_slot.c();
    },
    l: function claim(nodes) {
      if (input_slot)
        input_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (input_slot) {
        input_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (input_slot) {
        if (input_slot.p && (!current || dirty[2] & /*$$scope*/
        4)) {
          update_slot_base(
            input_slot,
            input_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[64],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[64]
            ) : get_slot_changes(
              input_slot_template,
              /*$$scope*/
              ctx2[64],
              dirty,
              get_input_slot_changes
            ),
            get_input_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(input_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(input_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (input_slot)
        input_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(190:6) {#if $$slots.input}",
    ctx
  });
  return block;
}
function create_else_block_14(ctx) {
  let previous_tag = (
    /*InputComponent*/
    ctx[36]
  );
  let svelte_element_anchor;
  validate_dynamic_element(
    /*InputComponent*/
    ctx[36]
  );
  let svelte_element = (
    /*InputComponent*/
    ctx[36] && create_dynamic_element_12(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*InputComponent*/
        ctx2[36]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_12(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*InputComponent*/
          ctx2[36]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*InputComponent*/
            ctx2[36]
          );
          svelte_element = create_dynamic_element_12(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*InputComponent*/
      ctx2[36];
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(232:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_63(ctx) {
  let previous_tag = (
    /*InputComponent*/
    ctx[36]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*InputComponent*/
    ctx[36]
  );
  validate_void_dynamic_element(
    /*InputComponent*/
    ctx[36]
  );
  let svelte_element = (
    /*InputComponent*/
    ctx[36] && create_dynamic_element9(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*InputComponent*/
        ctx2[36]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element9(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*InputComponent*/
          ctx2[36]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*InputComponent*/
            ctx2[36]
          );
          validate_void_dynamic_element(
            /*InputComponent*/
            ctx2[36]
          );
          svelte_element = create_dynamic_element9(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*InputComponent*/
      ctx2[36];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_63.name,
    type: "if",
    source: "(194:8) {#if type === 'select'}",
    ctx
  });
  return block;
}
function create_dynamic_element_12(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let svelte_element_type_value;
  let mounted;
  let dispose;
  let svelte_element_levels = [
    { id: (
      /*inputId*/
      ctx[6]
    ) },
    {
      class: svelte_element_class_value = /*c*/
      ctx[41].input[
        /*labelStyleIsFloating*/
        ctx[42]
      ]
    },
    { style: (
      /*inputStyle*/
      ctx[7]
    ) },
    { name: (
      /*name*/
      ctx[8]
    ) },
    {
      type: svelte_element_type_value = /*needsType*/
      ctx[40] ? (
        /*type*/
        ctx[10]
      ) : void 0
    },
    { placeholder: (
      /*placeholder*/
      ctx[15]
    ) },
    { inputmode: (
      /*inputmode*/
      ctx[11]
    ) },
    { size: (
      /*size*/
      ctx[16]
    ) },
    { accept: (
      /*accept*/
      ctx[17]
    ) },
    { autocomplete: (
      /*autocomplete*/
      ctx[18]
    ) },
    { autocorrect: (
      /*autocorrect*/
      ctx[19]
    ) },
    {
      autocapitalize: (
        /*autocapitalize*/
        ctx[20]
      )
    },
    { spellcheck: (
      /*spellcheck*/
      ctx[21]
    ) },
    { autofocus: (
      /*autofocus*/
      ctx[22]
    ) },
    { autosave: (
      /*autosave*/
      ctx[23]
    ) },
    { disabled: (
      /*disabled*/
      ctx[14]
    ) },
    { max: (
      /*max*/
      ctx[24]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[27]
    ) },
    { min: (
      /*min*/
      ctx[25]
    ) },
    { minlength: (
      /*minlength*/
      ctx[28]
    ) },
    { step: (
      /*step*/
      ctx[26]
    ) },
    { multiple: (
      /*multiple*/
      ctx[29]
    ) },
    { readonly: (
      /*readonly*/
      ctx[12]
    ) },
    { required: (
      /*required*/
      ctx[13]
    ) },
    { pattern: (
      /*pattern*/
      ctx[30]
    ) },
    { tabindex: (
      /*tabindex*/
      ctx[31]
    ) },
    { value: (
      /*value*/
      ctx[9]
    ) }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*InputComponent*/
        ctx[36]
      );
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*InputComponent*/
        (ctx[36] || "null").toUpperCase(),
        {
          id: true,
          class: true,
          style: true,
          name: true,
          type: true,
          placeholder: true,
          inputmode: true,
          size: true,
          accept: true,
          autocomplete: true,
          autocorrect: true,
          autocapitalize: true,
          spellcheck: true,
          autofocus: true,
          autosave: true,
          disabled: true,
          max: true,
          maxlength: true,
          min: true,
          minlength: true,
          step: true,
          multiple: true,
          readonly: true,
          required: true,
          pattern: true,
          tabindex: true,
          value: true
        }
      );
      children(svelte_element).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*InputComponent*/
        ctx[36]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file32, 232, 10, 6236);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      ctx[63](svelte_element);
      if (!mounted) {
        dispose = [
          listen_dev(
            svelte_element,
            "input",
            function() {
              if (is_function(
                /*onInput*/
                ctx[32]
              ))
                ctx[32].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "change",
            function() {
              if (is_function(
                /*onChange*/
                ctx[33]
              ))
                ctx[33].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "focus",
            /*onFocusInternal*/
            ctx[43],
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "blur",
            /*onBlurInternal*/
            ctx[44],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      svelte_element_data = get_spread_update(svelte_element_levels, [
        dirty[0] & /*inputId*/
        64 && { id: (
          /*inputId*/
          ctx[6]
        ) },
        dirty[1] & /*c, labelStyleIsFloating*/
        3072 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx[41].input[
          /*labelStyleIsFloating*/
          ctx[42]
        ]) && { class: svelte_element_class_value },
        dirty[0] & /*inputStyle*/
        128 && { style: (
          /*inputStyle*/
          ctx[7]
        ) },
        dirty[0] & /*name*/
        256 && { name: (
          /*name*/
          ctx[8]
        ) },
        dirty[0] & /*type*/
        1024 | dirty[1] & /*needsType*/
        512 && svelte_element_type_value !== (svelte_element_type_value = /*needsType*/
        ctx[40] ? (
          /*type*/
          ctx[10]
        ) : void 0) && { type: svelte_element_type_value },
        dirty[0] & /*placeholder*/
        32768 && { placeholder: (
          /*placeholder*/
          ctx[15]
        ) },
        dirty[0] & /*inputmode*/
        2048 && { inputmode: (
          /*inputmode*/
          ctx[11]
        ) },
        dirty[0] & /*size*/
        65536 && { size: (
          /*size*/
          ctx[16]
        ) },
        dirty[0] & /*accept*/
        131072 && { accept: (
          /*accept*/
          ctx[17]
        ) },
        dirty[0] & /*autocomplete*/
        262144 && { autocomplete: (
          /*autocomplete*/
          ctx[18]
        ) },
        dirty[0] & /*autocorrect*/
        524288 && { autocorrect: (
          /*autocorrect*/
          ctx[19]
        ) },
        dirty[0] & /*autocapitalize*/
        1048576 && {
          autocapitalize: (
            /*autocapitalize*/
            ctx[20]
          )
        },
        dirty[0] & /*spellcheck*/
        2097152 && { spellcheck: (
          /*spellcheck*/
          ctx[21]
        ) },
        dirty[0] & /*autofocus*/
        4194304 && { autofocus: (
          /*autofocus*/
          ctx[22]
        ) },
        dirty[0] & /*autosave*/
        8388608 && { autosave: (
          /*autosave*/
          ctx[23]
        ) },
        dirty[0] & /*disabled*/
        16384 && { disabled: (
          /*disabled*/
          ctx[14]
        ) },
        dirty[0] & /*max*/
        16777216 && { max: (
          /*max*/
          ctx[24]
        ) },
        dirty[0] & /*maxlength*/
        134217728 && { maxlength: (
          /*maxlength*/
          ctx[27]
        ) },
        dirty[0] & /*min*/
        33554432 && { min: (
          /*min*/
          ctx[25]
        ) },
        dirty[0] & /*minlength*/
        268435456 && { minlength: (
          /*minlength*/
          ctx[28]
        ) },
        dirty[0] & /*step*/
        67108864 && { step: (
          /*step*/
          ctx[26]
        ) },
        dirty[0] & /*multiple*/
        536870912 && { multiple: (
          /*multiple*/
          ctx[29]
        ) },
        dirty[0] & /*readonly*/
        4096 && { readonly: (
          /*readonly*/
          ctx[12]
        ) },
        dirty[0] & /*required*/
        8192 && { required: (
          /*required*/
          ctx[13]
        ) },
        dirty[0] & /*pattern*/
        1073741824 && { pattern: (
          /*pattern*/
          ctx[30]
        ) },
        dirty[1] & /*tabindex*/
        1 && { tabindex: (
          /*tabindex*/
          ctx[31]
        ) },
        dirty[0] & /*value*/
        512 && { value: (
          /*value*/
          ctx[9]
        ) }
      ]);
      if (/-/.test(
        /*InputComponent*/
        ctx[36]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      ctx[63](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element_12.name,
    type: "child_dynamic_element",
    source: "(233:10) <svelte:element             this={InputComponent}             id={inputId}             bind:this={inputEl}             class={c.input[labelStyleIsFloating]}             style={inputStyle}             {name}             type={needsType ? type : undefined}             {placeholder}             {inputmode}             {size}             {accept}             {autocomplete}             {autocorrect}             {autocapitalize}             {spellcheck}             {autofocus}             {autosave}             {disabled}             {max}             {maxlength}             {min}             {minlength}             {step}             {multiple}             {readonly}             {required}             {pattern}             {tabindex}             {value}             on:input={onInput}             on:change={onChange}             on:focus={onFocusInternal}             on:blur={onBlurInternal}           />",
    ctx
  });
  return block;
}
function create_dynamic_element9(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let svelte_element_type_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[61].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[64],
    null
  );
  let svelte_element_levels = [
    { id: (
      /*inputId*/
      ctx[6]
    ) },
    {
      class: svelte_element_class_value = /*c*/
      ctx[41].input[
        /*labelStyleIsFloating*/
        ctx[42]
      ]
    },
    { style: (
      /*inputStyle*/
      ctx[7]
    ) },
    { name: (
      /*name*/
      ctx[8]
    ) },
    {
      type: svelte_element_type_value = /*needsType*/
      ctx[40] ? (
        /*type*/
        ctx[10]
      ) : void 0
    },
    { placeholder: (
      /*placeholder*/
      ctx[15]
    ) },
    { inputmode: (
      /*inputmode*/
      ctx[11]
    ) },
    { size: (
      /*size*/
      ctx[16]
    ) },
    { accept: (
      /*accept*/
      ctx[17]
    ) },
    { autocomplete: (
      /*autocomplete*/
      ctx[18]
    ) },
    { autocorrect: (
      /*autocorrect*/
      ctx[19]
    ) },
    {
      autocapitalize: (
        /*autocapitalize*/
        ctx[20]
      )
    },
    { spellcheck: (
      /*spellcheck*/
      ctx[21]
    ) },
    { autofocus: (
      /*autofocus*/
      ctx[22]
    ) },
    { autosave: (
      /*autosave*/
      ctx[23]
    ) },
    { disabled: (
      /*disabled*/
      ctx[14]
    ) },
    { max: (
      /*max*/
      ctx[24]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[27]
    ) },
    { min: (
      /*min*/
      ctx[25]
    ) },
    { minlength: (
      /*minlength*/
      ctx[28]
    ) },
    { step: (
      /*step*/
      ctx[26]
    ) },
    { multiple: (
      /*multiple*/
      ctx[29]
    ) },
    { readonly: (
      /*readonly*/
      ctx[12]
    ) },
    { required: (
      /*required*/
      ctx[13]
    ) },
    { pattern: (
      /*pattern*/
      ctx[30]
    ) },
    { tabindex: (
      /*tabindex*/
      ctx[31]
    ) },
    { value: (
      /*value*/
      ctx[9]
    ) }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*InputComponent*/
        ctx[36]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*InputComponent*/
        (ctx[36] || "null").toUpperCase(),
        {
          id: true,
          class: true,
          style: true,
          name: true,
          type: true,
          placeholder: true,
          inputmode: true,
          size: true,
          accept: true,
          autocomplete: true,
          autocorrect: true,
          autocapitalize: true,
          spellcheck: true,
          autofocus: true,
          autosave: true,
          disabled: true,
          max: true,
          maxlength: true,
          min: true,
          minlength: true,
          step: true,
          multiple: true,
          readonly: true,
          required: true,
          pattern: true,
          tabindex: true,
          value: true
        }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*InputComponent*/
        ctx[36]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file32, 194, 10, 5250);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[62](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            svelte_element,
            "input",
            function() {
              if (is_function(
                /*onInput*/
                ctx[32]
              ))
                ctx[32].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "change",
            function() {
              if (is_function(
                /*onChange*/
                ctx[33]
              ))
                ctx[33].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "focus",
            /*onFocusInternal*/
            ctx[43],
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "blur",
            /*onBlurInternal*/
            ctx[44],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[64],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[64]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[64],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*inputId*/
        64) && { id: (
          /*inputId*/
          ctx[6]
        ) },
        (!current || dirty[1] & /*c, labelStyleIsFloating*/
        3072 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx[41].input[
          /*labelStyleIsFloating*/
          ctx[42]
        ])) && { class: svelte_element_class_value },
        (!current || dirty[0] & /*inputStyle*/
        128) && { style: (
          /*inputStyle*/
          ctx[7]
        ) },
        (!current || dirty[0] & /*name*/
        256) && { name: (
          /*name*/
          ctx[8]
        ) },
        (!current || dirty[0] & /*type*/
        1024 | dirty[1] & /*needsType*/
        512 && svelte_element_type_value !== (svelte_element_type_value = /*needsType*/
        ctx[40] ? (
          /*type*/
          ctx[10]
        ) : void 0)) && { type: svelte_element_type_value },
        (!current || dirty[0] & /*placeholder*/
        32768) && { placeholder: (
          /*placeholder*/
          ctx[15]
        ) },
        (!current || dirty[0] & /*inputmode*/
        2048) && { inputmode: (
          /*inputmode*/
          ctx[11]
        ) },
        (!current || dirty[0] & /*size*/
        65536) && { size: (
          /*size*/
          ctx[16]
        ) },
        (!current || dirty[0] & /*accept*/
        131072) && { accept: (
          /*accept*/
          ctx[17]
        ) },
        (!current || dirty[0] & /*autocomplete*/
        262144) && { autocomplete: (
          /*autocomplete*/
          ctx[18]
        ) },
        (!current || dirty[0] & /*autocorrect*/
        524288) && { autocorrect: (
          /*autocorrect*/
          ctx[19]
        ) },
        (!current || dirty[0] & /*autocapitalize*/
        1048576) && {
          autocapitalize: (
            /*autocapitalize*/
            ctx[20]
          )
        },
        (!current || dirty[0] & /*spellcheck*/
        2097152) && { spellcheck: (
          /*spellcheck*/
          ctx[21]
        ) },
        (!current || dirty[0] & /*autofocus*/
        4194304) && { autofocus: (
          /*autofocus*/
          ctx[22]
        ) },
        (!current || dirty[0] & /*autosave*/
        8388608) && { autosave: (
          /*autosave*/
          ctx[23]
        ) },
        (!current || dirty[0] & /*disabled*/
        16384) && { disabled: (
          /*disabled*/
          ctx[14]
        ) },
        (!current || dirty[0] & /*max*/
        16777216) && { max: (
          /*max*/
          ctx[24]
        ) },
        (!current || dirty[0] & /*maxlength*/
        134217728) && { maxlength: (
          /*maxlength*/
          ctx[27]
        ) },
        (!current || dirty[0] & /*min*/
        33554432) && { min: (
          /*min*/
          ctx[25]
        ) },
        (!current || dirty[0] & /*minlength*/
        268435456) && { minlength: (
          /*minlength*/
          ctx[28]
        ) },
        (!current || dirty[0] & /*step*/
        67108864) && { step: (
          /*step*/
          ctx[26]
        ) },
        (!current || dirty[0] & /*multiple*/
        536870912) && { multiple: (
          /*multiple*/
          ctx[29]
        ) },
        (!current || dirty[0] & /*readonly*/
        4096) && { readonly: (
          /*readonly*/
          ctx[12]
        ) },
        (!current || dirty[0] & /*required*/
        8192) && { required: (
          /*required*/
          ctx[13]
        ) },
        (!current || dirty[0] & /*pattern*/
        1073741824) && { pattern: (
          /*pattern*/
          ctx[30]
        ) },
        (!current || dirty[1] & /*tabindex*/
        1) && { tabindex: (
          /*tabindex*/
          ctx[31]
        ) },
        (!current || dirty[0] & /*value*/
        512) && { value: (
          /*value*/
          ctx[9]
        ) }
      ]);
      if (/-/.test(
        /*InputComponent*/
        ctx[36]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      ctx[62](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element9.name,
    type: "child_dynamic_element",
    source: "(195:10) <svelte:element             this={InputComponent}             id={inputId}             bind:this={inputEl}             class={c.input[labelStyleIsFloating]}             style={inputStyle}             {name}             type={needsType ? type : undefined}             {placeholder}             {inputmode}             {size}             {accept}             {autocomplete}             {autocorrect}             {autocapitalize}             {spellcheck}             {autofocus}             {autosave}             {disabled}             {max}             {maxlength}             {min}             {minlength}             {step}             {multiple}             {readonly}             {required}             {pattern}             {tabindex}             {value}             on:input={onInput}             on:change={onChange}             on:focus={onFocusInternal}             on:blur={onBlurInternal}           >",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let deleteicon;
  let current;
  deleteicon = new DeleteIcon_default({
    props: {
      theme: (
        /*theme*/
        ctx[35]
      ),
      onClick: (
        /*onClear*/
        ctx[34]
      ),
      class: (
        /*c*/
        ctx[41].clearButton
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(deleteicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(deleteicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(deleteicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const deleteicon_changes = {};
      if (dirty[1] & /*theme*/
      16)
        deleteicon_changes.theme = /*theme*/
        ctx2[35];
      if (dirty[1] & /*onClear*/
      8)
        deleteicon_changes.onClick = /*onClear*/
        ctx2[34];
      if (dirty[1] & /*c*/
      1024)
        deleteicon_changes.class = /*c*/
        ctx2[41].clearButton;
      deleteicon.$set(deleteicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(deleteicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(deleteicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(deleteicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(271:6) {#if clearButton}",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let dropdownicon;
  let current;
  dropdownicon = new DropdownIcon_default({
    props: { class: (
      /*c*/
      ctx[41].dropdown
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dropdownicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dropdownicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dropdownicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdownicon_changes = {};
      if (dirty[1] & /*c*/
      1024)
        dropdownicon_changes.class = /*c*/
        ctx2[41].dropdown;
      dropdownicon.$set(dropdownicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdownicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdownicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dropdownicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(274:6) {#if dropdown}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  let if_block = (
    /*error*/
    ctx[3] !== true && create_if_block_25(ctx)
  );
  const error_slot_template = (
    /*#slots*/
    ctx[61].error
  );
  const error_slot = create_slot(
    error_slot_template,
    ctx,
    /*$$scope*/
    ctx[64],
    get_error_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (error_slot)
        error_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      if (error_slot)
        error_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = cls(
        /*c*/
        ctx[41].errorInfo,
        /*c*/
        ctx[41].error
      ));
      add_location(div, file32, 279, 6, 7461);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration_dev(div, t);
      if (error_slot) {
        error_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*error*/
        ctx2[3] !== true
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_25(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (error_slot) {
        if (error_slot.p && (!current || dirty[2] & /*$$scope*/
        4)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[64],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[64]
            ) : get_slot_changes(
              error_slot_template,
              /*$$scope*/
              ctx2[64],
              dirty,
              get_error_slot_changes
            ),
            get_error_slot_context
          );
        }
      }
      if (!current || dirty[1] & /*c*/
      1024 && div_class_value !== (div_class_value = cls(
        /*c*/
        ctx2[41].errorInfo,
        /*c*/
        ctx2[41].error
      ))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (error_slot)
        error_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(279:4) {#if (error && error !== true) || $$slots.error}",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*error*/
        ctx[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*error*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*error*/
      8)
        set_data_dev(
          t,
          /*error*/
          ctx2[3]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(281:8) {#if error !== true}",
    ctx
  });
  return block;
}
function create_if_block14(ctx) {
  let div;
  let t0;
  let t1;
  let div_class_value;
  let current;
  const info_slot_template = (
    /*#slots*/
    ctx[61].info
  );
  const info_slot = create_slot(
    info_slot_template,
    ctx,
    /*$$scope*/
    ctx[64],
    get_info_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*info*/
        ctx[2]
      );
      t1 = space();
      if (info_slot)
        info_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(
        div_nodes,
        /*info*/
        ctx[2]
      );
      t1 = claim_space(div_nodes);
      if (info_slot)
        info_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = cls(
        /*c*/
        ctx[41].errorInfo,
        /*c*/
        ctx[41].info
      ));
      add_location(div, file32, 285, 6, 7644);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      if (info_slot) {
        info_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*info*/
      4)
        set_data_dev(
          t0,
          /*info*/
          ctx2[2]
        );
      if (info_slot) {
        if (info_slot.p && (!current || dirty[2] & /*$$scope*/
        4)) {
          update_slot_base(
            info_slot,
            info_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[64],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[64]
            ) : get_slot_changes(
              info_slot_template,
              /*$$scope*/
              ctx2[64],
              dirty,
              get_info_slot_changes
            ),
            get_info_slot_context
          );
        }
      }
      if (!current || dirty[1] & /*c*/
      1024 && div_class_value !== (div_class_value = cls(
        /*c*/
        ctx2[41].errorInfo,
        /*c*/
        ctx2[41].info
      ))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(info_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (info_slot)
        info_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(285:4) {#if (info || $$slots.info) && !error}",
    ctx
  });
  return block;
}
function create_inner_slot(ctx) {
  let t0;
  let div;
  let current_block_type_index;
  let if_block1;
  let t1;
  let t2;
  let div_class_value;
  let t3;
  let t4;
  let if_block5_anchor;
  let current;
  let if_block0 = (
    /*label*/
    (ctx[1] || /*$$slots*/
    ctx[45].label) && create_if_block_72(ctx)
  );
  const if_block_creators = [create_if_block_53, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[45].input
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = (
    /*clearButton*/
    ctx[4] && create_if_block_43(ctx)
  );
  let if_block3 = (
    /*dropdown*/
    ctx[5] && create_if_block_34(ctx)
  );
  let if_block4 = (
    /*error*/
    (ctx[3] && /*error*/
    ctx[3] !== true || /*$$slots*/
    ctx[45].error) && create_if_block_110(ctx)
  );
  let if_block5 = (
    /*info*/
    (ctx[2] || /*$$slots*/
    ctx[45].info) && !/*error*/
    ctx[3] && create_if_block14(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block3)
        if_block3.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      t4 = claim_space(nodes);
      if (if_block5)
        if_block5.l(nodes);
      if_block5_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[41].inputWrap[
        /*labelStyle*/
        ctx[38]
      ]);
      add_location(div, file32, 188, 4, 5054);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_hydration_dev(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_hydration_dev(target, if_block5_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*label*/
        ctx2[1] || /*$$slots*/
        ctx2[45].label
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*label*/
          2 | dirty[1] & /*$$slots*/
          16384) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_72(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      if (
        /*clearButton*/
        ctx2[4]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*clearButton*/
          16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_43(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*dropdown*/
        ctx2[5]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*dropdown*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_34(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty[1] & /*c, labelStyle*/
      1152 && div_class_value !== (div_class_value = /*c*/
      ctx2[41].inputWrap[
        /*labelStyle*/
        ctx2[38]
      ])) {
        attr_dev(div, "class", div_class_value);
      }
      if (
        /*error*/
        ctx2[3] && /*error*/
        ctx2[3] !== true || /*$$slots*/
        ctx2[45].error
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*error*/
          8 | dirty[1] & /*$$slots*/
          16384) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_110(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t4.parentNode, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*info*/
        (ctx2[2] || /*$$slots*/
        ctx2[45].info) && !/*error*/
        ctx2[3]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*info, error*/
          12 | dirty[1] & /*$$slots*/
          16384) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block14(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (detaching)
        detach_dev(t3);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach_dev(if_block5_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_inner_slot.name,
    type: "slot",
    source: '(180:2) <svelte:fragment slot=\\"inner\\">',
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let listitem;
  let current;
  const listitem_spread_levels = [
    { component: (
      /*component*/
      ctx[0]
    ) },
    { class: (
      /*c*/
      ctx[41].base
    ) },
    { title: void 0 },
    { mediaClass: (
      /*c*/
      ctx[41].media
    ) },
    {
      innerClass: (
        /*c*/
        ctx[41].inner[
          /*labelStyle*/
          ctx[38]
        ]
      )
    },
    { contentClass: (
      /*c*/
      ctx[41].itemContent
    ) },
    { titleWrapClass: (
      /*c*/
      ctx[41].titleWrap
    ) },
    { withMedia: !!/*$$slots*/
    ctx[45].media },
    {
      withTitle: !!/*$$slots*/
      ctx[45].label || !!/*label*/
      ctx[1]
    },
    {
      dividers: (
        /*theme*/
        ctx[35] === "material" || /*isOutline*/
        ctx[37] ? false : void 0
      )
    },
    /*$$restProps*/
    ctx[46]
  ];
  let listitem_props = {
    $$slots: {
      inner: [create_inner_slot],
      media: [create_media_slot],
      content: [create_content_slot],
      default: [create_default_slot9]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < listitem_spread_levels.length; i += 1) {
    listitem_props = assign(listitem_props, listitem_spread_levels[i]);
  }
  listitem = new ListItem_default({ props: listitem_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(listitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(listitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listitem_changes = dirty[0] & /*component, label*/
      3 | dirty[1] & /*c, labelStyle, $$slots, theme, isOutline, $$restProps*/
      50384 ? get_spread_update(listitem_spread_levels, [
        dirty[0] & /*component*/
        1 && { component: (
          /*component*/
          ctx2[0]
        ) },
        dirty[1] & /*c*/
        1024 && { class: (
          /*c*/
          ctx2[41].base
        ) },
        dirty & /*undefined*/
        0 && { title: void 0 },
        dirty[1] & /*c*/
        1024 && { mediaClass: (
          /*c*/
          ctx2[41].media
        ) },
        dirty[1] & /*c, labelStyle*/
        1152 && {
          innerClass: (
            /*c*/
            ctx2[41].inner[
              /*labelStyle*/
              ctx2[38]
            ]
          )
        },
        dirty[1] & /*c*/
        1024 && { contentClass: (
          /*c*/
          ctx2[41].itemContent
        ) },
        dirty[1] & /*c*/
        1024 && { titleWrapClass: (
          /*c*/
          ctx2[41].titleWrap
        ) },
        dirty[1] & /*$$slots*/
        16384 && { withMedia: !!/*$$slots*/
        ctx2[45].media },
        dirty[0] & /*label*/
        2 | dirty[1] & /*$$slots*/
        16384 && {
          withTitle: !!/*$$slots*/
          ctx2[45].label || !!/*label*/
          ctx2[1]
        },
        dirty[1] & /*theme, isOutline*/
        80 && {
          dividers: (
            /*theme*/
            ctx2[35] === "material" || /*isOutline*/
            ctx2[37] ? false : void 0
          )
        },
        dirty[1] & /*$$restProps*/
        32768 && get_spread_object(
          /*$$restProps*/
          ctx2[46]
        )
      ]) : {};
      if (dirty[0] & /*info, error, dropdown, clearButton, inputId, inputStyle, name, type, placeholder, inputmode, size, accept, autocomplete, autocorrect, autocapitalize, spellcheck, autofocus, autosave, disabled, max, maxlength, min, minlength, step, multiple, readonly, required, pattern, value, label*/
      2147483646 | dirty[1] & /*c, $$slots, labelStyle, theme, onClear, labelStyleIsFloating, needsType, tabindex, inputEl, InputComponent, onInput, onChange, isOutline*/
      20479 | dirty[2] & /*$$scope*/
      4) {
        listitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listitem.$set(listitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let isOutline;
  let colors;
  let labelStyle;
  let labelStyleIsFloating;
  let isFloatingTransformed;
  let c;
  let InputComponent;
  let needsType;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "component",
    "label",
    "outline",
    "outlineIos",
    "outlineMaterial",
    "floatingLabel",
    "info",
    "error",
    "clearButton",
    "dropdown",
    "inputId",
    "inputStyle",
    "inputClass",
    "name",
    "value",
    "type",
    "inputmode",
    "readonly",
    "required",
    "disabled",
    "placeholder",
    "size",
    "accept",
    "autocomplete",
    "autocorrect",
    "autocapitalize",
    "spellcheck",
    "autofocus",
    "autosave",
    "max",
    "min",
    "step",
    "maxlength",
    "minlength",
    "multiple",
    "pattern",
    "tabindex",
    "onInput",
    "onChange",
    "onFocus",
    "onBlur",
    "onClear"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListInput", slots, ["label", "input", "default", "error", "info", "media"]);
  const $$slots = compute_slots(slots);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "li" } = $$props;
  let { label = "" } = $$props;
  let { outline = void 0 } = $$props;
  let { outlineIos = void 0 } = $$props;
  let { outlineMaterial = void 0 } = $$props;
  let { floatingLabel = false } = $$props;
  let { info = void 0 } = $$props;
  let { error = void 0 } = $$props;
  let { clearButton = false } = $$props;
  let { dropdown = false } = $$props;
  let { inputId = void 0 } = $$props;
  let { inputStyle = void 0 } = $$props;
  let { inputClass = "" } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { type = "text" } = $$props;
  let { inputmode = void 0 } = $$props;
  let { readonly = void 0 } = $$props;
  let { required = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { accept = void 0 } = $$props;
  let { autocomplete = void 0 } = $$props;
  let { autocorrect = void 0 } = $$props;
  let { autocapitalize = void 0 } = $$props;
  let { spellcheck = void 0 } = $$props;
  let { autofocus = void 0 } = $$props;
  let { autosave = void 0 } = $$props;
  let { max = void 0 } = $$props;
  let { min = void 0 } = $$props;
  let { step = void 0 } = $$props;
  let { maxlength = void 0 } = $$props;
  let { minlength = void 0 } = $$props;
  let { multiple = void 0 } = $$props;
  let { pattern = void 0 } = $$props;
  let { tabindex = void 0 } = $$props;
  let { onInput = void 0 } = $$props;
  let { onChange = void 0 } = $$props;
  let { onFocus = void 0 } = $$props;
  let { onBlur = void 0 } = $$props;
  let { onClear = void 0 } = $$props;
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(35, theme = v));
  let inputEl = null;
  let isFocused = false;
  const dark = useDarkClasses();
  const getDomValue = () => {
    if (!inputEl)
      return void 0;
    return inputEl.value;
  };
  const isInputHasValue = () => {
    const domValue = getDomValue();
    return typeof value === "undefined" ? domValue || domValue === 0 : value || value === 0;
  };
  const getLabelColor = () => {
    if (error || $$slots.error)
      return colors.errorText;
    if (theme === "material") {
      return isFocused ? colors.labelTextFocusMaterial : colors.labelTextMaterial;
    }
    if (theme === "ios") {
      return isFocused ? colors.labelTextFocusIos : colors.labelTextIos;
    }
    return "";
  };
  const onFocusInternal = (e) => {
    $$invalidate(58, isFocused = true);
    if (onFocus)
      onFocus(e);
  };
  const onBlurInternal = (e) => {
    $$invalidate(58, isFocused = false);
    if (onBlur)
      onBlur(e);
  };
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(39, inputEl);
    });
  }
  function svelte_element_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(39, inputEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(46, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(47, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(48, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(49, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(50, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(0, component = $$new_props.component);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("outline" in $$new_props)
      $$invalidate(51, outline = $$new_props.outline);
    if ("outlineIos" in $$new_props)
      $$invalidate(52, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$new_props)
      $$invalidate(53, outlineMaterial = $$new_props.outlineMaterial);
    if ("floatingLabel" in $$new_props)
      $$invalidate(54, floatingLabel = $$new_props.floatingLabel);
    if ("info" in $$new_props)
      $$invalidate(2, info = $$new_props.info);
    if ("error" in $$new_props)
      $$invalidate(3, error = $$new_props.error);
    if ("clearButton" in $$new_props)
      $$invalidate(4, clearButton = $$new_props.clearButton);
    if ("dropdown" in $$new_props)
      $$invalidate(5, dropdown = $$new_props.dropdown);
    if ("inputId" in $$new_props)
      $$invalidate(6, inputId = $$new_props.inputId);
    if ("inputStyle" in $$new_props)
      $$invalidate(7, inputStyle = $$new_props.inputStyle);
    if ("inputClass" in $$new_props)
      $$invalidate(55, inputClass = $$new_props.inputClass);
    if ("name" in $$new_props)
      $$invalidate(8, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(9, value = $$new_props.value);
    if ("type" in $$new_props)
      $$invalidate(10, type = $$new_props.type);
    if ("inputmode" in $$new_props)
      $$invalidate(11, inputmode = $$new_props.inputmode);
    if ("readonly" in $$new_props)
      $$invalidate(12, readonly = $$new_props.readonly);
    if ("required" in $$new_props)
      $$invalidate(13, required = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate(14, disabled = $$new_props.disabled);
    if ("placeholder" in $$new_props)
      $$invalidate(15, placeholder = $$new_props.placeholder);
    if ("size" in $$new_props)
      $$invalidate(16, size = $$new_props.size);
    if ("accept" in $$new_props)
      $$invalidate(17, accept = $$new_props.accept);
    if ("autocomplete" in $$new_props)
      $$invalidate(18, autocomplete = $$new_props.autocomplete);
    if ("autocorrect" in $$new_props)
      $$invalidate(19, autocorrect = $$new_props.autocorrect);
    if ("autocapitalize" in $$new_props)
      $$invalidate(20, autocapitalize = $$new_props.autocapitalize);
    if ("spellcheck" in $$new_props)
      $$invalidate(21, spellcheck = $$new_props.spellcheck);
    if ("autofocus" in $$new_props)
      $$invalidate(22, autofocus = $$new_props.autofocus);
    if ("autosave" in $$new_props)
      $$invalidate(23, autosave = $$new_props.autosave);
    if ("max" in $$new_props)
      $$invalidate(24, max = $$new_props.max);
    if ("min" in $$new_props)
      $$invalidate(25, min = $$new_props.min);
    if ("step" in $$new_props)
      $$invalidate(26, step = $$new_props.step);
    if ("maxlength" in $$new_props)
      $$invalidate(27, maxlength = $$new_props.maxlength);
    if ("minlength" in $$new_props)
      $$invalidate(28, minlength = $$new_props.minlength);
    if ("multiple" in $$new_props)
      $$invalidate(29, multiple = $$new_props.multiple);
    if ("pattern" in $$new_props)
      $$invalidate(30, pattern = $$new_props.pattern);
    if ("tabindex" in $$new_props)
      $$invalidate(31, tabindex = $$new_props.tabindex);
    if ("onInput" in $$new_props)
      $$invalidate(32, onInput = $$new_props.onInput);
    if ("onChange" in $$new_props)
      $$invalidate(33, onChange = $$new_props.onChange);
    if ("onFocus" in $$new_props)
      $$invalidate(56, onFocus = $$new_props.onFocus);
    if ("onBlur" in $$new_props)
      $$invalidate(57, onBlur = $$new_props.onBlur);
    if ("onClear" in $$new_props)
      $$invalidate(34, onClear = $$new_props.onClear);
    if ("$$scope" in $$new_props)
      $$invalidate(64, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useTheme,
    useThemeClasses,
    DeleteIcon: DeleteIcon_default,
    DropdownIcon: DropdownIcon_default,
    ListItem: ListItem_default,
    useDarkClasses,
    ListInputClasses,
    ListInputColors,
    cls,
    className,
    colorsProp,
    ios,
    material,
    component,
    label,
    outline,
    outlineIos,
    outlineMaterial,
    floatingLabel,
    info,
    error,
    clearButton,
    dropdown,
    inputId,
    inputStyle,
    inputClass,
    name,
    value,
    type,
    inputmode,
    readonly,
    required,
    disabled,
    placeholder,
    size,
    accept,
    autocomplete,
    autocorrect,
    autocapitalize,
    spellcheck,
    autofocus,
    autosave,
    max,
    min,
    step,
    maxlength,
    minlength,
    multiple,
    pattern,
    tabindex,
    onInput,
    onChange,
    onFocus,
    onBlur,
    onClear,
    theme,
    inputEl,
    isFocused,
    dark,
    getDomValue,
    isInputHasValue,
    getLabelColor,
    onFocusInternal,
    onBlurInternal,
    InputComponent,
    needsType,
    c,
    isFloatingTransformed,
    colors,
    isOutline,
    labelStyle,
    labelStyleIsFloating
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(47, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(48, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(49, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(50, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(0, component = $$new_props.component);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("outline" in $$props)
      $$invalidate(51, outline = $$new_props.outline);
    if ("outlineIos" in $$props)
      $$invalidate(52, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$props)
      $$invalidate(53, outlineMaterial = $$new_props.outlineMaterial);
    if ("floatingLabel" in $$props)
      $$invalidate(54, floatingLabel = $$new_props.floatingLabel);
    if ("info" in $$props)
      $$invalidate(2, info = $$new_props.info);
    if ("error" in $$props)
      $$invalidate(3, error = $$new_props.error);
    if ("clearButton" in $$props)
      $$invalidate(4, clearButton = $$new_props.clearButton);
    if ("dropdown" in $$props)
      $$invalidate(5, dropdown = $$new_props.dropdown);
    if ("inputId" in $$props)
      $$invalidate(6, inputId = $$new_props.inputId);
    if ("inputStyle" in $$props)
      $$invalidate(7, inputStyle = $$new_props.inputStyle);
    if ("inputClass" in $$props)
      $$invalidate(55, inputClass = $$new_props.inputClass);
    if ("name" in $$props)
      $$invalidate(8, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(9, value = $$new_props.value);
    if ("type" in $$props)
      $$invalidate(10, type = $$new_props.type);
    if ("inputmode" in $$props)
      $$invalidate(11, inputmode = $$new_props.inputmode);
    if ("readonly" in $$props)
      $$invalidate(12, readonly = $$new_props.readonly);
    if ("required" in $$props)
      $$invalidate(13, required = $$new_props.required);
    if ("disabled" in $$props)
      $$invalidate(14, disabled = $$new_props.disabled);
    if ("placeholder" in $$props)
      $$invalidate(15, placeholder = $$new_props.placeholder);
    if ("size" in $$props)
      $$invalidate(16, size = $$new_props.size);
    if ("accept" in $$props)
      $$invalidate(17, accept = $$new_props.accept);
    if ("autocomplete" in $$props)
      $$invalidate(18, autocomplete = $$new_props.autocomplete);
    if ("autocorrect" in $$props)
      $$invalidate(19, autocorrect = $$new_props.autocorrect);
    if ("autocapitalize" in $$props)
      $$invalidate(20, autocapitalize = $$new_props.autocapitalize);
    if ("spellcheck" in $$props)
      $$invalidate(21, spellcheck = $$new_props.spellcheck);
    if ("autofocus" in $$props)
      $$invalidate(22, autofocus = $$new_props.autofocus);
    if ("autosave" in $$props)
      $$invalidate(23, autosave = $$new_props.autosave);
    if ("max" in $$props)
      $$invalidate(24, max = $$new_props.max);
    if ("min" in $$props)
      $$invalidate(25, min = $$new_props.min);
    if ("step" in $$props)
      $$invalidate(26, step = $$new_props.step);
    if ("maxlength" in $$props)
      $$invalidate(27, maxlength = $$new_props.maxlength);
    if ("minlength" in $$props)
      $$invalidate(28, minlength = $$new_props.minlength);
    if ("multiple" in $$props)
      $$invalidate(29, multiple = $$new_props.multiple);
    if ("pattern" in $$props)
      $$invalidate(30, pattern = $$new_props.pattern);
    if ("tabindex" in $$props)
      $$invalidate(31, tabindex = $$new_props.tabindex);
    if ("onInput" in $$props)
      $$invalidate(32, onInput = $$new_props.onInput);
    if ("onChange" in $$props)
      $$invalidate(33, onChange = $$new_props.onChange);
    if ("onFocus" in $$props)
      $$invalidate(56, onFocus = $$new_props.onFocus);
    if ("onBlur" in $$props)
      $$invalidate(57, onBlur = $$new_props.onBlur);
    if ("onClear" in $$props)
      $$invalidate(34, onClear = $$new_props.onClear);
    if ("theme" in $$props)
      $$invalidate(35, theme = $$new_props.theme);
    if ("inputEl" in $$props)
      $$invalidate(39, inputEl = $$new_props.inputEl);
    if ("isFocused" in $$props)
      $$invalidate(58, isFocused = $$new_props.isFocused);
    if ("InputComponent" in $$props)
      $$invalidate(36, InputComponent = $$new_props.InputComponent);
    if ("needsType" in $$props)
      $$invalidate(40, needsType = $$new_props.needsType);
    if ("c" in $$props)
      $$invalidate(41, c = $$new_props.c);
    if ("isFloatingTransformed" in $$props)
      $$invalidate(59, isFloatingTransformed = $$new_props.isFloatingTransformed);
    if ("colors" in $$props)
      $$invalidate(60, colors = $$new_props.colors);
    if ("isOutline" in $$props)
      $$invalidate(37, isOutline = $$new_props.isOutline);
    if ("labelStyle" in $$props)
      $$invalidate(38, labelStyle = $$new_props.labelStyle);
    if ("labelStyleIsFloating" in $$props)
      $$invalidate(42, labelStyleIsFloating = $$new_props.labelStyleIsFloating);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*outline, theme, outlineIos, outlineMaterial*/
    7340048) {
      $:
        $$invalidate(37, isOutline = typeof outline === "undefined" ? theme === "ios" ? outlineIos : outlineMaterial : outline);
    }
    if ($$self.$$.dirty[1] & /*colorsProp*/
    131072) {
      $:
        $$invalidate(60, colors = ListInputColors(colorsProp, dark));
    }
    if ($$self.$$.dirty[0] & /*label*/
    2 | $$self.$$.dirty[1] & /*floatingLabel*/
    8388608) {
      $:
        $$invalidate(38, labelStyle = label && floatingLabel ? "floating" : "stacked");
    }
    if ($$self.$$.dirty[1] & /*labelStyle*/
    128) {
      $:
        $$invalidate(42, labelStyleIsFloating = labelStyle === "floating" ? "floating" : "notFloating");
    }
    if ($$self.$$.dirty[0] & /*label*/
    2 | $$self.$$.dirty[1] & /*floatingLabel, isFocused*/
    142606336) {
      $:
        $$invalidate(59, isFloatingTransformed = (label || $$slots.label) && floatingLabel && !isInputHasValue() && !isFocused);
    }
    if ($$self.$$.dirty[0] & /*error, type, label*/
    1034 | $$self.$$.dirty[1] & /*ios, material, inputClass, isOutline, colors, isFloatingTransformed, isFocused, className*/
    957153344) {
      $:
        $$invalidate(41, c = useThemeClasses(
          { ios, material },
          ListInputClasses(
            {
              error,
              type,
              inputClass,
              outline: isOutline
            },
            colors,
            {
              isFloatingTransformed,
              isFocused,
              darkClasses: dark,
              getLabelColor,
              inputClass,
              hasLabel: !!label || $$slots.label
            }
          ),
          className,
          (v) => $$invalidate(41, c = v)
        ));
    }
    if ($$self.$$.dirty[0] & /*type*/
    1024) {
      $:
        $$invalidate(36, InputComponent = type === "select" || type === "textarea" ? type : "input");
    }
    if ($$self.$$.dirty[1] & /*InputComponent*/
    32) {
      $:
        $$invalidate(40, needsType = InputComponent === "input");
    }
  };
  return [
    component,
    label,
    info,
    error,
    clearButton,
    dropdown,
    inputId,
    inputStyle,
    name,
    value,
    type,
    inputmode,
    readonly,
    required,
    disabled,
    placeholder,
    size,
    accept,
    autocomplete,
    autocorrect,
    autocapitalize,
    spellcheck,
    autofocus,
    autosave,
    max,
    min,
    step,
    maxlength,
    minlength,
    multiple,
    pattern,
    tabindex,
    onInput,
    onChange,
    onClear,
    theme,
    InputComponent,
    isOutline,
    labelStyle,
    inputEl,
    needsType,
    c,
    labelStyleIsFloating,
    onFocusInternal,
    onBlurInternal,
    $$slots,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    outline,
    outlineIos,
    outlineMaterial,
    floatingLabel,
    inputClass,
    onFocus,
    onBlur,
    isFocused,
    isFloatingTransformed,
    colors,
    slots,
    svelte_element_binding,
    svelte_element_binding_1,
    $$scope
  ];
}
var ListInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance33,
      create_fragment33,
      safe_not_equal,
      {
        class: 47,
        colors: 48,
        ios: 49,
        material: 50,
        component: 0,
        label: 1,
        outline: 51,
        outlineIos: 52,
        outlineMaterial: 53,
        floatingLabel: 54,
        info: 2,
        error: 3,
        clearButton: 4,
        dropdown: 5,
        inputId: 6,
        inputStyle: 7,
        inputClass: 55,
        name: 8,
        value: 9,
        type: 10,
        inputmode: 11,
        readonly: 12,
        required: 13,
        disabled: 14,
        placeholder: 15,
        size: 16,
        accept: 17,
        autocomplete: 18,
        autocorrect: 19,
        autocapitalize: 20,
        spellcheck: 21,
        autofocus: 22,
        autosave: 23,
        max: 24,
        min: 25,
        step: 26,
        maxlength: 27,
        minlength: 28,
        multiple: 29,
        pattern: 30,
        tabindex: 31,
        onInput: 32,
        onChange: 33,
        onFocus: 56,
        onBlur: 57,
        onClear: 34
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListInput",
      options,
      id: create_fragment33.name
    });
  }
  get class() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineIos() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineIos(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineMaterial() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineMaterial(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatingLabel() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatingLabel(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearButton() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearButton(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdown() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdown(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputStyle() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputStyle(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputClass() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputClass(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputmode() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputmode(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accept() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocomplete() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocomplete(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocorrect() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocorrect(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocapitalize() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocapitalize(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spellcheck() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spellcheck(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autofocus() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autofocus(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autosave() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autosave(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxlength() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxlength(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minlength() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minlength(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pattern() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pattern(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onInput() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onInput(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onFocus() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onFocus(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBlur() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBlur(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClear() {
    throw new Error("<ListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClear(value) {
    throw new Error("<ListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListInput_default = ListInput;

// node_modules/konsta/svelte/components/MenuList.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(5:0) <List menuList {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let list;
  let current;
  const list_spread_levels = [
    { menuList: true },
    /*$$restProps*/
    ctx[0]
  ];
  let list_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < list_spread_levels.length; i += 1) {
    list_props = assign(list_props, list_spread_levels[i]);
  }
  list = new List_default({ props: list_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(list.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(list.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const list_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(list_spread_levels, [list_spread_levels[0], get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(list, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuList", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ List: List_default });
  return [$$restProps, slots, $$scope];
}
var MenuList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuList",
      options,
      id: create_fragment34.name
    });
  }
};
var MenuList_default = MenuList;

// node_modules/konsta/svelte/components/MenuListItem.svelte
var get_title_slot_changes3 = (dirty) => ({});
var get_title_slot_context3 = (ctx) => ({});
var get_media_slot_changes4 = (dirty) => ({});
var get_media_slot_context4 = (ctx) => ({});
var get_header_slot_changes3 = (dirty) => ({});
var get_header_slot_context3 = (ctx) => ({});
var get_after_slot_changes2 = (dirty) => ({});
var get_after_slot_context2 = (ctx) => ({});
var get_subtitle_slot_changes2 = (dirty) => ({});
var get_subtitle_slot_context2 = (ctx) => ({});
var get_text_slot_changes3 = (dirty) => ({});
var get_text_slot_context3 = (ctx) => ({});
var get_footer_slot_changes3 = (dirty) => ({});
var get_footer_slot_context3 = (ctx) => ({});
var get_inner_slot_changes2 = (dirty) => ({});
var get_inner_slot_context2 = (ctx) => ({});
var get_content_slot_changes2 = (dirty) => ({});
var get_content_slot_context2 = (ctx) => ({});
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(8:0) <ListItem   menuListItem   menuListItemActive={active}   href={href || false}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_if_block_83(ctx) {
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[4].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_title_slot_context3
  );
  const block = {
    c: function create() {
      if (title_slot)
        title_slot.c();
    },
    l: function claim(nodes) {
      if (title_slot)
        title_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (title_slot) {
        title_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_title_slot_changes3
            ),
            get_title_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_83.name,
    type: "if",
    source: "(15:4) {#if $$slots.title}",
    ctx
  });
  return block;
}
function create_title_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[3].title && create_if_block_83(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[3].title
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_83(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_title_slot.name,
    type: "slot",
    source: '(14:2) <svelte:fragment slot=\\"title\\">',
    ctx
  });
  return block;
}
function create_if_block_73(ctx) {
  let current;
  const media_slot_template = (
    /*#slots*/
    ctx[4].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_media_slot_context4
  );
  const block = {
    c: function create() {
      if (media_slot)
        media_slot.c();
    },
    l: function claim(nodes) {
      if (media_slot)
        media_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (media_slot) {
        media_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (media_slot) {
        if (media_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_media_slot_changes4
            ),
            get_media_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_73.name,
    type: "if",
    source: "(20:4) {#if $$slots.media}",
    ctx
  });
  return block;
}
function create_media_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[3].media && create_if_block_73(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[3].media
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_73(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_media_slot2.name,
    type: "slot",
    source: '(19:2) <svelte:fragment slot=\\"media\\">',
    ctx
  });
  return block;
}
function create_if_block_64(ctx) {
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[4].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_header_slot_context3
  );
  const block = {
    c: function create() {
      if (header_slot)
        header_slot.c();
    },
    l: function claim(nodes) {
      if (header_slot)
        header_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_header_slot_changes3
            ),
            get_header_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_64.name,
    type: "if",
    source: "(25:4) {#if $$slots.header}",
    ctx
  });
  return block;
}
function create_header_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[3].header && create_if_block_64(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[3].header
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_64(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_header_slot.name,
    type: "slot",
    source: '(24:2) <svelte:fragment slot=\\"header\\">',
    ctx
  });
  return block;
}
function create_if_block_54(ctx) {
  let current;
  const after_slot_template = (
    /*#slots*/
    ctx[4].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_after_slot_context2
  );
  const block = {
    c: function create() {
      if (after_slot)
        after_slot.c();
    },
    l: function claim(nodes) {
      if (after_slot)
        after_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (after_slot) {
        after_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_slot) {
        if (after_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_after_slot_changes2
            ),
            get_after_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (after_slot)
        after_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_54.name,
    type: "if",
    source: "(31:4) {#if $$slots.after}",
    ctx
  });
  return block;
}
function create_after_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[3].after && create_if_block_54(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[3].after
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_54(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_after_slot.name,
    type: "slot",
    source: "(30:2) ",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[4].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_subtitle_slot_context2
  );
  const block = {
    c: function create() {
      if (subtitle_slot)
        subtitle_slot.c();
    },
    l: function claim(nodes) {
      if (subtitle_slot)
        subtitle_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (subtitle_slot) {
        subtitle_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_subtitle_slot_changes2
            ),
            get_subtitle_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(36:4) {#if $$slots.subtitle}",
    ctx
  });
  return block;
}
function create_subtitle_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[3].subtitle && create_if_block_44(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[3].subtitle
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_44(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_subtitle_slot.name,
    type: "slot",
    source: '(35:2) <svelte:fragment slot=\\"subtitle\\">',
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[4].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_text_slot_context3
  );
  const block = {
    c: function create() {
      if (text_slot)
        text_slot.c();
    },
    l: function claim(nodes) {
      if (text_slot)
        text_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (text_slot) {
        text_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (text_slot) {
        if (text_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_text_slot_changes3
            ),
            get_text_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(41:4) {#if $$slots.text}",
    ctx
  });
  return block;
}
function create_text_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[3].text && create_if_block_35(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[3].text
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_35(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_text_slot.name,
    type: "slot",
    source: '(40:2) <svelte:fragment slot=\\"text\\">',
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[4].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_footer_slot_context3
  );
  const block = {
    c: function create() {
      if (footer_slot)
        footer_slot.c();
    },
    l: function claim(nodes) {
      if (footer_slot)
        footer_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (footer_slot) {
        footer_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_footer_slot_changes3
            ),
            get_footer_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(46:4) {#if $$slots.footer}",
    ctx
  });
  return block;
}
function create_footer_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[3].footer && create_if_block_26(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[3].footer
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_26(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_footer_slot.name,
    type: "slot",
    source: '(45:2) <svelte:fragment slot=\\"footer\\">',
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let current;
  const inner_slot_template = (
    /*#slots*/
    ctx[4].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_inner_slot_context2
  );
  const block = {
    c: function create() {
      if (inner_slot)
        inner_slot.c();
    },
    l: function claim(nodes) {
      if (inner_slot)
        inner_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_inner_slot_changes2
            ),
            get_inner_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inner_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inner_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (inner_slot)
        inner_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(51:4) {#if $$slots.inner}",
    ctx
  });
  return block;
}
function create_inner_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[3].inner && create_if_block_111(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[3].inner
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_111(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_inner_slot2.name,
    type: "slot",
    source: '(50:2) <svelte:fragment slot=\\"inner\\">',
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let current;
  const content_slot_template = (
    /*#slots*/
    ctx[4].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_content_slot_context2
  );
  const block = {
    c: function create() {
      if (content_slot)
        content_slot.c();
    },
    l: function claim(nodes) {
      if (content_slot)
        content_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (content_slot) {
        content_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_content_slot_changes2
            ),
            get_content_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(content_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (content_slot)
        content_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(56:4) {#if $$slots.content}",
    ctx
  });
  return block;
}
function create_content_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$$slots*/
    ctx[3].content && create_if_block15(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[3].content
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_content_slot2.name,
    type: "slot",
    source: '(55:2) <svelte:fragment slot=\\"content\\">',
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let listitem;
  let current;
  const listitem_spread_levels = [
    { menuListItem: true },
    { menuListItemActive: (
      /*active*/
      ctx[0]
    ) },
    { href: (
      /*href*/
      ctx[1] || false
    ) },
    /*$$restProps*/
    ctx[2]
  ];
  let listitem_props = {
    $$slots: {
      content: [create_content_slot2],
      inner: [create_inner_slot2],
      footer: [create_footer_slot],
      text: [create_text_slot],
      subtitle: [create_subtitle_slot],
      after: [create_after_slot],
      header: [create_header_slot],
      media: [create_media_slot2],
      title: [create_title_slot],
      default: [create_default_slot11]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < listitem_spread_levels.length; i += 1) {
    listitem_props = assign(listitem_props, listitem_spread_levels[i]);
  }
  listitem = new ListItem_default({ props: listitem_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(listitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(listitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const listitem_changes = dirty & /*active, href, $$restProps*/
      7 ? get_spread_update(listitem_spread_levels, [
        listitem_spread_levels[0],
        dirty & /*active*/
        1 && { menuListItemActive: (
          /*active*/
          ctx2[0]
        ) },
        dirty & /*href*/
        2 && { href: (
          /*href*/
          ctx2[1] || false
        ) },
        dirty & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx2[2]
        )
      ]) : {};
      if (dirty & /*$$scope, $$slots*/
      40) {
        listitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listitem.$set(listitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  const omit_props_names = ["active", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuListItem", slots, [
    "content",
    "inner",
    "footer",
    "text",
    "subtitle",
    "after",
    "header",
    "media",
    "title",
    "default"
  ]);
  const $$slots = compute_slots(slots);
  let { active = false } = $$props;
  let { href = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ ListItem: ListItem_default, active, href });
  $$self.$inject_state = ($$new_props) => {
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("href" in $$props)
      $$invalidate(1, href = $$new_props.href);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [active, href, $$restProps, $$slots, slots, $$scope];
}
var MenuListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, { active: 0, href: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuListItem",
      options,
      id: create_fragment35.name
    });
  }
  get active() {
    throw new Error("<MenuListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<MenuListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<MenuListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<MenuListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuListItem_default = MenuListItem;

// node_modules/konsta/shared/esm/classes/NavbarClasses.js
var NavbarClasses = (props, colors, classes) => {
  const {
    outline,
    translucent,
    large,
    medium,
    transparent,
    left,
    right,
    fontSizeIos,
    fontSizeMaterial,
    titleFontSizeIos,
    titleFontSizeMaterial,
    titleLargeFontSizeIos,
    titleLargeFontSizeMaterial,
    titleMediumFontSizeIos,
    titleMediumFontSizeMaterial,
    bgClassName = "",
    bgClass = "",
    subnavbarClassName = "",
    subnavbarClass = "",
    innerClassName = "",
    innerClass = "",
    leftClassName = "",
    leftClass = "",
    titleClassName = "",
    titleClass = "",
    subtitleClassName = "",
    subtitleClass = "",
    rightClassName = "",
    rightClass = "",
    centerTitle
  } = props;
  return {
    base: {
      common: cls(`w-full z-20 top-0 pt-safe`, (large || medium) && "pointer-events-none", positionClass("sticky", classes)),
      ios: cls(fontSizeIos, colors.textIos),
      material: cls(fontSizeMaterial, colors.textMaterial)
    },
    bg: {
      common: cls("absolute w-full h-full left-0 top-0", outline && "hairline-b", bgClassName || bgClass),
      ios: cls(colors.bgIos, translucent && "translucent"),
      material: `${colors.bgMaterial}`
    },
    subnavbar: {
      common: cls("relative flex items-center", subnavbarClassName || subnavbarClass, (large || medium) && "pointer-events-auto"),
      ios: "h-11 pl-2-safe pr-2-safe",
      material: "h-14 pl-4-safe pr-4-safe"
    },
    inner: {
      common: cls("flex relative items-center w-full overflow-hidden", innerClassName || innerClass, (large || medium) && "pointer-events-auto z-10"),
      ios: cls("pl-2-safe pr-2-safe h-11", !left && right ? "justify-end" : "justify-between"),
      material: "justify-start h-16 pl-safe pr-safe"
    },
    titleContainer: {
      common: cls("flex items-center px-4 relative", (large || medium) && "pointer-events-auto"),
      ios: cls(medium && cls(titleMediumFontSizeIos, "h-11 font-semibold"), large && cls(titleLargeFontSizeIos, "h-13 font-bold")),
      material: cls(medium && cls(titleMediumFontSizeMaterial, "h-12 pb-4"), large && cls(titleLargeFontSizeMaterial, "h-[5.5rem]"))
    },
    left: {
      common: cls("flex justify-center items-center h-full", leftClassName || leftClass),
      ios: "mr-2 transform transform-gpu",
      material: "mx-1"
    },
    title: {
      common: cls(`whitespace-nowrap leading-tight`, titleClassName || titleClass, (large || medium || transparent) && "opacity-0", centerTitle ? `absolute top-1/2 left-1/2 transform-gpu -translate-x-1/2 -translate-y-1/2 text-center` : "text-left"),
      ios: cls(`${titleFontSizeIos} font-semibold`, !centerTitle && "first:mx-2"),
      material: cls(`${titleFontSizeMaterial} font-normal`, !centerTitle && "first:mx-4")
    },
    subtitle: {
      common: cls("font-normal leading-none", subtitleClassName || subtitleClass),
      ios: "text-2xs opacity-55",
      material: "text-sm opacity-85"
    },
    right: {
      common: cls("flex justify-center items-center h-full", rightClassName || rightClass),
      ios: cls("transform transform-gpu", centerTitle ? "ml-2" : "ml-auto"),
      material: "ml-auto mr-1"
    }
  };
};

// node_modules/konsta/shared/esm/colors/NavbarColors.js
var NavbarColors = (colorsProp, dark) => {
  return {
    bgIos: cls("bg-ios-light-surface-2", dark("dark:bg-ios-dark-surface-2")),
    bgMaterial: cls("bg-md-light-surface-2", dark("dark:bg-md-dark-surface-2")),
    textIos: cls("text-black", dark("dark:text-white")),
    textMaterial: cls("text-md-light-on-surface", dark("dark:text-md-dark-on-surface")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Navbar.svelte
var file33 = "node_modules/konsta/svelte/components/Navbar.svelte";
var get_subnavbar_slot_changes = (dirty) => ({});
var get_subnavbar_slot_context = (ctx) => ({});
var get_title_slot_changes_12 = (dirty) => ({});
var get_title_slot_context_12 = (ctx) => ({});
var get_right_slot_changes = (dirty) => ({});
var get_right_slot_context = (ctx) => ({});
var get_subtitle_slot_changes3 = (dirty) => ({});
var get_subtitle_slot_context3 = (ctx) => ({});
var get_title_slot_changes4 = (dirty) => ({});
var get_title_slot_context4 = (ctx) => ({});
var get_left_slot_changes = (dirty) => ({});
var get_left_slot_context = (ctx) => ({});
function create_if_block_55(ctx) {
  let div;
  let div_class_value;
  let current;
  const left_slot_template = (
    /*#slots*/
    ctx[41].left
  );
  const left_slot = create_slot(
    left_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    get_left_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (left_slot)
        left_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (left_slot)
        left_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[10].left);
      add_location(div, file33, 213, 6, 5523);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (left_slot) {
        left_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (left_slot) {
        if (left_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              left_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              get_left_slot_changes
            ),
            get_left_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      1024 && div_class_value !== (div_class_value = /*c*/
      ctx2[10].left)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(left_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(left_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (left_slot)
        left_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_55.name,
    type: "if",
    source: "(213:4) {#if $$slots.left}",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let div_class_value;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[41].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    get_title_slot_context4
  );
  let if_block = (
    /*subtitle*/
    (ctx[3] || /*$$slots*/
    ctx[12].subtitle) && create_if_block_45(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*title*/
        ctx[2]
      );
      t1 = space();
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(
        div_nodes,
        /*title*/
        ctx[2]
      );
      t1 = claim_space(div_nodes);
      if (title_slot)
        title_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[10].title);
      add_location(div, file33, 216, 6, 5651);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append_hydration_dev(div, t2);
      if (if_block)
        if_block.m(div, null);
      ctx[43](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*title*/
      4)
        set_data_dev(
          t0,
          /*title*/
          ctx2[2]
        );
      if (title_slot) {
        if (title_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              get_title_slot_changes4
            ),
            get_title_slot_context4
          );
        }
      }
      if (
        /*subtitle*/
        ctx2[3] || /*$$slots*/
        ctx2[12].subtitle
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*subtitle, $$slots*/
          4104) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_45(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*c*/
      1024 && div_class_value !== (div_class_value = /*c*/
      ctx2[10].title)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[43](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(216:4) {#if $$slots.title || $$slots.subtitle || title || subtitle}",
    ctx
  });
  return block;
}
function create_if_block_45(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[41].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    get_subtitle_slot_context3
  );
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*subtitle*/
        ctx[3]
      );
      if (subtitle_slot)
        subtitle_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*subtitle*/
        ctx[3]
      );
      if (subtitle_slot)
        subtitle_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[10].subtitle);
      add_location(div, file33, 220, 10, 5795);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*subtitle*/
      8)
        set_data_dev(
          t,
          /*subtitle*/
          ctx2[3]
        );
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              get_subtitle_slot_changes3
            ),
            get_subtitle_slot_context3
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      1024 && div_class_value !== (div_class_value = /*c*/
      ctx2[10].subtitle)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_45.name,
    type: "if",
    source: "(220:8) {#if subtitle || $$slots.subtitle}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let div;
  let div_class_value;
  let current;
  const right_slot_template = (
    /*#slots*/
    ctx[41].right
  );
  const right_slot = create_slot(
    right_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    get_right_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (right_slot)
        right_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (right_slot)
        right_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[10].right);
      add_location(div, file33, 227, 6, 5951);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (right_slot) {
        right_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (right_slot) {
        if (right_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              right_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              get_right_slot_changes
            ),
            get_right_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      1024 && div_class_value !== (div_class_value = /*c*/
      ctx2[10].right)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(right_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(right_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (right_slot)
        right_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(227:4) {#if $$slots.right}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let div;
  let t0;
  let t1;
  let div_class_value;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[41].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    get_title_slot_context_12
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*title*/
        ctx[2]
      );
      t1 = space();
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(
        div_nodes,
        /*title*/
        ctx[2]
      );
      t1 = claim_space(div_nodes);
      if (title_slot)
        title_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[10].titleContainer);
      add_location(div, file33, 232, 4, 6060);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      ctx[45](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*title*/
      4)
        set_data_dev(
          t0,
          /*title*/
          ctx2[2]
        );
      if (title_slot) {
        if (title_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              get_title_slot_changes_12
            ),
            get_title_slot_context_12
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      1024 && div_class_value !== (div_class_value = /*c*/
      ctx2[10].titleContainer)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
      ctx[45](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(232:2) {#if large || medium}",
    ctx
  });
  return block;
}
function create_if_block16(ctx) {
  let div;
  let div_class_value;
  let current;
  const subnavbar_slot_template = (
    /*#slots*/
    ctx[41].subnavbar
  );
  const subnavbar_slot = create_slot(
    subnavbar_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    get_subnavbar_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (subnavbar_slot)
        subnavbar_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (subnavbar_slot)
        subnavbar_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[10].subnavbar);
      add_location(div, file33, 238, 4, 6214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (subnavbar_slot) {
        subnavbar_slot.m(div, null);
      }
      ctx[46](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (subnavbar_slot) {
        if (subnavbar_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            subnavbar_slot,
            subnavbar_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              subnavbar_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              get_subnavbar_slot_changes
            ),
            get_subnavbar_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      1024 && div_class_value !== (div_class_value = /*c*/
      ctx2[10].subnavbar)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subnavbar_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subnavbar_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subnavbar_slot)
        subnavbar_slot.d(detaching);
      ctx[46](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(238:2) {#if $$slots.subnavbar}",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let div2;
  let div0;
  let div0_class_value;
  let t0;
  let div1;
  let t1;
  let t2;
  let t3;
  let div1_class_value;
  let t4;
  let t5;
  let div2_class_value;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[12].left && create_if_block_55(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    (ctx[12].title || /*$$slots*/
    ctx[12].subtitle || /*title*/
    ctx[2] || /*subtitle*/
    ctx[3]) && create_if_block_36(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[12].right && create_if_block_27(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[41].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    null
  );
  let if_block3 = (
    /*large*/
    (ctx[1] || /*medium*/
    ctx[0]) && create_if_block_112(ctx)
  );
  let if_block4 = (
    /*$$slots*/
    ctx[12].subnavbar && create_if_block16(ctx)
  );
  let div2_levels = [
    {
      class: div2_class_value = /*c*/
      ctx[10].base
    },
    /*$$restProps*/
    ctx[11]
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (default_slot)
        default_slot.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      t3 = claim_space(div1_nodes);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t4 = claim_space(div2_nodes);
      if (if_block3)
        if_block3.l(div2_nodes);
      t5 = claim_space(div2_nodes);
      if (if_block4)
        if_block4.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*c*/
      ctx[10].bg);
      add_location(div0, file33, 210, 2, 5406);
      attr_dev(div1, "class", div1_class_value = /*c*/
      ctx[10].inner);
      add_location(div1, file33, 211, 2, 5449);
      set_attributes(div2, div2_data);
      add_location(div2, file33, 209, 0, 5348);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      ctx[42](div0);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      append_hydration_dev(div1, t3);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[44](div1);
      append_hydration_dev(div2, t4);
      if (if_block3)
        if_block3.m(div2, null);
      append_hydration_dev(div2, t5);
      if (if_block4)
        if_block4.m(div2, null);
      ctx[47](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*c*/
      1024 && div0_class_value !== (div0_class_value = /*c*/
      ctx2[10].bg)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$$slots*/
        ctx2[12].left
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_55(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[12].title || /*$$slots*/
        ctx2[12].subtitle || /*title*/
        ctx2[2] || /*subtitle*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$$slots, title, subtitle*/
          4108) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_36(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[12].right
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          4096) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_27(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      1024 && div1_class_value !== (div1_class_value = /*c*/
      ctx2[10].inner)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (
        /*large*/
        ctx2[1] || /*medium*/
        ctx2[0]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*large, medium*/
          3) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_112(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[12].subnavbar
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          4096) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block16(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty[0] & /*c*/
        1024 && div2_class_value !== (div2_class_value = /*c*/
        ctx2[10].base)) && { class: div2_class_value },
        dirty[0] & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(default_slot, local);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(default_slot, local);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      ctx[42](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[44](null);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      ctx[47](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let isScrollable;
  let colors;
  let isOutline;
  let c;
  const omit_props_names = [
    "class",
    "bgClass",
    "innerClass",
    "leftClass",
    "titleClass",
    "subtitleClass",
    "rightClass",
    "subnavbarClass",
    "colors",
    "translucent",
    "outline",
    "centerTitle",
    "medium",
    "large",
    "transparent",
    "fontSizeIos",
    "fontSizeMaterial",
    "titleFontSizeIos",
    "titleFontSizeMaterial",
    "titleMediumFontSizeIos",
    "titleMediumFontSizeMaterial",
    "titleLargeFontSizeIos",
    "titleLargeFontSizeMaterial",
    "scrollEl",
    "title",
    "subtitle",
    "ios",
    "material"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Navbar", slots, ["left", "title", "subtitle", "right", "default", "subnavbar"]);
  const $$slots = compute_slots(slots);
  let { class: className = void 0 } = $$props;
  let { bgClass = "" } = $$props;
  let { innerClass = "" } = $$props;
  let { leftClass = "" } = $$props;
  let { titleClass = "" } = $$props;
  let { subtitleClass = "" } = $$props;
  let { rightClass = "" } = $$props;
  let { subnavbarClass = "" } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { translucent = true } = $$props;
  let { outline = void 0 } = $$props;
  let { centerTitle = void 0 } = $$props;
  let { medium = false } = $$props;
  let { large = false } = $$props;
  let { transparent = false } = $$props;
  let { fontSizeIos = "text-[17px]" } = $$props;
  let { fontSizeMaterial = "text-[16px]" } = $$props;
  let { titleFontSizeIos = "text-[17px]" } = $$props;
  let { titleFontSizeMaterial = "text-[22px]" } = $$props;
  let { titleMediumFontSizeIos = "text-[24px]" } = $$props;
  let { titleMediumFontSizeMaterial = "text-[24px]" } = $$props;
  let { titleLargeFontSizeIos = "text-[34px]" } = $$props;
  let { titleLargeFontSizeMaterial = "text-[28px]" } = $$props;
  let { scrollEl = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let elRef = 0;
  let titleContainerHeight = 0;
  let bgElRef = null;
  let innerElRef = null;
  let titleContainerElRef = null;
  let titleElRef = null;
  let subnavbarElRef = null;
  let wasScrollable = isScrollable;
  const dark = useDarkClasses();
  let theme;
  theme = useTheme((v) => $$invalidate(37, theme = v));
  const getScrollEl = () => {
    if (typeof scrollEl === "undefined") {
      return elRef && elRef.parentNode;
    }
    return scrollEl || scrollEl;
  };
  const onScroll = (e) => {
    if (!e) {
      e = { target: getScrollEl() };
    }
    const { scrollTop } = e.target;
    if (!isScrollable) {
      if (wasScrollable) {
        if (titleElRef) {
          $$invalidate(8, titleElRef.style.opacity = "", titleElRef);
        }
        if (bgElRef) {
          $$invalidate(5, bgElRef.style.opacity = "", bgElRef);
        }
      }
      return;
    }
    const maxTranslate = titleContainerHeight;
    const scrollProgress = Math.max(Math.min(scrollTop / maxTranslate, 1), 0);
    $$invalidate(5, bgElRef.style.opacity = transparent ? -0.5 + scrollProgress * 1.5 : "", bgElRef);
    if (medium || large) {
      $$invalidate(5, bgElRef.style.transform = `translateY(-${scrollProgress * maxTranslate}px)`, bgElRef);
    }
    if (titleContainerElRef) {
      $$invalidate(7, titleContainerElRef.style.transform = `translateY(-${scrollProgress * maxTranslate}px)`, titleContainerElRef);
      $$invalidate(7, titleContainerElRef.style.opacity = 1 - scrollProgress * 2, titleContainerElRef);
    }
    if (titleElRef) {
      $$invalidate(8, titleElRef.style.opacity = -0.5 + scrollProgress * 1.5, titleElRef);
    }
    if ((medium || large) && subnavbarElRef) {
      $$invalidate(9, subnavbarElRef.style.transform = `translateY(-${scrollProgress * maxTranslate}px)`, subnavbarElRef);
    }
  };
  const calcSize = () => {
    if (titleContainerElRef) {
      titleContainerHeight = titleContainerElRef.offsetHeight;
    } else {
      titleContainerHeight = innerElRef.offsetHeight;
    }
  };
  const initScroll = () => {
    if (!isScrollable) {
      if (wasScrollable) {
        onScroll({ target: { scrollTop: 0 } });
        wasScrollable = isScrollable;
      }
      return;
    }
    wasScrollable = isScrollable;
    const scrollElLocal = getScrollEl();
    if (scrollElLocal) {
      scrollElLocal.addEventListener("scroll", onScroll);
      onScroll({ target: scrollElLocal });
    } else {
      onScroll({ target: { scrollTop: 0 } });
    }
  };
  const destroyScroll = () => {
    const scrollElLocal = getScrollEl();
    if (scrollElLocal) {
      scrollElLocal.removeEventListener("scroll", onScroll);
    }
  };
  afterUpdate(() => {
    calcSize();
    if (!wasScrollable && isScrollable) {
      initScroll();
    } else if (wasScrollable && !isScrollable) {
      onScroll();
      wasScrollable = isScrollable;
      destroyScroll();
    } else if (wasScrollable && isScrollable) {
      onScroll();
    }
  });
  onMount(() => {
    calcSize();
    initScroll();
  });
  onDestroy(() => {
    destroyScroll();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      bgElRef = $$value;
      $$invalidate(5, bgElRef);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      titleElRef = $$value;
      $$invalidate(8, titleElRef);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerElRef = $$value;
      $$invalidate(6, innerElRef);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      titleContainerElRef = $$value;
      $$invalidate(7, titleContainerElRef);
    });
  }
  function div_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      subnavbarElRef = $$value;
      $$invalidate(9, subnavbarElRef);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elRef = $$value;
      $$invalidate(4, elRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(13, className = $$new_props.class);
    if ("bgClass" in $$new_props)
      $$invalidate(14, bgClass = $$new_props.bgClass);
    if ("innerClass" in $$new_props)
      $$invalidate(15, innerClass = $$new_props.innerClass);
    if ("leftClass" in $$new_props)
      $$invalidate(16, leftClass = $$new_props.leftClass);
    if ("titleClass" in $$new_props)
      $$invalidate(17, titleClass = $$new_props.titleClass);
    if ("subtitleClass" in $$new_props)
      $$invalidate(18, subtitleClass = $$new_props.subtitleClass);
    if ("rightClass" in $$new_props)
      $$invalidate(19, rightClass = $$new_props.rightClass);
    if ("subnavbarClass" in $$new_props)
      $$invalidate(20, subnavbarClass = $$new_props.subnavbarClass);
    if ("colors" in $$new_props)
      $$invalidate(21, colorsProp = $$new_props.colors);
    if ("translucent" in $$new_props)
      $$invalidate(22, translucent = $$new_props.translucent);
    if ("outline" in $$new_props)
      $$invalidate(23, outline = $$new_props.outline);
    if ("centerTitle" in $$new_props)
      $$invalidate(24, centerTitle = $$new_props.centerTitle);
    if ("medium" in $$new_props)
      $$invalidate(0, medium = $$new_props.medium);
    if ("large" in $$new_props)
      $$invalidate(1, large = $$new_props.large);
    if ("transparent" in $$new_props)
      $$invalidate(25, transparent = $$new_props.transparent);
    if ("fontSizeIos" in $$new_props)
      $$invalidate(26, fontSizeIos = $$new_props.fontSizeIos);
    if ("fontSizeMaterial" in $$new_props)
      $$invalidate(27, fontSizeMaterial = $$new_props.fontSizeMaterial);
    if ("titleFontSizeIos" in $$new_props)
      $$invalidate(28, titleFontSizeIos = $$new_props.titleFontSizeIos);
    if ("titleFontSizeMaterial" in $$new_props)
      $$invalidate(29, titleFontSizeMaterial = $$new_props.titleFontSizeMaterial);
    if ("titleMediumFontSizeIos" in $$new_props)
      $$invalidate(30, titleMediumFontSizeIos = $$new_props.titleMediumFontSizeIos);
    if ("titleMediumFontSizeMaterial" in $$new_props)
      $$invalidate(31, titleMediumFontSizeMaterial = $$new_props.titleMediumFontSizeMaterial);
    if ("titleLargeFontSizeIos" in $$new_props)
      $$invalidate(32, titleLargeFontSizeIos = $$new_props.titleLargeFontSizeIos);
    if ("titleLargeFontSizeMaterial" in $$new_props)
      $$invalidate(33, titleLargeFontSizeMaterial = $$new_props.titleLargeFontSizeMaterial);
    if ("scrollEl" in $$new_props)
      $$invalidate(34, scrollEl = $$new_props.scrollEl);
    if ("title" in $$new_props)
      $$invalidate(2, title = $$new_props.title);
    if ("subtitle" in $$new_props)
      $$invalidate(3, subtitle = $$new_props.subtitle);
    if ("ios" in $$new_props)
      $$invalidate(35, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(36, material = $$new_props.material);
    if ("$$scope" in $$new_props)
      $$invalidate(40, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    afterUpdate,
    useTheme,
    useThemeClasses,
    useDarkClasses,
    NavbarClasses,
    NavbarColors,
    className,
    bgClass,
    innerClass,
    leftClass,
    titleClass,
    subtitleClass,
    rightClass,
    subnavbarClass,
    colorsProp,
    translucent,
    outline,
    centerTitle,
    medium,
    large,
    transparent,
    fontSizeIos,
    fontSizeMaterial,
    titleFontSizeIos,
    titleFontSizeMaterial,
    titleMediumFontSizeIos,
    titleMediumFontSizeMaterial,
    titleLargeFontSizeIos,
    titleLargeFontSizeMaterial,
    scrollEl,
    title,
    subtitle,
    ios,
    material,
    elRef,
    titleContainerHeight,
    bgElRef,
    innerElRef,
    titleContainerElRef,
    titleElRef,
    subnavbarElRef,
    wasScrollable,
    dark,
    theme,
    getScrollEl,
    onScroll,
    calcSize,
    initScroll,
    destroyScroll,
    isScrollable,
    c,
    colors,
    isOutline
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(13, className = $$new_props.className);
    if ("bgClass" in $$props)
      $$invalidate(14, bgClass = $$new_props.bgClass);
    if ("innerClass" in $$props)
      $$invalidate(15, innerClass = $$new_props.innerClass);
    if ("leftClass" in $$props)
      $$invalidate(16, leftClass = $$new_props.leftClass);
    if ("titleClass" in $$props)
      $$invalidate(17, titleClass = $$new_props.titleClass);
    if ("subtitleClass" in $$props)
      $$invalidate(18, subtitleClass = $$new_props.subtitleClass);
    if ("rightClass" in $$props)
      $$invalidate(19, rightClass = $$new_props.rightClass);
    if ("subnavbarClass" in $$props)
      $$invalidate(20, subnavbarClass = $$new_props.subnavbarClass);
    if ("colorsProp" in $$props)
      $$invalidate(21, colorsProp = $$new_props.colorsProp);
    if ("translucent" in $$props)
      $$invalidate(22, translucent = $$new_props.translucent);
    if ("outline" in $$props)
      $$invalidate(23, outline = $$new_props.outline);
    if ("centerTitle" in $$props)
      $$invalidate(24, centerTitle = $$new_props.centerTitle);
    if ("medium" in $$props)
      $$invalidate(0, medium = $$new_props.medium);
    if ("large" in $$props)
      $$invalidate(1, large = $$new_props.large);
    if ("transparent" in $$props)
      $$invalidate(25, transparent = $$new_props.transparent);
    if ("fontSizeIos" in $$props)
      $$invalidate(26, fontSizeIos = $$new_props.fontSizeIos);
    if ("fontSizeMaterial" in $$props)
      $$invalidate(27, fontSizeMaterial = $$new_props.fontSizeMaterial);
    if ("titleFontSizeIos" in $$props)
      $$invalidate(28, titleFontSizeIos = $$new_props.titleFontSizeIos);
    if ("titleFontSizeMaterial" in $$props)
      $$invalidate(29, titleFontSizeMaterial = $$new_props.titleFontSizeMaterial);
    if ("titleMediumFontSizeIos" in $$props)
      $$invalidate(30, titleMediumFontSizeIos = $$new_props.titleMediumFontSizeIos);
    if ("titleMediumFontSizeMaterial" in $$props)
      $$invalidate(31, titleMediumFontSizeMaterial = $$new_props.titleMediumFontSizeMaterial);
    if ("titleLargeFontSizeIos" in $$props)
      $$invalidate(32, titleLargeFontSizeIos = $$new_props.titleLargeFontSizeIos);
    if ("titleLargeFontSizeMaterial" in $$props)
      $$invalidate(33, titleLargeFontSizeMaterial = $$new_props.titleLargeFontSizeMaterial);
    if ("scrollEl" in $$props)
      $$invalidate(34, scrollEl = $$new_props.scrollEl);
    if ("title" in $$props)
      $$invalidate(2, title = $$new_props.title);
    if ("subtitle" in $$props)
      $$invalidate(3, subtitle = $$new_props.subtitle);
    if ("ios" in $$props)
      $$invalidate(35, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(36, material = $$new_props.material);
    if ("elRef" in $$props)
      $$invalidate(4, elRef = $$new_props.elRef);
    if ("titleContainerHeight" in $$props)
      titleContainerHeight = $$new_props.titleContainerHeight;
    if ("bgElRef" in $$props)
      $$invalidate(5, bgElRef = $$new_props.bgElRef);
    if ("innerElRef" in $$props)
      $$invalidate(6, innerElRef = $$new_props.innerElRef);
    if ("titleContainerElRef" in $$props)
      $$invalidate(7, titleContainerElRef = $$new_props.titleContainerElRef);
    if ("titleElRef" in $$props)
      $$invalidate(8, titleElRef = $$new_props.titleElRef);
    if ("subnavbarElRef" in $$props)
      $$invalidate(9, subnavbarElRef = $$new_props.subnavbarElRef);
    if ("wasScrollable" in $$props)
      wasScrollable = $$new_props.wasScrollable;
    if ("theme" in $$props)
      $$invalidate(37, theme = $$new_props.theme);
    if ("isScrollable" in $$props)
      isScrollable = $$new_props.isScrollable;
    if ("c" in $$props)
      $$invalidate(10, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(38, colors = $$new_props.colors);
    if ("isOutline" in $$props)
      $$invalidate(39, isOutline = $$new_props.isOutline);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*medium, large, transparent*/
    33554435) {
      $:
        isScrollable = medium || large || transparent;
    }
    if ($$self.$$.dirty[0] & /*colorsProp*/
    2097152) {
      $:
        $$invalidate(38, colors = NavbarColors(colorsProp, dark));
    }
    if ($$self.$$.dirty[0] & /*outline*/
    8388608 | $$self.$$.dirty[1] & /*theme*/
    64) {
      $:
        $$invalidate(39, isOutline = typeof outline === "undefined" ? theme === "ios" : outline);
    }
    if ($$self.$$.dirty[0] & /*bgClass, innerClass, leftClass, titleClass, subtitleClass, rightClass, subnavbarClass, translucent, transparent, fontSizeIos, fontSizeMaterial, titleFontSizeIos, titleFontSizeMaterial, medium, large, titleMediumFontSizeIos, centerTitle, className*/
    2136989699 | $$self.$$.dirty[1] & /*ios, material, isOutline, titleMediumFontSizeMaterial, titleLargeFontSizeIos, titleLargeFontSizeMaterial, theme, colors*/
    503) {
      $:
        $$invalidate(10, c = useThemeClasses(
          { ios, material },
          NavbarClasses(
            {
              bgClass,
              innerClass,
              leftClass,
              titleClass,
              subtitleClass,
              rightClass,
              subnavbarClass,
              translucent,
              transparent,
              outline: isOutline,
              fontSizeIos,
              fontSizeMaterial,
              titleFontSizeIos,
              titleFontSizeMaterial,
              medium,
              large,
              titleMediumFontSizeIos,
              titleMediumFontSizeMaterial,
              titleLargeFontSizeIos,
              titleLargeFontSizeMaterial,
              centerTitle: typeof centerTitle === "undefined" ? theme === "ios" : centerTitle
            },
            colors,
            className
          ),
          className,
          (v) => $$invalidate(10, c = v)
        ));
    }
  };
  return [
    medium,
    large,
    title,
    subtitle,
    elRef,
    bgElRef,
    innerElRef,
    titleContainerElRef,
    titleElRef,
    subnavbarElRef,
    c,
    $$restProps,
    $$slots,
    className,
    bgClass,
    innerClass,
    leftClass,
    titleClass,
    subtitleClass,
    rightClass,
    subnavbarClass,
    colorsProp,
    translucent,
    outline,
    centerTitle,
    transparent,
    fontSizeIos,
    fontSizeMaterial,
    titleFontSizeIos,
    titleFontSizeMaterial,
    titleMediumFontSizeIos,
    titleMediumFontSizeMaterial,
    titleLargeFontSizeIos,
    titleLargeFontSizeMaterial,
    scrollEl,
    ios,
    material,
    theme,
    colors,
    isOutline,
    $$scope,
    slots,
    div0_binding,
    div_binding,
    div1_binding,
    div_binding_1,
    div_binding_2,
    div2_binding
  ];
}
var Navbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance36,
      create_fragment36,
      safe_not_equal,
      {
        class: 13,
        bgClass: 14,
        innerClass: 15,
        leftClass: 16,
        titleClass: 17,
        subtitleClass: 18,
        rightClass: 19,
        subnavbarClass: 20,
        colors: 21,
        translucent: 22,
        outline: 23,
        centerTitle: 24,
        medium: 0,
        large: 1,
        transparent: 25,
        fontSizeIos: 26,
        fontSizeMaterial: 27,
        titleFontSizeIos: 28,
        titleFontSizeMaterial: 29,
        titleMediumFontSizeIos: 30,
        titleMediumFontSizeMaterial: 31,
        titleLargeFontSizeIos: 32,
        titleLargeFontSizeMaterial: 33,
        scrollEl: 34,
        title: 2,
        subtitle: 3,
        ios: 35,
        material: 36
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navbar",
      options,
      id: create_fragment36.name
    });
  }
  get class() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leftClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leftClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitleClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitleClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rightClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rightClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subnavbarClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subnavbarClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translucent() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translucent(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get centerTitle() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set centerTitle(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get medium() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set medium(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get large() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transparent() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transparent(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSizeIos() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSizeIos(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSizeMaterial() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSizeMaterial(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontSizeIos() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontSizeIos(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontSizeMaterial() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontSizeMaterial(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleMediumFontSizeIos() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleMediumFontSizeIos(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleMediumFontSizeMaterial() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleMediumFontSizeMaterial(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleLargeFontSizeIos() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleLargeFontSizeIos(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleLargeFontSizeMaterial() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleLargeFontSizeMaterial(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollEl() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollEl(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Navbar_default = Navbar;

// node_modules/konsta/svelte/components/icons/BackIcon.svelte
var file34 = "node_modules/konsta/svelte/components/icons/BackIcon.svelte";
function create_if_block_113(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "12" },
    { height: "20" },
    { viewBox: "0 0 12 20" },
    { fill: "currentcolor" },
    /*$$restProps*/
    ctx[1]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M0.18261596,9.4221638 C0.21783626,9.37068075 0.25835058,9.32165682 0.30416276,9.27584463 L9.1425872,0.4374202 C9.7256776,-0.14567018 10.6691555,-0.1475686 11.2590259,0.44230183 C11.8448123,1.02808827 11.8502479,1.97240019 11.2639075,2.55874056 L3.82594417,9.9967039 L11.2578297,17.4285894 C11.8409201,18.0116798 11.8428185,18.9551577 11.252948,19.5450281 C10.6671616,20.1308146 9.7228497,20.1362501 9.13650932,19.5499097 L0.2980849,10.7114853 C-0.0545897,10.3588107 -0.0959125,9.8144953 0.18261596,9.4221638 Z");
      add_location(path, file34, 13, 4, 216);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file34, 5, 2, 64);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "12" },
        { height: "20" },
        { viewBox: "0 0 12 20" },
        { fill: "currentcolor" },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(5:0) {#if theme === 'ios'}",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let svg;
  let polygon;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "16" },
    { height: "16" },
    { viewBox: "0 0 16 16" },
    { fill: "currentcolor" },
    /*$$restProps*/
    ctx[1]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "16 7 3.83 7 9.42 1.41 8 0 0 8 8 16 9.41 14.59 3.83 9 16 9");
      add_location(polygon, file34, 27, 4, 945);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file34, 19, 2, 793);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "16" },
        { height: "16" },
        { viewBox: "0 0 16 16" },
        { fill: "currentcolor" },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(19:0) {#if theme === 'material'}",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = (
    /*theme*/
    ctx[0] === "ios" && create_if_block_113(ctx)
  );
  let if_block1 = (
    /*theme*/
    ctx[0] === "material" && create_if_block17(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*theme*/
        ctx2[0] === "ios"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_113(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*theme*/
        ctx2[0] === "material"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block17(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  const omit_props_names = ["theme"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BackIcon", slots, []);
  let { theme } = $$props;
  $$self.$$.on_mount.push(function() {
    if (theme === void 0 && !("theme" in $$props || $$self.$$.bound[$$self.$$.props["theme"]])) {
      console.warn("<BackIcon> was created without expected prop 'theme'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("theme" in $$new_props)
      $$invalidate(0, theme = $$new_props.theme);
  };
  $$self.$capture_state = () => ({ theme });
  $$self.$inject_state = ($$new_props) => {
    if ("theme" in $$props)
      $$invalidate(0, theme = $$new_props.theme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [theme, $$restProps];
}
var BackIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { theme: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BackIcon",
      options,
      id: create_fragment37.name
    });
  }
  get theme() {
    throw new Error("<BackIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<BackIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BackIcon_default = BackIcon;

// node_modules/konsta/shared/esm/classes/NavbarBackLinkClasses.js
var NavbarBackLinkClasses = () => {
  return {
    base: {
      common: "cursor-pointer",
      material: "min-w-12 k-touch-ripple-inset"
    },
    icon: ""
  };
};

// node_modules/konsta/svelte/components/NavbarBackLink.svelte
var file35 = "node_modules/konsta/svelte/components/NavbarBackLink.svelte";
function create_if_block18(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*text*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file35, 36, 4, 1008);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data_dev(
          t,
          /*text*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(36:2) {#if shouldShowText}",
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let span;
  let backicon;
  let span_class_value;
  let t0;
  let t1;
  let current;
  backicon = new BackIcon_default({
    props: { theme: (
      /*theme*/
      ctx[3]
    ) },
    $$inline: true
  });
  let if_block = (
    /*shouldShowText*/
    ctx[5] && create_if_block18(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      create_component(backicon.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(backicon.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      t1 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[4].icon);
      add_location(span, file35, 32, 2, 924);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(backicon, span, null);
      insert_hydration_dev(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const backicon_changes = {};
      if (dirty & /*theme*/
      8)
        backicon_changes.theme = /*theme*/
        ctx2[3];
      backicon.$set(backicon_changes);
      if (!current || dirty & /*c*/
      16 && span_class_value !== (span_class_value = /*c*/
      ctx2[4].icon)) {
        attr_dev(span, "class", span_class_value);
      }
      if (
        /*shouldShowText*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(backicon.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(backicon.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      destroy_component(backicon);
      if (detaching)
        detach_dev(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(32:0) <Link class={c.base} navbar {component} {...$$restProps} {onClick}>",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let link;
  let current;
  const link_spread_levels = [
    { class: (
      /*c*/
      ctx[4].base
    ) },
    { navbar: true },
    { component: (
      /*component*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[6],
    { onClick: (
      /*onClick*/
      ctx[2]
    ) }
  ];
  let link_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < link_spread_levels.length; i += 1) {
    link_props = assign(link_props, link_spread_levels[i]);
  }
  link = new Link_default({ props: link_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(link.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const link_changes = dirty & /*c, component, $$restProps, onClick*/
      85 ? get_spread_update(link_spread_levels, [
        dirty & /*c*/
        16 && { class: (
          /*c*/
          ctx2[4].base
        ) },
        link_spread_levels[1],
        dirty & /*component*/
        1 && { component: (
          /*component*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        ),
        dirty & /*onClick*/
        4 && { onClick: (
          /*onClick*/
          ctx2[2]
        ) }
      ]) : {};
      if (dirty & /*$$scope, text, shouldShowText, c, theme*/
      4154) {
        link_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let shouldShowText;
  let c;
  const omit_props_names = ["class", "ios", "material", "component", "text", "showText", "onClick"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavbarBackLink", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "a" } = $$props;
  let { text: text2 = "Back" } = $$props;
  let { showText = "auto" } = $$props;
  let { onClick = void 0 } = $$props;
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(3, theme = v));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("ios" in $$new_props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(9, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(0, component = $$new_props.component);
    if ("text" in $$new_props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("showText" in $$new_props)
      $$invalidate(10, showText = $$new_props.showText);
    if ("onClick" in $$new_props)
      $$invalidate(2, onClick = $$new_props.onClick);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useTheme,
    useThemeClasses,
    BackIcon: BackIcon_default,
    Link: Link_default,
    NavbarBackLinkClasses,
    className,
    ios,
    material,
    component,
    text: text2,
    showText,
    onClick,
    theme,
    c,
    shouldShowText
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("ios" in $$props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(9, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(0, component = $$new_props.component);
    if ("text" in $$props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("showText" in $$props)
      $$invalidate(10, showText = $$new_props.showText);
    if ("onClick" in $$props)
      $$invalidate(2, onClick = $$new_props.onClick);
    if ("theme" in $$props)
      $$invalidate(3, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(4, c = $$new_props.c);
    if ("shouldShowText" in $$props)
      $$invalidate(5, shouldShowText = $$new_props.shouldShowText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*showText, theme*/
    1032) {
      $:
        $$invalidate(5, shouldShowText = showText === "auto" && theme === "ios" || showText === true);
    }
    if ($$self.$$.dirty & /*ios, material, className*/
    896) {
      $:
        $$invalidate(4, c = useThemeClasses({ ios, material }, NavbarBackLinkClasses(), className, (v) => $$invalidate(4, c = v)));
    }
  };
  return [
    component,
    text2,
    onClick,
    theme,
    c,
    shouldShowText,
    $$restProps,
    className,
    ios,
    material,
    showText,
    slots,
    $$scope
  ];
}
var NavbarBackLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      class: 7,
      ios: 8,
      material: 9,
      component: 0,
      text: 1,
      showText: 10,
      onClick: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavbarBackLink",
      options,
      id: create_fragment38.name
    });
  }
  get class() {
    throw new Error("<NavbarBackLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavbarBackLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<NavbarBackLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<NavbarBackLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<NavbarBackLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<NavbarBackLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<NavbarBackLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<NavbarBackLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<NavbarBackLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<NavbarBackLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showText() {
    throw new Error("<NavbarBackLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showText(value) {
    throw new Error("<NavbarBackLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<NavbarBackLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<NavbarBackLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavbarBackLink_default = NavbarBackLink;

// node_modules/konsta/shared/esm/classes/PageClasses.js
var PageClasses = (props, colors, classes) => {
  return {
    base: {
      common: cls("h-full w-full left-0 top-0 overflow-auto", positionClass("absolute", classes)),
      ios: colors.bgIos,
      material: colors.bgMaterial
    }
  };
};

// node_modules/konsta/shared/esm/colors/PageColors.js
var PageColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: cls("bg-ios-light-surface", dark("dark:bg-ios-dark-surface")),
    bgMaterial: cls("bg-md-light-surface", dark("dark:bg-md-dark-surface")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Page.svelte
var file36 = "node_modules/konsta/svelte/components/Page.svelte";
function create_dynamic_element10(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*c*/
      ctx[1].base
    },
    /*$$restProps*/
    ctx[2]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[0]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[0] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file36, 29, 0, 733);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*c*/
        2 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx2[1].base)) && { class: svelte_element_class_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]);
      if (/-/.test(
        /*component*/
        ctx2[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element10.name,
    type: "child_dynamic_element",
    source: "(30:0) <svelte:element this={component} class={c.base} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let previous_tag = (
    /*component*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[0]
  );
  let svelte_element = (
    /*component*/
    ctx[0] && create_dynamic_element10(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*component*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element10(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element10(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[0];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let colors;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "component"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Page", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "div" } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(4, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(5, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(6, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(0, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PageClasses,
    PageColors,
    useDarkClasses,
    useThemeClasses,
    className,
    colorsProp,
    ios,
    material,
    component,
    dark,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(4, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(5, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(6, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(0, component = $$new_props.component);
    if ("c" in $$props)
      $$invalidate(1, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(7, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    16) {
      $:
        $$invalidate(7, colors = PageColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    232) {
      $:
        $$invalidate(1, c = useThemeClasses({ ios, material }, PageClasses({}, colors, className), className, (v) => $$invalidate(1, c = v)));
    }
  };
  return [
    component,
    c,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    colors,
    $$scope,
    slots
  ];
}
var Page = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {
      class: 3,
      colors: 4,
      ios: 5,
      material: 6,
      component: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Page",
      options,
      id: create_fragment39.name
    });
  }
  get class() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Page_default = Page;

// node_modules/konsta/shared/esm/classes/PanelClasses.js
var PanelClasses = (props, colors, classes) => {
  const {
    size,
    floating
  } = props;
  return {
    base: {
      common: cls("transition-transform transform duration-400 z-40 max-w-full overflow-hidden", floating ? "top-2-safe bottom-2-safe h-auto" : "top-0 max-h-full", colors.bg, positionClass("fixed", classes), size),
      ios: "",
      material: "ease-material-in"
    },
    left: {
      common: cls("no-safe-areas-right", floating ? "right-full -mr-2 rounded-2xl" : "right-full"),
      material: cls(!floating && "rounded-r-2xl"),
      opened: "translate-x-full",
      closed: "-translate-x-2"
    },
    right: {
      common: cls("no-safe-areas-left", floating ? "left-full -ml-2 rounded-2xl" : "left-full"),
      material: cls(!floating && "rounded-l-2xl"),
      opened: "-translate-x-full",
      closed: "translate-x-2"
    },
    backdrop: {
      common: "fixed z-40 w-full h-full left-0 top-0 bg-black bg-opacity-50 duration-400",
      opened: "",
      closed: "opacity-0 pointer-events-none"
    }
  };
};

// node_modules/konsta/shared/esm/colors/PanelColors.js
var PanelColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bg: cls("bg-white", dark("dark:bg-black")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Panel.svelte
var file37 = "node_modules/konsta/svelte/components/Panel.svelte";
function create_if_block19(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[3].backdrop[
        /*state*/
        ctx[2]
      ]);
      add_location(div, file37, 38, 2, 1073);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onBackdropClick*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*c, state*/
      12 && div_class_value !== (div_class_value = /*c*/
      ctx[3].backdrop[
        /*state*/
        ctx[2]
      ])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(38:0) {#if backdrop}",
    ctx
  });
  return block;
}
function create_fragment40(ctx) {
  let t;
  let div;
  let current;
  let if_block = (
    /*backdrop*/
    ctx[0] && create_if_block19(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file37, 40, 0, 1140);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*backdrop*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let state;
  let colors;
  let c;
  let classes;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "size",
    "side",
    "opened",
    "backdrop",
    "floating",
    "onBackdropClick"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Panel", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { size = "w-72 h-screen" } = $$props;
  let { side = "left" } = $$props;
  let { opened = false } = $$props;
  let { backdrop = true } = $$props;
  let { floating = false } = $$props;
  let { onBackdropClick = void 0 } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(7, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(9, material = $$new_props.material);
    if ("size" in $$new_props)
      $$invalidate(10, size = $$new_props.size);
    if ("side" in $$new_props)
      $$invalidate(11, side = $$new_props.side);
    if ("opened" in $$new_props)
      $$invalidate(12, opened = $$new_props.opened);
    if ("backdrop" in $$new_props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("floating" in $$new_props)
      $$invalidate(13, floating = $$new_props.floating);
    if ("onBackdropClick" in $$new_props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cls,
    PanelClasses,
    PanelColors,
    useDarkClasses,
    useThemeClasses,
    className,
    colorsProp,
    ios,
    material,
    size,
    side,
    opened,
    backdrop,
    floating,
    onBackdropClick,
    dark,
    state,
    c,
    classes,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(7, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(9, material = $$new_props.material);
    if ("size" in $$props)
      $$invalidate(10, size = $$new_props.size);
    if ("side" in $$props)
      $$invalidate(11, side = $$new_props.side);
    if ("opened" in $$props)
      $$invalidate(12, opened = $$new_props.opened);
    if ("backdrop" in $$props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("floating" in $$props)
      $$invalidate(13, floating = $$new_props.floating);
    if ("onBackdropClick" in $$props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("state" in $$props)
      $$invalidate(2, state = $$new_props.state);
    if ("c" in $$props)
      $$invalidate(3, c = $$new_props.c);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("colors" in $$props)
      $$invalidate(14, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*opened*/
    4096) {
      $:
        $$invalidate(2, state = opened ? "opened" : "closed");
    }
    if ($$self.$$.dirty & /*colorsProp*/
    128) {
      $:
        $$invalidate(14, colors = PanelColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, size, floating, colors, className*/
    26432) {
      $:
        $$invalidate(3, c = useThemeClasses({ ios, material }, PanelClasses({ size, floating }, colors, className), className, (v) => $$invalidate(3, c = v)));
    }
    if ($$self.$$.dirty & /*c, side, state*/
    2060) {
      $:
        $$invalidate(4, classes = cls(c.base, c[side][state]));
    }
  };
  return [
    backdrop,
    onBackdropClick,
    state,
    c,
    classes,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    size,
    side,
    opened,
    floating,
    colors,
    $$scope,
    slots
  ];
}
var Panel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {
      class: 6,
      colors: 7,
      ios: 8,
      material: 9,
      size: 10,
      side: 11,
      opened: 12,
      backdrop: 0,
      floating: 13,
      onBackdropClick: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Panel",
      options,
      id: create_fragment40.name
    });
  }
  get class() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get side() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set side(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floating() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floating(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBackdropClick() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBackdropClick(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Panel_default = Panel;

// node_modules/konsta/shared/esm/calc-popover-position.js
var calcPopoverPosition = (_ref) => {
  let {
    popoverEl,
    targetEl,
    angleEl,
    needsAngle,
    targetX,
    targetY,
    targetWidth = 0,
    targetHeight = 0,
    theme
  } = _ref;
  if (targetEl.current) {
    targetEl = targetEl.current;
  } else if (targetEl.value) {
    targetEl = targetEl.value;
  } else if (targetEl.el) {
    targetEl = targetEl.el;
  } else if (targetEl.$el) {
    targetEl = targetEl.$el;
  }
  if (typeof targetEl === "string") {
    targetEl = document.querySelector(targetEl);
  }
  let appWidth = document.body.offsetWidth;
  let appHeight = document.body.offsetHeight;
  if (appWidth === 0) {
    appWidth = window.innerWidth;
  }
  if (appHeight === 0) {
    appHeight = window.innerHeight;
  }
  const [popoverWidth, popoverHeight] = [popoverEl.offsetWidth, popoverEl.offsetHeight];
  let angleSize = 0;
  let angleLeft;
  let angleTop;
  let anglePosition = "";
  if (needsAngle) {
    angleSize = angleEl.offsetWidth / 2;
  }
  let targetOffsetLeft;
  let targetOffsetTop;
  const targetElStyles = window.getComputedStyle(targetEl);
  let safeAreaTop = parseInt(targetElStyles.getPropertyValue("--k-safe-area-top"), 10) || 0;
  let safeAreaLeft = parseInt(targetElStyles.getPropertyValue("--k-safe-area-left"), 10) || 0;
  let safeAreaRight = parseInt(targetElStyles.getPropertyValue("--k-safe-area-right"), 10) || 0;
  if (Number.isNaN(safeAreaTop))
    safeAreaTop = 0;
  if (Number.isNaN(safeAreaLeft))
    safeAreaLeft = 0;
  if (Number.isNaN(safeAreaRight))
    safeAreaRight = 0;
  if (targetEl) {
    targetWidth = targetEl.offsetWidth;
    targetHeight = targetEl.offsetHeight;
    const targetElBox = targetEl.getBoundingClientRect();
    targetOffsetLeft = targetElBox.left;
    targetOffsetTop = targetElBox.top;
  } else if (typeof targetX !== "undefined" && targetY !== "undefined") {
    targetOffsetLeft = targetX;
    targetOffsetTop = targetY;
  }
  let [left, top, diff] = [0, 0, 0];
  const angleMin = theme === "ios" ? 13 : 23;
  let position = "top";
  if (popoverHeight + angleSize < targetOffsetTop - safeAreaTop) {
    top = targetOffsetTop - popoverHeight - angleSize;
  } else if (popoverHeight + angleSize < appHeight - targetOffsetTop - targetHeight) {
    position = "bottom";
    top = targetOffsetTop + targetHeight + angleSize;
  } else {
    position = "middle";
    top = targetHeight / 2 + targetOffsetTop - popoverHeight / 2;
    diff = top;
    top = Math.max(5, Math.min(top, appHeight - popoverHeight - 5));
    diff -= top;
  }
  if (position === "top" || position === "bottom") {
    left = targetWidth / 2 + targetOffsetLeft - popoverWidth / 2;
    diff = left;
    left = Math.max(5, Math.min(left, appWidth - popoverWidth - 5));
    if (safeAreaLeft) {
      left = Math.max(left, safeAreaLeft);
    }
    if (safeAreaRight && left + popoverWidth > appWidth - 5 - safeAreaRight) {
      left = appWidth - 5 - safeAreaRight - popoverWidth;
    }
    if (position === "top") {
      anglePosition = "bottom";
    }
    if (position === "bottom") {
      anglePosition = "top";
    }
    diff -= left;
    angleLeft = popoverWidth / 2 - angleSize + diff;
    angleLeft = Math.max(Math.min(angleLeft, popoverWidth - angleSize * 2 - angleMin), angleMin);
  } else if (position === "middle") {
    left = targetOffsetLeft - popoverWidth - angleSize;
    anglePosition = "right";
    if (left < 5 || left + popoverWidth + safeAreaRight > appWidth || left < safeAreaLeft) {
      if (left < 5)
        left = targetOffsetLeft + targetWidth + angleSize;
      if (left + popoverWidth + safeAreaRight > appWidth)
        left = appWidth - popoverWidth - 5 - safeAreaRight;
      if (left < safeAreaLeft)
        left = safeAreaLeft;
      anglePosition = "left";
    }
    angleTop = popoverHeight / 2 - angleSize + diff;
    angleTop = Math.max(Math.min(angleTop, popoverHeight - angleSize * 2 - angleMin), angleMin);
  }
  const popoverVerticalPosition = position;
  const popoverHorizontalPosition = left < targetOffsetLeft ? "left" : "right";
  return {
    set: true,
    angleTop: typeof angleTop === "undefined" ? void 0 : `${angleTop}px`,
    angleLeft: typeof angleLeft === "undefined" ? void 0 : `${angleLeft}px`,
    anglePosition,
    popoverTop: `${top}px`,
    popoverLeft: `${left}px`,
    popoverPosition: `${popoverVerticalPosition}-${popoverHorizontalPosition}`
  };
};

// node_modules/konsta/shared/esm/classes/PopoverClasses.js
var PopoverClasses = (props, colors, classes) => {
  const {
    size,
    translucent,
    angleClassName,
    angleClass
  } = props;
  return {
    base: {
      common: cls("transition-transform-opacity z-40 no-safe-areas", positionClass("fixed", classes), size),
      ios: "duration-300",
      material: "duration-400 ease-material-in",
      opened: "",
      closed: {
        common: "opacity-0 pointer-events-none",
        ios: "",
        material: "scale-x-90 scale-y-75"
      }
    },
    inner: {
      common: cls("overflow-hidden relative"),
      ios: cls("rounded-xl", translucent && "translucent", colors.bgIos),
      material: cls("rounded-[1.75rem]", colors.bgMaterial)
    },
    angleWrap: {
      common: cls(angleClassName || angleClass || "", "pointer-events-none"),
      ios: cls("absolute w-6.5 h-6.5 z-50 overflow-hidden", translucent && "opacity-80"),
      material: cls("absolute w-6.5 h-6.5 z-50 overflow-hidden"),
      bottom: "top-full",
      top: "bottom-full",
      left: "right-full",
      right: "left-full"
    },
    angleArrow: {
      common: cls("absolute rounded w-full h-full transform rotate-45"),
      ios: colors.bgIos,
      material: colors.bgMaterial,
      bottom: "-top-4.75",
      top: "top-4.75",
      left: "left-4.75",
      right: "-left-4.75"
    },
    backdrop: {
      common: "fixed z-40 w-full h-full left-0 top-0 bg-black bg-opacity-50 duration-300",
      opened: "",
      closed: "opacity-0 pointer-events-none"
    }
  };
};

// node_modules/konsta/shared/esm/colors/PopoverColors.js
var PopoverColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: cls("bg-ios-light-surface-3", dark("dark:bg-ios-dark-surface-3")),
    bgMaterial: cls("bg-md-light-surface-3", dark("dark:bg-md-dark-surface-3")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Popover.svelte
var file38 = "node_modules/konsta/svelte/components/Popover.svelte";
function create_if_block_114(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[5].backdrop[
        /*state*/
        ctx[4]
      ]);
      add_location(div, file38, 129, 2, 3221);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onBackdropClick*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*c, state*/
      48 && div_class_value !== (div_class_value = /*c*/
      ctx[5].backdrop[
        /*state*/
        ctx[4]
      ])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(129:0) {#if backdrop}",
    ctx
  });
  return block;
}
function create_if_block20(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { style: true, class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*c*/
      ctx[5].angleArrow[
        /*positions*/
        ctx[3].anglePosition
      ]);
      add_location(div0, file38, 138, 6, 3500);
      attr_dev(
        div1,
        "style",
        /*angleStyle*/
        ctx[9]
      );
      attr_dev(div1, "class", div1_class_value = /*c*/
      ctx[5].angleWrap[
        /*positions*/
        ctx[3].anglePosition
      ]);
      add_location(div1, file38, 133, 4, 3381);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      ctx[30](div1);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*c, positions*/
      40 && div0_class_value !== (div0_class_value = /*c*/
      ctx2[5].angleArrow[
        /*positions*/
        ctx2[3].anglePosition
      ])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty[0] & /*angleStyle*/
      512) {
        attr_dev(
          div1,
          "style",
          /*angleStyle*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*c, positions*/
      40 && div1_class_value !== (div1_class_value = /*c*/
      ctx2[5].angleWrap[
        /*positions*/
        ctx2[3].anglePosition
      ])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      ctx[30](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(133:2) {#if angle}",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let t0;
  let div1;
  let t1;
  let div0;
  let div0_class_value;
  let current;
  let if_block0 = (
    /*backdrop*/
    ctx[1] && create_if_block_114(ctx)
  );
  let if_block1 = (
    /*angle*/
    ctx[0] && create_if_block20(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  let div1_levels = [
    { class: (
      /*classes*/
      ctx[8]
    ) },
    { style: (
      /*popoverStyle*/
      ctx[10]
    ) },
    /*$$restProps*/
    ctx[11]
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (if_block1)
        if_block1.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*c*/
      ctx[5].inner);
      add_location(div0, file38, 141, 2, 3575);
      set_attributes(div1, div1_data);
      add_location(div1, file38, 131, 0, 3288);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div1, anchor);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[31](div1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*backdrop*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_114(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*angle*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block20(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*c*/
      32 && div0_class_value !== (div0_class_value = /*c*/
      ctx2[5].inner)) {
        attr_dev(div0, "class", div0_class_value);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*classes*/
        256) && { class: (
          /*classes*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*popoverStyle*/
        1024) && { style: (
          /*popoverStyle*/
          ctx2[10]
        ) },
        dirty[0] & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div1);
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[31](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let state;
  let colors;
  let c;
  let popoverStyle;
  let angleStyle;
  let classes;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "style",
    "angle",
    "angleClass",
    "size",
    "opened",
    "backdrop",
    "onBackdropClick",
    "target",
    "targetX",
    "targetY",
    "targetWidth",
    "targetHeight",
    "translucent"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { style = "" } = $$props;
  let { angle = true } = $$props;
  let { angleClass = "" } = $$props;
  let { size = "w-64" } = $$props;
  let { opened = false } = $$props;
  let { backdrop = true } = $$props;
  let { onBackdropClick = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { targetX = void 0 } = $$props;
  let { targetY = void 0 } = $$props;
  let { targetWidth = void 0 } = $$props;
  let { targetHeight = void 0 } = $$props;
  let { translucent = true } = $$props;
  let el;
  let angleEl;
  let positions = {
    set: false,
    angleTop: 0,
    angleLeft: 0,
    anglePosition: "bottom",
    popoverTop: 0,
    popoverLeft: 0,
    popoverPosition: "top-left"
  };
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(26, theme = v));
  const dark = useDarkClasses();
  const setPopover = () => {
    if (!target || !el || !opened)
      return;
    $$invalidate(3, positions = calcPopoverPosition({
      popoverEl: el,
      targetEl: target,
      angleEl,
      needsAngle: angle,
      targetX,
      targetY,
      targetWidth,
      targetHeight,
      theme
    }));
  };
  const attachEvents = () => {
    if (typeof window === "undefined")
      return;
    window.addEventListener("resize", setPopover);
  };
  const detachEvents = () => {
    if (typeof window === "undefined")
      return;
    window.removeEventListener("resize", setPopover);
  };
  onMount(() => {
    attachEvents();
  });
  onDestroy(() => {
    detachEvents();
  });
  function watchOpened(openedPassed) {
    setPopover();
  }
  const originClasses = {
    "top-right": "origin-bottom-left",
    "top-left": "origin-bottom-right",
    "middle-left": "origin-right",
    "middle-right": "origin-left",
    "bottom-right": "origin-top-left",
    "bottom-left": "origin-top-right"
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      angleEl = $$value;
      $$invalidate(7, angleEl);
    });
  }
  function div1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(6, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(13, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(14, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(15, material = $$new_props.material);
    if ("style" in $$new_props)
      $$invalidate(16, style = $$new_props.style);
    if ("angle" in $$new_props)
      $$invalidate(0, angle = $$new_props.angle);
    if ("angleClass" in $$new_props)
      $$invalidate(17, angleClass = $$new_props.angleClass);
    if ("size" in $$new_props)
      $$invalidate(18, size = $$new_props.size);
    if ("opened" in $$new_props)
      $$invalidate(19, opened = $$new_props.opened);
    if ("backdrop" in $$new_props)
      $$invalidate(1, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$new_props)
      $$invalidate(2, onBackdropClick = $$new_props.onBackdropClick);
    if ("target" in $$new_props)
      $$invalidate(20, target = $$new_props.target);
    if ("targetX" in $$new_props)
      $$invalidate(21, targetX = $$new_props.targetX);
    if ("targetY" in $$new_props)
      $$invalidate(22, targetY = $$new_props.targetY);
    if ("targetWidth" in $$new_props)
      $$invalidate(23, targetWidth = $$new_props.targetWidth);
    if ("targetHeight" in $$new_props)
      $$invalidate(24, targetHeight = $$new_props.targetHeight);
    if ("translucent" in $$new_props)
      $$invalidate(25, translucent = $$new_props.translucent);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    cls,
    useThemeClasses,
    useTheme,
    calcPopoverPosition,
    useDarkClasses,
    PopoverClasses,
    PopoverColors,
    className,
    colorsProp,
    ios,
    material,
    style,
    angle,
    angleClass,
    size,
    opened,
    backdrop,
    onBackdropClick,
    target,
    targetX,
    targetY,
    targetWidth,
    targetHeight,
    translucent,
    el,
    angleEl,
    positions,
    theme,
    dark,
    setPopover,
    attachEvents,
    detachEvents,
    watchOpened,
    originClasses,
    state,
    c,
    classes,
    angleStyle,
    popoverStyle,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(13, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(14, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(15, material = $$new_props.material);
    if ("style" in $$props)
      $$invalidate(16, style = $$new_props.style);
    if ("angle" in $$props)
      $$invalidate(0, angle = $$new_props.angle);
    if ("angleClass" in $$props)
      $$invalidate(17, angleClass = $$new_props.angleClass);
    if ("size" in $$props)
      $$invalidate(18, size = $$new_props.size);
    if ("opened" in $$props)
      $$invalidate(19, opened = $$new_props.opened);
    if ("backdrop" in $$props)
      $$invalidate(1, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$props)
      $$invalidate(2, onBackdropClick = $$new_props.onBackdropClick);
    if ("target" in $$props)
      $$invalidate(20, target = $$new_props.target);
    if ("targetX" in $$props)
      $$invalidate(21, targetX = $$new_props.targetX);
    if ("targetY" in $$props)
      $$invalidate(22, targetY = $$new_props.targetY);
    if ("targetWidth" in $$props)
      $$invalidate(23, targetWidth = $$new_props.targetWidth);
    if ("targetHeight" in $$props)
      $$invalidate(24, targetHeight = $$new_props.targetHeight);
    if ("translucent" in $$props)
      $$invalidate(25, translucent = $$new_props.translucent);
    if ("el" in $$props)
      $$invalidate(6, el = $$new_props.el);
    if ("angleEl" in $$props)
      $$invalidate(7, angleEl = $$new_props.angleEl);
    if ("positions" in $$props)
      $$invalidate(3, positions = $$new_props.positions);
    if ("theme" in $$props)
      $$invalidate(26, theme = $$new_props.theme);
    if ("state" in $$props)
      $$invalidate(4, state = $$new_props.state);
    if ("c" in $$props)
      $$invalidate(5, c = $$new_props.c);
    if ("classes" in $$props)
      $$invalidate(8, classes = $$new_props.classes);
    if ("angleStyle" in $$props)
      $$invalidate(9, angleStyle = $$new_props.angleStyle);
    if ("popoverStyle" in $$props)
      $$invalidate(10, popoverStyle = $$new_props.popoverStyle);
    if ("colors" in $$props)
      $$invalidate(27, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*opened*/
    524288) {
      $:
        $$invalidate(4, state = opened ? "opened" : "closed");
    }
    if ($$self.$$.dirty[0] & /*colorsProp*/
    8192) {
      $:
        $$invalidate(27, colors = PopoverColors(colorsProp, dark));
    }
    if ($$self.$$.dirty[0] & /*ios, material, size, angleClass, translucent, colors, className*/
    168218624) {
      $:
        $$invalidate(5, c = useThemeClasses({ ios, material }, PopoverClasses({ size, angleClass, translucent }, colors, className), className, (v) => $$invalidate(5, c = v)));
    }
    if ($$self.$$.dirty[0] & /*opened*/
    524288) {
      $:
        watchOpened(opened);
    }
    if ($$self.$$.dirty[0] & /*positions, style*/
    65544) {
      $:
        $$invalidate(10, popoverStyle = positions.set ? `
        ${style || ""};
        left: ${positions.popoverLeft};
        top: ${positions.popoverTop};
      ` : style || "");
    }
    if ($$self.$$.dirty[0] & /*positions*/
    8) {
      $:
        $$invalidate(9, angleStyle = positions.set ? `
        left: ${positions.angleLeft};
        top: ${positions.angleTop};
      ` : void 0);
    }
    if ($$self.$$.dirty[0] & /*c, state, theme, positions*/
    67108920) {
      $:
        $$invalidate(8, classes = cls(c.base[state], theme === "material" && originClasses[positions.popoverPosition]));
    }
  };
  return [
    angle,
    backdrop,
    onBackdropClick,
    positions,
    state,
    c,
    el,
    angleEl,
    classes,
    angleStyle,
    popoverStyle,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    style,
    angleClass,
    size,
    opened,
    target,
    targetX,
    targetY,
    targetWidth,
    targetHeight,
    translucent,
    theme,
    colors,
    $$scope,
    slots,
    div1_binding,
    div1_binding_1
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance41,
      create_fragment41,
      safe_not_equal,
      {
        class: 12,
        colors: 13,
        ios: 14,
        material: 15,
        style: 16,
        angle: 0,
        angleClass: 17,
        size: 18,
        opened: 19,
        backdrop: 1,
        onBackdropClick: 2,
        target: 20,
        targetX: 21,
        targetY: 22,
        targetWidth: 23,
        targetHeight: 24,
        translucent: 25
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment41.name
    });
  }
  get class() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angle() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angle(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angleClass() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angleClass(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBackdropClick() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBackdropClick(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetWidth() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetWidth(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetHeight() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetHeight(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translucent() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translucent(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popover_default = Popover;

// node_modules/konsta/shared/esm/classes/PopupClasses.js
var PopupClasses = (props, colors, classes) => {
  const {
    size
  } = props;
  return {
    base: {
      common: cls("left-1/2 top-1/2 transition-transform transform -translate-x-1/2 z-40 max-w-full max-h-full overflow-hidden md:no-safe-areas", colors.bg, positionClass("fixed", classes), size),
      ios: "duration-400 md:rounded-lg",
      material: " md:rounded-[1.75rem]",
      opened: {
        common: "-translate-y-1/2",
        material: cls("ease-material-in-popup duration-[600ms]")
      },
      closed: {
        common: "translate-y-full",
        material: "duration-400"
      }
    },
    backdrop: {
      common: "fixed z-40 w-full h-full left-0 top-0 bg-black bg-opacity-50 duration-400",
      opened: "",
      closed: "opacity-0 pointer-events-none"
    }
  };
};

// node_modules/konsta/shared/esm/colors/PopupColors.js
var PopupColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bg: cls("bg-white", dark("dark:bg-black")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Popup.svelte
var file39 = "node_modules/konsta/svelte/components/Popup.svelte";
function create_if_block21(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[2].backdrop[
        /*state*/
        ctx[3]
      ]);
      add_location(div, file39, 33, 2, 932);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onBackdropClick*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*c, state*/
      12 && div_class_value !== (div_class_value = /*c*/
      ctx[2].backdrop[
        /*state*/
        ctx[3]
      ])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(33:0) {#if backdrop}",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let t;
  let div;
  let div_class_value;
  let current;
  let if_block = (
    /*backdrop*/
    ctx[0] && create_if_block21(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[2].base[
        /*state*/
        ctx[3]
      ]
    },
    /*$$restProps*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file39, 35, 0, 999);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*backdrop*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c, state*/
        12 && div_class_value !== (div_class_value = /*c*/
        ctx2[2].base[
          /*state*/
          ctx2[3]
        ])) && { class: div_class_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let state;
  let colors;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "size", "opened", "backdrop", "onBackdropClick"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popup", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { size = "w-screen h-screen md:w-160 md:h-160" } = $$props;
  let { opened = false } = $$props;
  let { backdrop = true } = $$props;
  let { onBackdropClick = void 0 } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(6, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(8, material = $$new_props.material);
    if ("size" in $$new_props)
      $$invalidate(9, size = $$new_props.size);
    if ("opened" in $$new_props)
      $$invalidate(10, opened = $$new_props.opened);
    if ("backdrop" in $$new_props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$new_props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PopupClasses,
    PopupColors,
    useDarkClasses,
    useThemeClasses,
    className,
    colorsProp,
    ios,
    material,
    size,
    opened,
    backdrop,
    onBackdropClick,
    dark,
    c,
    colors,
    state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(6, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(8, material = $$new_props.material);
    if ("size" in $$props)
      $$invalidate(9, size = $$new_props.size);
    if ("opened" in $$props)
      $$invalidate(10, opened = $$new_props.opened);
    if ("backdrop" in $$props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("c" in $$props)
      $$invalidate(2, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(11, colors = $$new_props.colors);
    if ("state" in $$props)
      $$invalidate(3, state = $$new_props.state);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*opened*/
    1024) {
      $:
        $$invalidate(3, state = opened ? "opened" : "closed");
    }
    if ($$self.$$.dirty & /*colorsProp*/
    64) {
      $:
        $$invalidate(11, colors = PopupColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, size, colors, className*/
    2976) {
      $:
        $$invalidate(2, c = useThemeClasses({ ios, material }, PopupClasses({ size }, colors, className), className, (v) => $$invalidate(2, c = v)));
    }
  };
  return [
    backdrop,
    onBackdropClick,
    c,
    state,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    size,
    opened,
    colors,
    $$scope,
    slots
  ];
}
var Popup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {
      class: 5,
      colors: 6,
      ios: 7,
      material: 8,
      size: 9,
      opened: 10,
      backdrop: 0,
      onBackdropClick: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popup",
      options,
      id: create_fragment42.name
    });
  }
  get class() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBackdropClick() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBackdropClick(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popup_default = Popup;

// node_modules/konsta/svelte/components/icons/PreloaderIOS.svelte
var file40 = "node_modules/konsta/svelte/components/icons/PreloaderIOS.svelte";
function create_fragment43(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  let path5;
  let path6;
  let path7;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "20" },
    { height: "20" },
    { viewBox: "0 0 20 20" },
    { fill: "currentcolor" },
    /*$$restProps*/
    ctx[0]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      path5 = svg_element("path");
      path6 = svg_element("path");
      path7 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true, opacity: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true, opacity: true });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { d: true, opacity: true });
      children(path3).forEach(detach_dev);
      path4 = claim_svg_element(svg_nodes, "path", { d: true, opacity: true });
      children(path4).forEach(detach_dev);
      path5 = claim_svg_element(svg_nodes, "path", { d: true, opacity: true });
      children(path5).forEach(detach_dev);
      path6 = claim_svg_element(svg_nodes, "path", { d: true, opacity: true });
      children(path6).forEach(detach_dev);
      path7 = claim_svg_element(svg_nodes, "path", { d: true, opacity: true });
      children(path7).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M10,0 C10.5522847,0 11,0.44771525 11,1 L11,6 C11,6.55228475 10.5522847,7 10,7 C9.44771525,7 9,6.55228475 9,6 L9,1 C9,0.44771525 9.44771525,0 10,0 Z");
      add_location(path0, file40, 11, 2, 156);
      attr_dev(path1, "d", "M10,13 C10.5522847,13 11,13.4477153 11,14 L11,19 C11,19.5522847 10.5522847,20 10,20 C9.44771525,20 9,19.5522847 9,19 L9,14 C9,13.4477153 9.44771525,13 10,13 Z");
      attr_dev(path1, "opacity", ".64");
      add_location(path1, file40, 14, 2, 325);
      attr_dev(path2, "d", "M13,10 C13,9.44771525 13.4477153,9 14,9 L19,9 C19.5522847,9 20,9.44771525 20,10 C20,10.5522847 19.5522847,11 19,11 L14,11 C13.4477153,11 13,10.5522847 13,10 Z");
      attr_dev(path2, "opacity", ".82");
      add_location(path2, file40, 18, 2, 523);
      attr_dev(path3, "d", "M-3.8285687e-16,10 C-3.8285687e-16,9.44771525 0.44771525,9 1,9 L6,9 C6.55228475,9 7,9.44771525 7,10 C7,10.5522847 6.55228475,11 6,11 L1,11 C0.44771525,11 -3.8285687e-16,10.5522847 -3.8285687e-16,10 Z");
      attr_dev(path3, "opacity", ".46");
      add_location(path3, file40, 22, 2, 721);
      attr_dev(path4, "d", "M2.92912627,2.92912627 C3.31965056,2.53860197 3.95281554,2.53860197 4.34333983,2.92912627 L7.87887373,6.46466017 C8.26939803,6.85518446 8.26939803,7.48834944 7.87887373,7.87887373 C7.48834944,8.26939803 6.85518446,8.26939803 6.46466017,7.87887373 L2.92912627,4.34333983 C2.53860197,3.95281554 2.53860197,3.31965056 2.92912627,2.92912627 Z");
      attr_dev(path4, "opacity", ".37");
      add_location(path4, file40, 26, 2, 960);
      attr_dev(path5, "d", "M12.1211263,12.1211263 C12.5116506,11.730602 13.1448155,11.730602 13.5353398,12.1211263 L17.0708737,15.6566602 C17.461398,16.0471845 17.461398,16.6803494 17.0708737,17.0708737 C16.6803494,17.461398 16.0471845,17.461398 15.6566602,17.0708737 L12.1211263,13.5353398 C11.730602,13.1448155 11.730602,12.5116506 12.1211263,12.1211263 Z");
      attr_dev(path5, "opacity", ".73");
      add_location(path5, file40, 30, 2, 1338);
      attr_dev(path6, "d", "M12.1211263,7.87887373 C11.730602,7.48834944 11.730602,6.85518446 12.1211263,6.46466017 L15.6566602,2.92912627 C16.0471845,2.53860197 16.6803494,2.53860197 17.0708737,2.92912627 C17.461398,3.31965056 17.461398,3.95281554 17.0708737,4.34333983 L13.5353398,7.87887373 C13.1448155,8.26939803 12.5116506,8.26939803 12.1211263,7.87887373 Z");
      attr_dev(path6, "opacity", ".91");
      add_location(path6, file40, 34, 2, 1708);
      attr_dev(path7, "d", "M2.92912627,17.0708737 C2.53860197,16.6803494 2.53860197,16.0471845 2.92912627,15.6566602 L6.46466017,12.1211263 C6.85518446,11.730602 7.48834944,11.730602 7.87887373,12.1211263 C8.26939803,12.5116506 8.26939803,13.1448155 7.87887373,13.5353398 L4.34333983,17.0708737 C3.95281554,17.461398 3.31965056,17.461398 2.92912627,17.0708737 Z");
      attr_dev(path7, "opacity", ".55");
      add_location(path7, file40, 38, 2, 2082);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file40, 3, 0, 20);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, path3);
      append_hydration_dev(svg, path4);
      append_hydration_dev(svg, path5);
      append_hydration_dev(svg, path6);
      append_hydration_dev(svg, path7);
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "20" },
        { height: "20" },
        { viewBox: "0 0 20 20" },
        { fill: "currentcolor" },
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PreloaderIOS", slots, []);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
var PreloaderIOS = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PreloaderIOS",
      options,
      id: create_fragment43.name
    });
  }
};
var PreloaderIOS_default = PreloaderIOS;

// node_modules/konsta/svelte/components/icons/PreloaderMaterial.svelte
var file41 = "node_modules/konsta/svelte/components/icons/PreloaderMaterial.svelte";
function create_fragment44(ctx) {
  let svg;
  let circle;
  let svg_levels = [
    { viewBox: "0 0 36 36" },
    /*$$restProps*/
    ctx[0],
    { fill: "none" },
    { stroke: "currentcolor" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, fill: true, stroke: true });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "18");
      attr_dev(circle, "cy", "18");
      attr_dev(circle, "r", "16");
      add_location(circle, file41, 4, 2, 99);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file41, 3, 0, 20);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { viewBox: "0 0 36 36" },
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        ctx2[0],
        { fill: "none" },
        { stroke: "currentcolor" }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PreloaderMaterial", slots, []);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
var PreloaderMaterial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PreloaderMaterial",
      options,
      id: create_fragment44.name
    });
  }
};
var PreloaderMaterial_default = PreloaderMaterial;

// node_modules/konsta/shared/esm/classes/PreloaderClasses.js
var PreloaderClasses = (props, colors, theme) => {
  const {
    size
  } = props;
  return {
    base: {
      common: cls(theme === "ios" ? "k-ios-preloader" : "k-material-preloader", `inline-block ${size}`),
      ios: colors.iconIos,
      material: `stroke-4 ${colors.iconMaterial}`
    },
    inner: {
      common: `block w-full h-full`
    }
  };
};

// node_modules/konsta/shared/esm/colors/PreloaderColors.js
var PreloaderColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    iconIos: "text-primary",
    iconMaterial: cls("text-md-light-primary", dark("dark:text-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Preloader.svelte
var file42 = "node_modules/konsta/svelte/components/Preloader.svelte";
function create_else_block10(ctx) {
  let preloadermaterial;
  let current;
  preloadermaterial = new PreloaderMaterial_default({
    props: { class: "w-full h-full" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(preloadermaterial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(preloadermaterial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(preloadermaterial, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(preloadermaterial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(preloadermaterial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(preloadermaterial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block10.name,
    type: "else",
    source: "(39:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let preloaderios;
  let current;
  preloaderios = new PreloaderIOS_default({
    props: { class: "w-full h-full" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(preloaderios.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(preloaderios.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(preloaderios, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(preloaderios.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(preloaderios.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(preloaderios, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(37:4) {#if theme === 'ios'}",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let span1;
  let span0;
  let current_block_type_index;
  let if_block;
  let span0_class_value;
  let t;
  let span1_class_value;
  let current;
  const if_block_creators = [create_if_block22, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*theme*/
      ctx2[0] === "ios"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let span1_levels = [
    {
      class: span1_class_value = /*c*/
      ctx[1].base
    },
    /*$$restProps*/
    ctx[2]
  ];
  let span1_data = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span1_data = assign(span1_data, span1_levels[i]);
  }
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      if_block.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      t = claim_space(span1_nodes);
      if (default_slot)
        default_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = /*c*/
      ctx[1].inner);
      add_location(span0, file42, 35, 2, 1056);
      set_attributes(span1, span1_data);
      add_location(span1, file42, 34, 0, 1015);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, span0);
      if_blocks[current_block_type_index].m(span0, null);
      append_hydration_dev(span1, t);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(span0, null);
      }
      if (!current || dirty & /*c*/
      2 && span0_class_value !== (span0_class_value = /*c*/
      ctx2[1].inner)) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span1, span1_data = get_spread_update(span1_levels, [
        (!current || dirty & /*c*/
        2 && span1_class_value !== (span1_class_value = /*c*/
        ctx2[1].base)) && { class: span1_class_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let colors;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Preloader", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { size = "w-8 h-8" } = $$props;
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(0, theme = v));
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(4, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(5, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(6, material = $$new_props.material);
    if ("size" in $$new_props)
      $$invalidate(7, size = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useTheme,
    useThemeClasses,
    useDarkClasses,
    PreloaderIOS: PreloaderIOS_default,
    PreloaderMaterial: PreloaderMaterial_default,
    PreloaderClasses,
    PreloaderColors,
    className,
    colorsProp,
    ios,
    material,
    size,
    theme,
    dark,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(4, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(5, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(6, material = $$new_props.material);
    if ("size" in $$props)
      $$invalidate(7, size = $$new_props.size);
    if ("theme" in $$props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(1, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(8, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    16) {
      $:
        $$invalidate(8, colors = PreloaderColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, size, colors, theme, className*/
    489) {
      $:
        $$invalidate(1, c = useThemeClasses({ ios, material }, PreloaderClasses({ size }, colors, theme), className, (v) => $$invalidate(1, c = v)));
    }
  };
  return [
    theme,
    c,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    size,
    colors,
    $$scope,
    slots
  ];
}
var Preloader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, {
      class: 3,
      colors: 4,
      ios: 5,
      material: 6,
      size: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Preloader",
      options,
      id: create_fragment45.name
    });
  }
  get class() {
    throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Preloader_default = Preloader;

// node_modules/konsta/shared/esm/classes/ProgressbarClasses.js
var ProgressbarClasses = (colors) => {
  return {
    base: {
      common: `block h-1 bg-opacity-30 dark:bg-opacity-30 overflow-hidden`,
      ios: `bg-black rounded-full`,
      material: colors.bgMaterial
    },
    inner: {
      common: `block duration-200 w-full h-full`,
      ios: colors.bgIos,
      material: colors.bgMaterial
    }
  };
};

// node_modules/konsta/shared/esm/colors/ProgressbarColors.js
var ProgressbarColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: "bg-primary",
    bgMaterial: cls("bg-md-light-primary", dark("dark:bg-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Progressbar.svelte
var file43 = "node_modules/konsta/svelte/components/Progressbar.svelte";
function create_fragment46(ctx) {
  let span1;
  let span0;
  let span0_class_value;
  let span0_style_value;
  let t;
  let span1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span1_levels = [
    {
      class: span1_class_value = /*c*/
      ctx[1].base
    },
    /*$$restProps*/
    ctx[2]
  ];
  let span1_data = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span1_data = assign(span1_data, span1_levels[i]);
  }
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true, style: true });
      children(span0).forEach(detach_dev);
      t = claim_space(span1_nodes);
      if (default_slot)
        default_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = /*c*/
      ctx[1].inner);
      attr_dev(span0, "style", span0_style_value = `transform: translateX(-${100 - /*progress*/
      ctx[0] / 1 * 100}%)`);
      add_location(span0, file43, 28, 2, 794);
      set_attributes(span1, span1_data);
      add_location(span1, file43, 27, 0, 753);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span1, t);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*c*/
      2 && span0_class_value !== (span0_class_value = /*c*/
      ctx2[1].inner)) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (!current || dirty & /*progress*/
      1 && span0_style_value !== (span0_style_value = `transform: translateX(-${100 - /*progress*/
      ctx2[0] / 1 * 100}%)`)) {
        attr_dev(span0, "style", span0_style_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span1, span1_data = get_spread_update(span1_levels, [
        (!current || dirty & /*c*/
        2 && span1_class_value !== (span1_class_value = /*c*/
        ctx2[1].base)) && { class: span1_class_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let colors;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "progress"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Progressbar", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { progress = 0 } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(4, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(5, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(6, material = $$new_props.material);
    if ("progress" in $$new_props)
      $$invalidate(0, progress = $$new_props.progress);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ProgressbarClasses,
    ProgressbarColors,
    useThemeClasses,
    useDarkClasses,
    className,
    colorsProp,
    ios,
    material,
    progress,
    dark,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(4, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(5, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(6, material = $$new_props.material);
    if ("progress" in $$props)
      $$invalidate(0, progress = $$new_props.progress);
    if ("c" in $$props)
      $$invalidate(1, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(7, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    16) {
      $:
        $$invalidate(7, colors = ProgressbarColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    232) {
      $:
        $$invalidate(1, c = useThemeClasses({ ios, material }, ProgressbarClasses(colors), className, (v) => $$invalidate(1, c = v)));
    }
  };
  return [
    progress,
    c,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    colors,
    $$scope,
    slots
  ];
}
var Progressbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      class: 3,
      colors: 4,
      ios: 5,
      material: 6,
      progress: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Progressbar",
      options,
      id: create_fragment46.name
    });
  }
  get class() {
    throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get progress() {
    throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set progress(value) {
    throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Progressbar_default = Progressbar;

// node_modules/konsta/shared/esm/classes/RadioClasses.js
var RadioClasses = (props, colors, classes, darkClasses) => {
  return {
    base: cls(`cursor-pointer inline-flex align-middle`, positionClass("relative", classes), darkClasses("dark:touch-ripple-white")),
    iconWrap: {
      common: "flex items-center justify-center rounded-full",
      ios: "w-5.5 h-5.5 border",
      material: "w-5 h-5 border-2",
      notChecked: {
        ios: colors.borderIos,
        material: colors.borderMaterial
      },
      checked: {
        ios: colors.borderCheckedIos,
        material: colors.borderCheckedMaterial
      }
    },
    icon: {
      ios: "text-primary",
      material: `w-3/5 h-3/5 rounded-full ${colors.bgCheckedMaterial}`,
      notChecked: "opacity-0",
      checked: "opacity-100"
    },
    indeterminateIcon: {
      common: "bg-white w-3/4",
      ios: "h-0.25",
      material: "h-0.5"
    },
    input: {
      common: "hidden"
    }
  };
};

// node_modules/konsta/shared/esm/colors/RadioColors.js
var RadioColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    borderIos: cls("border-black border-opacity-30", dark("dark:border-white dark:border-opacity-30")),
    borderMaterial: cls(`border-md-light-outline`, dark("dark:border-md-dark-outline")),
    bgCheckedIos: "bg-primary",
    bgCheckedMaterial: cls("bg-md-light-primary", dark("dark:bg-md-dark-primary")),
    borderCheckedIos: "border-primary",
    borderCheckedMaterial: cls("border-md-light-primary", dark("dark:border-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Radio.svelte
var file44 = "node_modules/konsta/svelte/components/Radio.svelte";
function create_else_block11(ctx) {
  let span;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[9].icon[
        /*state*/
        ctx[10]
      ]);
      add_location(span, file44, 68, 6, 1722);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*c, state*/
      1536 && span_class_value !== (span_class_value = /*c*/
      ctx2[9].icon[
        /*state*/
        ctx2[10]
      ])) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(68:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let checkboxicon;
  let current;
  checkboxicon = new CheckboxIcon_default({
    props: {
      class: (
        /*c*/
        ctx[9].icon[
          /*state*/
          ctx[10]
        ]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkboxicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkboxicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxicon_changes = {};
      if (dirty & /*c, state*/
      1536)
        checkboxicon_changes.class = /*c*/
        ctx2[9].icon[
          /*state*/
          ctx2[10]
        ];
      checkboxicon.$set(checkboxicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(66:4) {#if theme === 'ios'}",
    ctx
  });
  return block;
}
function create_dynamic_element11(ctx) {
  let svelte_element;
  let input;
  let input_class_value;
  let t0;
  let i;
  let current_block_type_index;
  let if_block;
  let i_class_value;
  let t1;
  let svelte_element_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block23, create_else_block11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*theme*/
      ctx2[8] === "ios"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*c*/
      ctx[9].base
    },
    /*$$restProps*/
    ctx[11]
  ];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i2]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[0]
      );
      input = element("input");
      t0 = space();
      i = element("i");
      if_block.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[0] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      input = claim_element(svelte_element_nodes, "INPUT", { type: true, name: true, class: true });
      t0 = claim_space(svelte_element_nodes);
      i = claim_element(svelte_element_nodes, "I", { class: true });
      var i_nodes = children(i);
      if_block.l(i_nodes);
      i_nodes.forEach(detach_dev);
      t1 = claim_space(svelte_element_nodes);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[2]
      );
      input.value = /*value*/
      ctx[3];
      input.disabled = /*disabled*/
      ctx[4];
      input.readOnly = /*readonly*/
      ctx[5];
      input.checked = /*checked*/
      ctx[1];
      attr_dev(input, "class", input_class_value = /*c*/
      ctx[9].input);
      add_location(input, file44, 53, 2, 1459);
      attr_dev(i, "class", i_class_value = /*c*/
      ctx[9].iconWrap[
        /*state*/
        ctx[10]
      ]);
      add_location(i, file44, 64, 2, 1603);
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file44, 47, 0, 1353);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, input);
      append_hydration_dev(svelte_element, t0);
      append_hydration_dev(svelte_element, i);
      if_blocks[current_block_type_index].m(i, null);
      append_hydration_dev(svelte_element, t1);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[20](svelte_element);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          function() {
            if (is_function(
              /*onChange*/
              ctx[6]
            ))
              ctx[6].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*name*/
      4) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx[2]
        );
      }
      if (!current || dirty & /*value*/
      8) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx[3]
        );
      }
      if (!current || dirty & /*disabled*/
      16) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx[4]
        );
      }
      if (!current || dirty & /*readonly*/
      32) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx[5]
        );
      }
      if (!current || dirty & /*checked*/
      2) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx[1]
        );
      }
      if (!current || dirty & /*c*/
      512 && input_class_value !== (input_class_value = /*c*/
      ctx[9].input)) {
        attr_dev(input, "class", input_class_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(i, null);
      }
      if (!current || dirty & /*c, state*/
      1536 && i_class_value !== (i_class_value = /*c*/
      ctx[9].iconWrap[
        /*state*/
        ctx[10]
      ])) {
        attr_dev(i, "class", i_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*c*/
        512 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx[9].base)) && { class: svelte_element_class_value },
        dirty & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx[11]
      ]);
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[20](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element11.name,
    type: "child_dynamic_element",
    source: "(48:0) <svelte:element   this={component}   bind:this={rippleEl.current}   class={c.base}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment47(ctx) {
  let previous_tag = (
    /*component*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[0]
  );
  let svelte_element = (
    /*component*/
    ctx[0] && create_dynamic_element11(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*component*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element11(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element11(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[0];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let colors;
  let state;
  let c;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "component",
    "checked",
    "name",
    "value",
    "disabled",
    "readonly",
    "onChange",
    "touchRipple"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Radio", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "label" } = $$props;
  let { checked = false } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { readonly = false } = $$props;
  let { onChange = void 0 } = $$props;
  let { touchRipple = true } = $$props;
  const rippleEl = { current: null };
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(8, theme = v));
  const dark = useDarkClasses();
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleEl.current = $$value;
      $$invalidate(7, rippleEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(13, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(14, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(15, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(0, component = $$new_props.component);
    if ("checked" in $$new_props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(3, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props)
      $$invalidate(5, readonly = $$new_props.readonly);
    if ("onChange" in $$new_props)
      $$invalidate(6, onChange = $$new_props.onChange);
    if ("touchRipple" in $$new_props)
      $$invalidate(16, touchRipple = $$new_props.touchRipple);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useTheme,
    useThemeClasses,
    useTouchRipple,
    CheckboxIcon: CheckboxIcon_default,
    useDarkClasses,
    RadioClasses,
    RadioColors,
    className,
    colorsProp,
    ios,
    material,
    component,
    checked,
    name,
    value,
    disabled,
    readonly,
    onChange,
    touchRipple,
    rippleEl,
    theme,
    dark,
    c,
    colors,
    state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(13, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(14, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(15, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(0, component = $$new_props.component);
    if ("checked" in $$props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(3, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("readonly" in $$props)
      $$invalidate(5, readonly = $$new_props.readonly);
    if ("onChange" in $$props)
      $$invalidate(6, onChange = $$new_props.onChange);
    if ("touchRipple" in $$props)
      $$invalidate(16, touchRipple = $$new_props.touchRipple);
    if ("theme" in $$props)
      $$invalidate(8, theme = $$new_props.theme);
    if ("c" in $$props)
      $$invalidate(9, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(17, colors = $$new_props.colors);
    if ("state" in $$props)
      $$invalidate(10, state = $$new_props.state);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*rippleEl, touchRipple*/
    65664) {
      $:
        useTouchRipple(rippleEl, touchRipple);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    8192) {
      $:
        $$invalidate(17, colors = RadioColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*checked*/
    2) {
      $:
        $$invalidate(10, state = checked ? "checked" : "notChecked");
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    184320) {
      $:
        $$invalidate(9, c = useThemeClasses({ ios, material }, RadioClasses({}, colors, className, dark), className, (v) => $$invalidate(9, c = v)));
    }
  };
  return [
    component,
    checked,
    name,
    value,
    disabled,
    readonly,
    onChange,
    rippleEl,
    theme,
    c,
    state,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    touchRipple,
    colors,
    $$scope,
    slots,
    svelte_element_binding
  ];
}
var Radio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      class: 12,
      colors: 13,
      ios: 14,
      material: 15,
      component: 0,
      checked: 1,
      name: 2,
      value: 3,
      disabled: 4,
      readonly: 5,
      onChange: 6,
      touchRipple: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Radio",
      options,
      id: create_fragment47.name
    });
  }
  get class() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Radio_default = Radio;

// node_modules/konsta/shared/esm/classes/RangeClasses.js
var RangeClasses = (props, colors, darkClasses) => {
  return {
    base: {
      common: "block relative select-none w-full self-center touch-pan-y",
      ios: "h-7",
      material: "h-5"
    },
    trackBg: {
      common: cls("absolute top-1/2 left-0 w-full transform -translate-y-1/2 bg-black bg-opacity-20", darkClasses("dark:bg-white dark:bg-opacity-20")),
      ios: "h-1 rounded-full",
      material: "h-0.5"
    },
    trackValue: {
      common: `absolute top-1/2 left-0 w-full transform -translate-y-1/2`,
      ios: `h-1 rounded-full ${colors.valueBgIos}`,
      material: `h-0.5 ${colors.valueBgMaterial}`
    },
    input: {
      common: "appearance-none w-full bg-transparent cursor-pointer block focus:outline-none relative",
      ios: "h-7",
      material: "h-5"
    },
    inputThumb: {
      common: "range-thumb:relative range-thumb:appearance-none range-thumb:rounded-full range-thumb:border-none",
      ios: `range-thumb:w-7 range-thumb:h-7 range-thumb:-mt-3.5 ${colors.thumbBgIos} range-thumb:shadow-ios-toggle`,
      material: `range-thumb:w-3 range-thumb:h-3 ${colors.thumbBgMaterial} range-thumb:-mt-1.5 range-thumb:transform range-thumb:duration-200 active:range-thumb:scale-150`
    },
    inputTrack: {
      common: "range-track:appearance-none range-track:h-px"
    }
  };
};

// node_modules/konsta/shared/esm/colors/RangeColors.js
var RangeColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    valueBgIos: "bg-primary",
    valueBgMaterial: cls("bg-md-light-primary", dark("dark:bg-md-dark-primary")),
    thumbBgIos: "range-thumb:bg-white",
    thumbBgMaterial: cls("range-thumb:bg-md-light-primary", dark("dark:range-thumb:bg-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Range.svelte
var file45 = "node_modules/konsta/svelte/components/Range.svelte";
function create_fragment48(ctx) {
  let div;
  let span0;
  let span0_class_value;
  let t0;
  let span1;
  let span1_class_value;
  let span1_style_value;
  let t1;
  let input;
  let input_class_value;
  let div_class_value;
  let mounted;
  let dispose;
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[13].base
    },
    /*$$restProps*/
    ctx[14]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t0 = claim_space(div_nodes);
      span1 = claim_element(div_nodes, "SPAN", { class: true, style: true });
      children(span1).forEach(detach_dev);
      t1 = claim_space(div_nodes);
      input = claim_element(div_nodes, "INPUT", {
        class: true,
        type: true,
        id: true,
        name: true,
        min: true,
        max: true,
        step: true
      });
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = /*c*/
      ctx[13].trackBg);
      add_location(span0, file45, 42, 2, 1224);
      attr_dev(span1, "class", span1_class_value = /*c*/
      ctx[13].trackValue);
      attr_dev(span1, "style", span1_style_value = `width: ${/*valueWidth*/
      ctx[12]}%`);
      add_location(span1, file45, 43, 2, 1253);
      attr_dev(input, "class", input_class_value = cls(
        /*c*/
        ctx[13].input,
        /*c*/
        ctx[13].inputThumb,
        /*c*/
        ctx[13].inputTrack
      ));
      attr_dev(input, "type", "range");
      attr_dev(
        input,
        "id",
        /*inputId*/
        ctx[0]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[1]
      );
      attr_dev(
        input,
        "min",
        /*min*/
        ctx[6]
      );
      attr_dev(
        input,
        "max",
        /*max*/
        ctx[7]
      );
      attr_dev(
        input,
        "step",
        /*step*/
        ctx[5]
      );
      input.value = /*value*/
      ctx[2];
      input.readOnly = /*readonly*/
      ctx[3];
      input.disabled = /*disabled*/
      ctx[4];
      add_location(input, file45, 44, 2, 1317);
      set_attributes(div, div_data);
      add_location(div, file45, 41, 0, 1184);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span0);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, span1);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            function() {
              if (is_function(
                /*onInput*/
                ctx[8]
              ))
                ctx[8].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            function() {
              if (is_function(
                /*onChange*/
                ctx[9]
              ))
                ctx[9].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            function() {
              if (is_function(
                /*onFocus*/
                ctx[10]
              ))
                ctx[10].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            function() {
              if (is_function(
                /*onBlur*/
                ctx[11]
              ))
                ctx[11].apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*c*/
      8192 && span0_class_value !== (span0_class_value = /*c*/
      ctx[13].trackBg)) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (dirty & /*c*/
      8192 && span1_class_value !== (span1_class_value = /*c*/
      ctx[13].trackValue)) {
        attr_dev(span1, "class", span1_class_value);
      }
      if (dirty & /*valueWidth*/
      4096 && span1_style_value !== (span1_style_value = `width: ${/*valueWidth*/
      ctx[12]}%`)) {
        attr_dev(span1, "style", span1_style_value);
      }
      if (dirty & /*c*/
      8192 && input_class_value !== (input_class_value = cls(
        /*c*/
        ctx[13].input,
        /*c*/
        ctx[13].inputThumb,
        /*c*/
        ctx[13].inputTrack
      ))) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*inputId*/
      1) {
        attr_dev(
          input,
          "id",
          /*inputId*/
          ctx[0]
        );
      }
      if (dirty & /*name*/
      2) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx[1]
        );
      }
      if (dirty & /*min*/
      64) {
        attr_dev(
          input,
          "min",
          /*min*/
          ctx[6]
        );
      }
      if (dirty & /*max*/
      128) {
        attr_dev(
          input,
          "max",
          /*max*/
          ctx[7]
        );
      }
      if (dirty & /*step*/
      32) {
        attr_dev(
          input,
          "step",
          /*step*/
          ctx[5]
        );
      }
      if (dirty & /*value*/
      4) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx[2]
        );
      }
      if (dirty & /*readonly*/
      8) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx[3]
        );
      }
      if (dirty & /*disabled*/
      16) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx[4]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*c*/
        8192 && div_class_value !== (div_class_value = /*c*/
        ctx[13].base) && { class: div_class_value },
        dirty & /*$$restProps*/
        16384 && /*$$restProps*/
        ctx[14]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  let colors;
  let c;
  let valueWidth;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "inputId",
    "name",
    "value",
    "readonly",
    "disabled",
    "step",
    "min",
    "max",
    "onInput",
    "onChange",
    "onFocus",
    "onBlur"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Range", slots, []);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { inputId = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { readonly = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { step = 1 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { onInput = void 0 } = $$props;
  let { onChange = void 0 } = $$props;
  let { onFocus = void 0 } = $$props;
  let { onBlur = void 0 } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(15, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(16, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(17, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(18, material = $$new_props.material);
    if ("inputId" in $$new_props)
      $$invalidate(0, inputId = $$new_props.inputId);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("readonly" in $$new_props)
      $$invalidate(3, readonly = $$new_props.readonly);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("step" in $$new_props)
      $$invalidate(5, step = $$new_props.step);
    if ("min" in $$new_props)
      $$invalidate(6, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(7, max = $$new_props.max);
    if ("onInput" in $$new_props)
      $$invalidate(8, onInput = $$new_props.onInput);
    if ("onChange" in $$new_props)
      $$invalidate(9, onChange = $$new_props.onChange);
    if ("onFocus" in $$new_props)
      $$invalidate(10, onFocus = $$new_props.onFocus);
    if ("onBlur" in $$new_props)
      $$invalidate(11, onBlur = $$new_props.onBlur);
  };
  $$self.$capture_state = () => ({
    cls,
    RangeClasses,
    RangeColors,
    useDarkClasses,
    useThemeClasses,
    className,
    colorsProp,
    ios,
    material,
    inputId,
    name,
    value,
    readonly,
    disabled,
    step,
    min,
    max,
    onInput,
    onChange,
    onFocus,
    onBlur,
    dark,
    valueWidth,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(15, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(16, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(17, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(18, material = $$new_props.material);
    if ("inputId" in $$props)
      $$invalidate(0, inputId = $$new_props.inputId);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("readonly" in $$props)
      $$invalidate(3, readonly = $$new_props.readonly);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("step" in $$props)
      $$invalidate(5, step = $$new_props.step);
    if ("min" in $$props)
      $$invalidate(6, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(7, max = $$new_props.max);
    if ("onInput" in $$props)
      $$invalidate(8, onInput = $$new_props.onInput);
    if ("onChange" in $$props)
      $$invalidate(9, onChange = $$new_props.onChange);
    if ("onFocus" in $$props)
      $$invalidate(10, onFocus = $$new_props.onFocus);
    if ("onBlur" in $$props)
      $$invalidate(11, onBlur = $$new_props.onBlur);
    if ("valueWidth" in $$props)
      $$invalidate(12, valueWidth = $$new_props.valueWidth);
    if ("c" in $$props)
      $$invalidate(13, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(19, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    65536) {
      $:
        $$invalidate(19, colors = RangeColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    950272) {
      $:
        $$invalidate(13, c = useThemeClasses({ ios, material }, RangeClasses({}, colors, dark), className, (v) => $$invalidate(13, c = v)));
    }
    if ($$self.$$.dirty & /*value, min, max*/
    196) {
      $:
        $$invalidate(12, valueWidth = ((value || 0) - min) / (max - min) * 100);
    }
  };
  return [
    inputId,
    name,
    value,
    readonly,
    disabled,
    step,
    min,
    max,
    onInput,
    onChange,
    onFocus,
    onBlur,
    valueWidth,
    c,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    colors
  ];
}
var Range = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, {
      class: 15,
      colors: 16,
      ios: 17,
      material: 18,
      inputId: 0,
      name: 1,
      value: 2,
      readonly: 3,
      disabled: 4,
      step: 5,
      min: 6,
      max: 7,
      onInput: 8,
      onChange: 9,
      onFocus: 10,
      onBlur: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Range",
      options,
      id: create_fragment48.name
    });
  }
  get class() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onInput() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onInput(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onFocus() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onFocus(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBlur() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBlur(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Range_default = Range;

// node_modules/konsta/shared/esm/classes/SegmentedClasses.js
var SegmentedClasses = (props, colors, darkClasses) => {
  const {
    outline,
    rounded
  } = props;
  return {
    base: {
      common: `flex justify-center items-center overflow-hidden w-full`,
      square: {
        ios: "rounded",
        material: "rounded-lg"
      },
      rounded: "rounded-full"
    },
    raised: outline ? "shadow" : `shadow divide-x divide-black divide-opacity-10`,
    outline: {
      common: ``,
      ios: `${colors.borderIos} border-2`,
      material: `${colors.borderMaterial} border`
    },
    outlineInner: {
      common: `-m-0.5 flex w-full justify-center items-center`,
      ios: `divide-x-2 ${colors.divideIos}`,
      material: `divide-x ${colors.divideMaterial}`
    },
    strong: {
      common: cls("p-0.5 space-x-1 relative"),
      ios: colors.strongBgIos,
      material: colors.strongBgMaterial
    },
    strongHighlight: {
      common: cls("absolute left-0.5 top-0.5 bottom-0.5 !ml-0 pointer-events-none duration-200", rounded && "rounded-full", `bg-white shadow`, darkClasses("dark:bg-opacity-15 dark:touch-ripple-white")),
      ios: cls(!rounded && "rounded"),
      material: cls(!rounded && "rounded-md")
    }
  };
};

// node_modules/konsta/shared/esm/colors/SegmentedColors.js
var SegmentedColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    strongBgIos: cls("bg-black bg-opacity-5", dark("dark:bg-white dark:bg-opacity-10")),
    strongBgMaterial: cls("bg-md-light-surface-variant", dark("dark:bg-md-dark-surface-variant")),
    borderIos: "border-primary",
    borderMaterial: cls("border-md-light-outline", dark("dark:border-md-dark-outline")),
    divideIos: "divide-primary",
    divideMaterial: cls("divide-md-light-outline", dark("dark:divide-md-dark-outline")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Segmented.svelte
var file46 = "node_modules/konsta/svelte/components/Segmented.svelte";
function create_else_block12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(84:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let span;
  let span_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[2].outlineInner);
      add_location(span, file46, 80, 4, 2156);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*c*/
      4 && span_class_value !== (span_class_value = /*c*/
      ctx2[2].outlineInner)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(80:2) {#if outline}",
    ctx
  });
  return block;
}
function create_if_block24(ctx) {
  let span;
  let span_class_value;
  let span_style_value;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[2].strongHighlight);
      attr_dev(span, "style", span_style_value = `
        width: ${/*highlightStyle*/
      ctx[4].width};
        transform: ${/*highlightStyle*/
      ctx[4].transform};
      `);
      add_location(span, file46, 87, 4, 2263);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      ctx[16](span);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*c*/
      4 && span_class_value !== (span_class_value = /*c*/
      ctx2[2].strongHighlight)) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty & /*highlightStyle*/
      16 && span_style_value !== (span_style_value = `
        width: ${/*highlightStyle*/
      ctx2[4].width};
        transform: ${/*highlightStyle*/
      ctx2[4].transform};
      `)) {
        attr_dev(span, "style", span_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      ctx[16](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(87:2) {#if strong}",
    ctx
  });
  return block;
}
function create_fragment49(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [create_if_block_115, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*outline*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*strong*/
    ctx[1] && create_if_block24(ctx)
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file46, 78, 0, 2097);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (
        /*strong*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block24(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        32) && { class: (
          /*classes*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let colors;
  let c;
  let classes;
  const omit_props_names = ["class", "colors", "ios", "material", "raised", "outline", "strong", "rounded"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Segmented", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { raised = false } = $$props;
  let { outline = false } = $$props;
  let { strong = false } = $$props;
  let { rounded = false } = $$props;
  let highlightElRef = null;
  const dark = useDarkClasses();
  let highlightStyle = { transform: "", width: "" };
  const setHighlight = () => {
    if (strong && highlightElRef) {
      const buttonsEl = highlightElRef.parentElement;
      const buttonsLength = buttonsEl.children.length - 1;
      const activeIndex = [...buttonsEl.children].indexOf(buttonsEl.querySelector(".k-segmented-strong-button-active"));
      const between = "4px";
      const padding = "2px";
      const width = `calc((100% - ${padding} * 2 - ${between} * (${buttonsLength} - 1)) / ${buttonsLength})`;
      const transform = `translateX(calc(${activeIndex} * 100% + ${activeIndex} * ${between}))`;
      if (width !== highlightStyle.width || transform !== highlightStyle.transform) {
        $$invalidate(4, highlightStyle = { width, transform });
      }
    }
  };
  onMount(() => setHighlight());
  afterUpdate(() => setHighlight());
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      highlightElRef = $$value;
      $$invalidate(3, highlightElRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(8, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(9, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(10, material = $$new_props.material);
    if ("raised" in $$new_props)
      $$invalidate(11, raised = $$new_props.raised);
    if ("outline" in $$new_props)
      $$invalidate(0, outline = $$new_props.outline);
    if ("strong" in $$new_props)
      $$invalidate(1, strong = $$new_props.strong);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    afterUpdate,
    cls,
    SegmentedClasses,
    SegmentedColors,
    useDarkClasses,
    useThemeClasses,
    className,
    colorsProp,
    ios,
    material,
    raised,
    outline,
    strong,
    rounded,
    highlightElRef,
    dark,
    highlightStyle,
    setHighlight,
    c,
    classes,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(8, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(9, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(10, material = $$new_props.material);
    if ("raised" in $$props)
      $$invalidate(11, raised = $$new_props.raised);
    if ("outline" in $$props)
      $$invalidate(0, outline = $$new_props.outline);
    if ("strong" in $$props)
      $$invalidate(1, strong = $$new_props.strong);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("highlightElRef" in $$props)
      $$invalidate(3, highlightElRef = $$new_props.highlightElRef);
    if ("highlightStyle" in $$props)
      $$invalidate(4, highlightStyle = $$new_props.highlightStyle);
    if ("c" in $$props)
      $$invalidate(2, c = $$new_props.c);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("colors" in $$props)
      $$invalidate(13, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    256) {
      $:
        $$invalidate(13, colors = SegmentedColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, outline, rounded, colors*/
    13825) {
      $:
        $$invalidate(2, c = useThemeClasses({ ios, material }, SegmentedClasses({ outline, rounded }, colors, dark), "", (v) => $$invalidate(2, c = v)));
    }
    if ($$self.$$.dirty & /*rounded, c, raised, outline, strong, className*/
    6279) {
      $:
        $$invalidate(5, classes = cls(
          // base
          rounded ? c.base.rounded : c.base.square,
          raised && c.raised,
          outline && c.outline,
          strong && c.strong,
          className
        ));
    }
  };
  return [
    outline,
    strong,
    c,
    highlightElRef,
    highlightStyle,
    classes,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    raised,
    rounded,
    colors,
    $$scope,
    slots,
    span_binding
  ];
}
var Segmented = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {
      class: 7,
      colors: 8,
      ios: 9,
      material: 10,
      raised: 11,
      outline: 0,
      strong: 1,
      rounded: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Segmented",
      options,
      id: create_fragment49.name
    });
  }
  get class() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raised() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raised(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strong() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strong(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Segmented_default = Segmented;

// node_modules/konsta/svelte/components/SegmentedButton.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(14:0) <Button   segmented   segmentedActive={active}   segmentedStrong={strong}   rounded={rounded && strong}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment50(ctx) {
  let button;
  let current;
  const button_spread_levels = [
    { segmented: true },
    { segmentedActive: (
      /*active*/
      ctx[0]
    ) },
    { segmentedStrong: (
      /*strong*/
      ctx[1]
    ) },
    {
      rounded: (
        /*rounded*/
        ctx[2] && /*strong*/
        ctx[1]
      )
    },
    /*$$restProps*/
    ctx[3]
  ];
  let button_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  button = new Button_default({ props: button_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button_changes = dirty & /*active, strong, rounded, $$restProps*/
      15 ? get_spread_update(button_spread_levels, [
        button_spread_levels[0],
        dirty & /*active*/
        1 && { segmentedActive: (
          /*active*/
          ctx2[0]
        ) },
        dirty & /*strong*/
        2 && { segmentedStrong: (
          /*strong*/
          ctx2[1]
        ) },
        dirty & /*rounded, strong*/
        6 && {
          rounded: (
            /*rounded*/
            ctx2[2] && /*strong*/
            ctx2[1]
          )
        },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      128) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  const omit_props_names = ["active", "strong", "rounded", "outline", "clear"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SegmentedButton", slots, ["default"]);
  let { active = false } = $$props;
  let { strong = false } = $$props;
  let { rounded = false } = $$props;
  let { outline = false } = $$props;
  let { clear = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("strong" in $$new_props)
      $$invalidate(1, strong = $$new_props.strong);
    if ("rounded" in $$new_props)
      $$invalidate(2, rounded = $$new_props.rounded);
    if ("outline" in $$new_props)
      $$invalidate(4, outline = $$new_props.outline);
    if ("clear" in $$new_props)
      $$invalidate(5, clear = $$new_props.clear);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Button: Button_default,
    active,
    strong,
    rounded,
    outline,
    clear
  });
  $$self.$inject_state = ($$new_props) => {
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("strong" in $$props)
      $$invalidate(1, strong = $$new_props.strong);
    if ("rounded" in $$props)
      $$invalidate(2, rounded = $$new_props.rounded);
    if ("outline" in $$props)
      $$invalidate(4, outline = $$new_props.outline);
    if ("clear" in $$props)
      $$invalidate(5, clear = $$new_props.clear);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [active, strong, rounded, $$restProps, outline, clear, slots, $$scope];
}
var SegmentedButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      active: 0,
      strong: 1,
      rounded: 2,
      outline: 4,
      clear: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SegmentedButton",
      options,
      id: create_fragment50.name
    });
  }
  get active() {
    throw new Error("<SegmentedButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<SegmentedButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strong() {
    throw new Error("<SegmentedButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strong(value) {
    throw new Error("<SegmentedButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<SegmentedButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<SegmentedButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<SegmentedButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<SegmentedButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clear() {
    throw new Error("<SegmentedButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clear(value) {
    throw new Error("<SegmentedButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SegmentedButton_default = SegmentedButton;

// node_modules/konsta/shared/esm/classes/SheetClasses.js
var SheetClasses = (props, colors, classes) => {
  return {
    base: {
      common: cls("left-0 top-full transition-transform duration-400 z-40 overflow-hidden", positionClass("fixed", classes)),
      ios: "",
      material: `rounded-t-2xl ease-material-in ${colors.bgIos}`,
      opened: `-translate-y-full ${colors.bgMaterial}`,
      closed: ""
    },
    backdrop: {
      common: "fixed z-40 w-full h-full left-0 top-0 bg-black bg-opacity-50 duration-400",
      opened: "",
      closed: "opacity-0 pointer-events-none"
    }
  };
};

// node_modules/konsta/shared/esm/colors/SheetColors.js
var SheetColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: cls("bg-white", dark("dark:bg-black")),
    bgMaterial: cls("bg-md-light-surface", dark("dark:bg-md-dark-surface")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Sheet.svelte
var file47 = "node_modules/konsta/svelte/components/Sheet.svelte";
function create_if_block25(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[2].backdrop[
        /*state*/
        ctx[3]
      ]);
      add_location(div, file47, 32, 2, 867);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*onBackdropClick*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*c, state*/
      12 && div_class_value !== (div_class_value = /*c*/
      ctx[2].backdrop[
        /*state*/
        ctx[3]
      ])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(32:0) {#if backdrop}",
    ctx
  });
  return block;
}
function create_fragment51(ctx) {
  let t;
  let div;
  let div_class_value;
  let current;
  let if_block = (
    /*backdrop*/
    ctx[0] && create_if_block25(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*c*/
      ctx[2].base[
        /*state*/
        ctx[3]
      ]
    },
    /*$$restProps*/
    ctx[4]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file47, 34, 0, 934);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*backdrop*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block25(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*c, state*/
        12 && div_class_value !== (div_class_value = /*c*/
        ctx2[2].base[
          /*state*/
          ctx2[3]
        ])) && { class: div_class_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let state;
  let colors;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "opened", "backdrop", "onBackdropClick"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sheet", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { opened = false } = $$props;
  let { backdrop = true } = $$props;
  let { onBackdropClick = void 0 } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(6, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(8, material = $$new_props.material);
    if ("opened" in $$new_props)
      $$invalidate(9, opened = $$new_props.opened);
    if ("backdrop" in $$new_props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$new_props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    SheetClasses,
    SheetColors,
    useDarkClasses,
    useThemeClasses,
    className,
    colorsProp,
    ios,
    material,
    opened,
    backdrop,
    onBackdropClick,
    dark,
    c,
    colors,
    state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(6, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(8, material = $$new_props.material);
    if ("opened" in $$props)
      $$invalidate(9, opened = $$new_props.opened);
    if ("backdrop" in $$props)
      $$invalidate(0, backdrop = $$new_props.backdrop);
    if ("onBackdropClick" in $$props)
      $$invalidate(1, onBackdropClick = $$new_props.onBackdropClick);
    if ("c" in $$props)
      $$invalidate(2, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(10, colors = $$new_props.colors);
    if ("state" in $$props)
      $$invalidate(3, state = $$new_props.state);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*opened*/
    512) {
      $:
        $$invalidate(3, state = opened ? "opened" : "closed");
    }
    if ($$self.$$.dirty & /*colorsProp*/
    64) {
      $:
        $$invalidate(10, colors = SheetColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    1440) {
      $:
        $$invalidate(2, c = useThemeClasses({ ios, material }, SheetClasses({}, colors, className), className, (v) => $$invalidate(2, c = v)));
    }
  };
  return [
    backdrop,
    onBackdropClick,
    c,
    state,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    opened,
    colors,
    $$scope,
    slots
  ];
}
var Sheet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, {
      class: 5,
      colors: 6,
      ios: 7,
      material: 8,
      opened: 9,
      backdrop: 0,
      onBackdropClick: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sheet",
      options,
      id: create_fragment51.name
    });
  }
  get class() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBackdropClick() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBackdropClick(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Sheet_default = Sheet;

// node_modules/konsta/shared/esm/classes/StepperClasses.js
var StepperClasses = (props, colors) => {
  const {
    buttonsOnly
  } = props;
  return {
    base: `${colors.text} inline-flex items-stretch`,
    raised: "shadow",
    size: {
      small: {
        ios: `h-6`,
        material: `h-8`
      },
      medium: {
        ios: `h-7`,
        material: `h-10`
      },
      large: {
        ios: `h-11`,
        material: `h-12`
      }
    },
    shape: {
      square: {
        ios: "rounded",
        material: "rounded-lg"
      },
      rounded: "rounded-full"
    },
    button: {
      common: "relative flex items-center justify-center w-10 cursor-pointer overflow-hidden z-10 select-none"
    },
    buttonLeftShape: {
      square: {
        ios: "rounded-l",
        material: "rounded-l-lg"
      },
      rounded: "rounded-l-full"
    },
    buttonRightShape: {
      square: {
        ios: "rounded-r",
        material: "rounded-r-lg"
      },
      rounded: "rounded-r-full"
    },
    buttonStyle: {
      fill: {
        common: cls(colors.fillTouchRipple, buttonsOnly && "first:border-r border-black border-opacity-10"),
        ios: cls(colors.fillBgIos, colors.fillTextIos, colors.fillActiveBgIos),
        material: cls(colors.fillBgMaterial, colors.fillTextMaterial, colors.fillActiveBgMaterial)
      },
      outline: {
        common: cls(colors.touchRipple, "active:bg-opacity-15", buttonsOnly && "first:border-r-0"),
        ios: cls("border-2", colors.textIos, colors.activeBgIos, colors.outlineBorderIos),
        material: cls("border", colors.textMaterial, colors.activeBgMaterial, colors.outlineBorderMaterial)
      },
      clear: {
        common: `${colors.touchRipple} active:bg-opacity-15 last:border-l border-black border-opacity-10`,
        ios: cls(colors.textIos, colors.activeBgIos),
        material: cls(colors.textMaterial, colors.activeBgMaterial)
      }
    },
    input: {
      common: "focus:outline-none text-center appearance-none bg-transparent"
    },
    value: {
      common: `w-11 flex items-center justify-center font-medium`,
      ios: `text-base ${colors.textIos}`,
      material: `text-sm ${colors.textMaterial}`,
      fill: {
        common: ``,
        ios: `border-t-2 border-b-2 ${colors.outlineBorderIos}`,
        material: `border-t border-b ${colors.outlineBorderMaterial}`
      },
      outline: {
        common: ``,
        ios: `border-t-2 border-b-2 ${colors.outlineBorderIos}`,
        material: `border-t border-b ${colors.outlineBorderMaterial}`
      },
      clear: "border-l border-black border-opacity-10"
    },
    hBar: "w-4 h-0.5 bg-current block",
    vBar: "w-0.5 h-4 bg-current block absolute inset-1/2 transform -translate-x-1/2 -translate-y-1/2"
  };
};

// node_modules/konsta/shared/esm/colors/StepperColors.js
var StepperColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    activeBgIos: "active:bg-primary",
    activeBgMaterial: "",
    textIos: "text-primary",
    textMaterial: cls("text-md-light-primary", "dark:text-md-dark-primary"),
    fillTextIos: cls("text-white"),
    fillTextMaterial: cls("text-md-light-on-primary", dark("dark:text-md-dark-on-primary")),
    fillBgIos: "bg-primary",
    fillBgMaterial: cls("bg-md-light-primary", dark("dark:bg-md-dark-primary")),
    fillActiveBgIos: "active:bg-ios-primary-shade",
    fillActiveBgMaterial: "",
    fillTouchRipple: cls("touch-ripple-white", "dark:touch-ripple-primary"),
    outlineBorderIos: "border-primary",
    outlineBorderMaterial: cls("border-md-light-outline", dark("dark:border-md-dark-outline")),
    touchRipple: "touch-ripple-primary",
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Stepper.svelte
var file48 = "node_modules/konsta/svelte/components/Stepper.svelte";
function create_if_block_116(ctx) {
  let input_1;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input_1 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input_1 = claim_element(nodes, "INPUT", {
        class: true,
        placeholder: true,
        type: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        input_1,
        "class",
        /*valueClasses*/
        ctx[17]
      );
      attr_dev(
        input_1,
        "placeholder",
        /*inputPlaceholder*/
        ctx[4]
      );
      attr_dev(
        input_1,
        "type",
        /*inputType*/
        ctx[3]
      );
      input_1.value = /*value*/
      ctx[1];
      input_1.disabled = /*inputDisabled*/
      ctx[5];
      input_1.readOnly = /*inputReadonly*/
      ctx[6];
      add_location(input_1, file48, 137, 4, 3666);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input_1, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            input_1,
            "input",
            function() {
              if (is_function(
                /*onInput*/
                ctx[8]
              ))
                ctx[8].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "change",
            function() {
              if (is_function(
                /*onChange*/
                ctx[9]
              ))
                ctx[9].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "focus",
            function() {
              if (is_function(
                /*onFocus*/
                ctx[10]
              ))
                ctx[10].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "blur",
            function() {
              if (is_function(
                /*onBlur*/
                ctx[11]
              ))
                ctx[11].apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*valueClasses*/
      131072) {
        attr_dev(
          input_1,
          "class",
          /*valueClasses*/
          ctx[17]
        );
      }
      if (dirty[0] & /*inputPlaceholder*/
      16) {
        attr_dev(
          input_1,
          "placeholder",
          /*inputPlaceholder*/
          ctx[4]
        );
      }
      if (dirty[0] & /*inputType*/
      8) {
        attr_dev(
          input_1,
          "type",
          /*inputType*/
          ctx[3]
        );
      }
      if (dirty[0] & /*value*/
      2 && input_1.value !== /*value*/
      ctx[1]) {
        prop_dev(
          input_1,
          "value",
          /*value*/
          ctx[1]
        );
      }
      if (dirty[0] & /*inputDisabled*/
      32) {
        prop_dev(
          input_1,
          "disabled",
          /*inputDisabled*/
          ctx[5]
        );
      }
      if (dirty[0] & /*inputReadonly*/
      64) {
        prop_dev(
          input_1,
          "readOnly",
          /*inputReadonly*/
          ctx[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input_1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: "(137:2) {#if input && !buttonsOnly}",
    ctx
  });
  return block;
}
function create_if_block26(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*value*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*value*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span,
        "class",
        /*valueClasses*/
        ctx[17]
      );
      add_location(span, file48, 151, 4, 3986);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value*/
      2)
        set_data_dev(
          t,
          /*value*/
          ctx2[1]
        );
      if (dirty[0] & /*valueClasses*/
      131072) {
        attr_dev(
          span,
          "class",
          /*valueClasses*/
          ctx2[17]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(151:2) {#if !input && !buttonsOnly}",
    ctx
  });
  return block;
}
function create_dynamic_element12(ctx) {
  let svelte_element;
  let span1;
  let span0;
  let span0_class_value;
  let t0;
  let t1;
  let t2;
  let span4;
  let span2;
  let span2_class_value;
  let t3;
  let span3;
  let span3_class_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*input*/
    ctx[2] && !/*buttonsOnly*/
    ctx[7] && create_if_block_116(ctx)
  );
  let if_block1 = !/*input*/
  ctx[2] && !/*buttonsOnly*/
  ctx[7] && create_if_block26(ctx);
  let svelte_element_levels = [
    { class: (
      /*classes*/
      ctx[20]
    ) },
    /*$$restProps*/
    ctx[21]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[0]
      );
      span1 = element("span");
      span0 = element("span");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      span4 = element("span");
      span2 = element("span");
      t3 = space();
      span3 = element("span");
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[0] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      span1 = claim_element(svelte_element_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      t0 = claim_space(svelte_element_nodes);
      if (if_block0)
        if_block0.l(svelte_element_nodes);
      t1 = claim_space(svelte_element_nodes);
      if (if_block1)
        if_block1.l(svelte_element_nodes);
      t2 = claim_space(svelte_element_nodes);
      span4 = claim_element(svelte_element_nodes, "SPAN", { class: true });
      var span4_nodes = children(span4);
      span2 = claim_element(span4_nodes, "SPAN", { class: true });
      children(span2).forEach(detach_dev);
      t3 = claim_space(span4_nodes);
      span3 = claim_element(span4_nodes, "SPAN", { class: true });
      children(span3).forEach(detach_dev);
      span4_nodes.forEach(detach_dev);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = /*c*/
      ctx[14].hBar);
      add_location(span0, file48, 134, 4, 3598);
      attr_dev(
        span1,
        "class",
        /*buttonLeftClasses*/
        ctx[19]
      );
      add_location(span1, file48, 129, 2, 3494);
      attr_dev(span2, "class", span2_class_value = /*c*/
      ctx[14].hBar);
      add_location(span2, file48, 159, 4, 4144);
      attr_dev(span3, "class", span3_class_value = /*c*/
      ctx[14].vBar);
      add_location(span3, file48, 160, 4, 4172);
      attr_dev(
        span4,
        "class",
        /*buttonRightClasses*/
        ctx[18]
      );
      add_location(span4, file48, 154, 2, 4039);
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file48, 128, 0, 3425);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, span1);
      append_hydration_dev(span1, span0);
      ctx[52](span1);
      append_hydration_dev(svelte_element, t0);
      if (if_block0)
        if_block0.m(svelte_element, null);
      append_hydration_dev(svelte_element, t1);
      if (if_block1)
        if_block1.m(svelte_element, null);
      append_hydration_dev(svelte_element, t2);
      append_hydration_dev(svelte_element, span4);
      append_hydration_dev(span4, span2);
      append_hydration_dev(span4, t3);
      append_hydration_dev(span4, span3);
      ctx[53](span4);
      if (!mounted) {
        dispose = [
          listen_dev(
            span1,
            "click",
            function() {
              if (is_function(
                /*onMinus*/
                ctx[12]
              ))
                ctx[12].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            span4,
            "click",
            function() {
              if (is_function(
                /*onPlus*/
                ctx[13]
              ))
                ctx[13].apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*c*/
      16384 && span0_class_value !== (span0_class_value = /*c*/
      ctx[14].hBar)) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (dirty[0] & /*buttonLeftClasses*/
      524288) {
        attr_dev(
          span1,
          "class",
          /*buttonLeftClasses*/
          ctx[19]
        );
      }
      if (
        /*input*/
        ctx[2] && !/*buttonsOnly*/
        ctx[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_116(ctx);
          if_block0.c();
          if_block0.m(svelte_element, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*input*/
      ctx[2] && !/*buttonsOnly*/
      ctx[7]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block26(ctx);
          if_block1.c();
          if_block1.m(svelte_element, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*c*/
      16384 && span2_class_value !== (span2_class_value = /*c*/
      ctx[14].hBar)) {
        attr_dev(span2, "class", span2_class_value);
      }
      if (dirty[0] & /*c*/
      16384 && span3_class_value !== (span3_class_value = /*c*/
      ctx[14].vBar)) {
        attr_dev(span3, "class", span3_class_value);
      }
      if (dirty[0] & /*buttonRightClasses*/
      262144) {
        attr_dev(
          span4,
          "class",
          /*buttonRightClasses*/
          ctx[18]
        );
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        dirty[0] & /*classes*/
        1048576 && { class: (
          /*classes*/
          ctx[20]
        ) },
        dirty[0] & /*$$restProps*/
        2097152 && /*$$restProps*/
        ctx[21]
      ]);
      if (/-/.test(
        /*component*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      ctx[52](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[53](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element12.name,
    type: "child_dynamic_element",
    source: "(129:0) <svelte:element this={component} class={classes} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment52(ctx) {
  let previous_tag = (
    /*component*/
    ctx[0]
  );
  let svelte_element_anchor;
  validate_dynamic_element(
    /*component*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[0]
  );
  let svelte_element = (
    /*component*/
    ctx[0] && create_dynamic_element12(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*component*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element12(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element12(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[0];
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let isRounded;
  let isSmall;
  let isLarge;
  let isRaised;
  let isOutline;
  let colors;
  let size;
  let style;
  let shape;
  let c;
  let classes;
  let buttonLeftClasses;
  let buttonRightClasses;
  let valueClasses;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "component",
    "value",
    "input",
    "inputType",
    "inputPlaceholder",
    "inputDisabled",
    "inputReadonly",
    "buttonsOnly",
    "rounded",
    "roundedIos",
    "roundedMaterial",
    "small",
    "smallIos",
    "smallMaterial",
    "large",
    "largeIos",
    "largeMaterial",
    "raised",
    "raisedIos",
    "raisedMaterial",
    "outline",
    "outlineIos",
    "outlineMaterial",
    "onInput",
    "onChange",
    "onFocus",
    "onBlur",
    "onMinus",
    "onPlus",
    "touchRipple"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stepper", slots, []);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { component = "span" } = $$props;
  let { value = 0 } = $$props;
  let { input = false } = $$props;
  let { inputType = "text" } = $$props;
  let { inputPlaceholder = void 0 } = $$props;
  let { inputDisabled = false } = $$props;
  let { inputReadonly = false } = $$props;
  let { buttonsOnly = false } = $$props;
  let { rounded = void 0 } = $$props;
  let { roundedIos = void 0 } = $$props;
  let { roundedMaterial = void 0 } = $$props;
  let { small = void 0 } = $$props;
  let { smallIos = void 0 } = $$props;
  let { smallMaterial = void 0 } = $$props;
  let { large = void 0 } = $$props;
  let { largeIos = void 0 } = $$props;
  let { largeMaterial = void 0 } = $$props;
  let { raised = void 0 } = $$props;
  let { raisedIos = void 0 } = $$props;
  let { raisedMaterial = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { outlineIos = void 0 } = $$props;
  let { outlineMaterial = void 0 } = $$props;
  let { onInput = void 0 } = $$props;
  let { onChange = void 0 } = $$props;
  let { onFocus = void 0 } = $$props;
  let { onBlur = void 0 } = $$props;
  let { onMinus = void 0 } = $$props;
  let { onPlus = void 0 } = $$props;
  let { touchRipple = true } = $$props;
  let theme;
  theme = useTheme({}, (v) => $$invalidate(42, theme = v));
  const buttonLeftEl = { current: null };
  const buttonRightEl = { current: null };
  useTouchRipple(buttonLeftEl, touchRipple);
  useTouchRipple(buttonRightEl, touchRipple);
  const dark = useDarkClasses();
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonLeftEl.current = $$value;
      $$invalidate(15, buttonLeftEl);
    });
  }
  function span4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonRightEl.current = $$value;
      $$invalidate(16, buttonRightEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(22, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(23, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(24, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(25, material = $$new_props.material);
    if ("component" in $$new_props)
      $$invalidate(0, component = $$new_props.component);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("input" in $$new_props)
      $$invalidate(2, input = $$new_props.input);
    if ("inputType" in $$new_props)
      $$invalidate(3, inputType = $$new_props.inputType);
    if ("inputPlaceholder" in $$new_props)
      $$invalidate(4, inputPlaceholder = $$new_props.inputPlaceholder);
    if ("inputDisabled" in $$new_props)
      $$invalidate(5, inputDisabled = $$new_props.inputDisabled);
    if ("inputReadonly" in $$new_props)
      $$invalidate(6, inputReadonly = $$new_props.inputReadonly);
    if ("buttonsOnly" in $$new_props)
      $$invalidate(7, buttonsOnly = $$new_props.buttonsOnly);
    if ("rounded" in $$new_props)
      $$invalidate(26, rounded = $$new_props.rounded);
    if ("roundedIos" in $$new_props)
      $$invalidate(27, roundedIos = $$new_props.roundedIos);
    if ("roundedMaterial" in $$new_props)
      $$invalidate(28, roundedMaterial = $$new_props.roundedMaterial);
    if ("small" in $$new_props)
      $$invalidate(29, small = $$new_props.small);
    if ("smallIos" in $$new_props)
      $$invalidate(30, smallIos = $$new_props.smallIos);
    if ("smallMaterial" in $$new_props)
      $$invalidate(31, smallMaterial = $$new_props.smallMaterial);
    if ("large" in $$new_props)
      $$invalidate(32, large = $$new_props.large);
    if ("largeIos" in $$new_props)
      $$invalidate(33, largeIos = $$new_props.largeIos);
    if ("largeMaterial" in $$new_props)
      $$invalidate(34, largeMaterial = $$new_props.largeMaterial);
    if ("raised" in $$new_props)
      $$invalidate(35, raised = $$new_props.raised);
    if ("raisedIos" in $$new_props)
      $$invalidate(36, raisedIos = $$new_props.raisedIos);
    if ("raisedMaterial" in $$new_props)
      $$invalidate(37, raisedMaterial = $$new_props.raisedMaterial);
    if ("outline" in $$new_props)
      $$invalidate(38, outline = $$new_props.outline);
    if ("outlineIos" in $$new_props)
      $$invalidate(39, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$new_props)
      $$invalidate(40, outlineMaterial = $$new_props.outlineMaterial);
    if ("onInput" in $$new_props)
      $$invalidate(8, onInput = $$new_props.onInput);
    if ("onChange" in $$new_props)
      $$invalidate(9, onChange = $$new_props.onChange);
    if ("onFocus" in $$new_props)
      $$invalidate(10, onFocus = $$new_props.onFocus);
    if ("onBlur" in $$new_props)
      $$invalidate(11, onBlur = $$new_props.onBlur);
    if ("onMinus" in $$new_props)
      $$invalidate(12, onMinus = $$new_props.onMinus);
    if ("onPlus" in $$new_props)
      $$invalidate(13, onPlus = $$new_props.onPlus);
    if ("touchRipple" in $$new_props)
      $$invalidate(41, touchRipple = $$new_props.touchRipple);
  };
  $$self.$capture_state = () => ({
    cls,
    useThemeClasses,
    useTheme,
    useDarkClasses,
    useTouchRipple,
    StepperClasses,
    StepperColors,
    className,
    colorsProp,
    ios,
    material,
    component,
    value,
    input,
    inputType,
    inputPlaceholder,
    inputDisabled,
    inputReadonly,
    buttonsOnly,
    rounded,
    roundedIos,
    roundedMaterial,
    small,
    smallIos,
    smallMaterial,
    large,
    largeIos,
    largeMaterial,
    raised,
    raisedIos,
    raisedMaterial,
    outline,
    outlineIos,
    outlineMaterial,
    onInput,
    onChange,
    onFocus,
    onBlur,
    onMinus,
    onPlus,
    touchRipple,
    theme,
    buttonLeftEl,
    buttonRightEl,
    dark,
    style,
    c,
    valueClasses,
    shape,
    buttonRightClasses,
    buttonLeftClasses,
    size,
    isRaised,
    classes,
    colors,
    isRounded,
    isOutline,
    isSmall,
    isLarge
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(22, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(23, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(24, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(25, material = $$new_props.material);
    if ("component" in $$props)
      $$invalidate(0, component = $$new_props.component);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("input" in $$props)
      $$invalidate(2, input = $$new_props.input);
    if ("inputType" in $$props)
      $$invalidate(3, inputType = $$new_props.inputType);
    if ("inputPlaceholder" in $$props)
      $$invalidate(4, inputPlaceholder = $$new_props.inputPlaceholder);
    if ("inputDisabled" in $$props)
      $$invalidate(5, inputDisabled = $$new_props.inputDisabled);
    if ("inputReadonly" in $$props)
      $$invalidate(6, inputReadonly = $$new_props.inputReadonly);
    if ("buttonsOnly" in $$props)
      $$invalidate(7, buttonsOnly = $$new_props.buttonsOnly);
    if ("rounded" in $$props)
      $$invalidate(26, rounded = $$new_props.rounded);
    if ("roundedIos" in $$props)
      $$invalidate(27, roundedIos = $$new_props.roundedIos);
    if ("roundedMaterial" in $$props)
      $$invalidate(28, roundedMaterial = $$new_props.roundedMaterial);
    if ("small" in $$props)
      $$invalidate(29, small = $$new_props.small);
    if ("smallIos" in $$props)
      $$invalidate(30, smallIos = $$new_props.smallIos);
    if ("smallMaterial" in $$props)
      $$invalidate(31, smallMaterial = $$new_props.smallMaterial);
    if ("large" in $$props)
      $$invalidate(32, large = $$new_props.large);
    if ("largeIos" in $$props)
      $$invalidate(33, largeIos = $$new_props.largeIos);
    if ("largeMaterial" in $$props)
      $$invalidate(34, largeMaterial = $$new_props.largeMaterial);
    if ("raised" in $$props)
      $$invalidate(35, raised = $$new_props.raised);
    if ("raisedIos" in $$props)
      $$invalidate(36, raisedIos = $$new_props.raisedIos);
    if ("raisedMaterial" in $$props)
      $$invalidate(37, raisedMaterial = $$new_props.raisedMaterial);
    if ("outline" in $$props)
      $$invalidate(38, outline = $$new_props.outline);
    if ("outlineIos" in $$props)
      $$invalidate(39, outlineIos = $$new_props.outlineIos);
    if ("outlineMaterial" in $$props)
      $$invalidate(40, outlineMaterial = $$new_props.outlineMaterial);
    if ("onInput" in $$props)
      $$invalidate(8, onInput = $$new_props.onInput);
    if ("onChange" in $$props)
      $$invalidate(9, onChange = $$new_props.onChange);
    if ("onFocus" in $$props)
      $$invalidate(10, onFocus = $$new_props.onFocus);
    if ("onBlur" in $$props)
      $$invalidate(11, onBlur = $$new_props.onBlur);
    if ("onMinus" in $$props)
      $$invalidate(12, onMinus = $$new_props.onMinus);
    if ("onPlus" in $$props)
      $$invalidate(13, onPlus = $$new_props.onPlus);
    if ("touchRipple" in $$props)
      $$invalidate(41, touchRipple = $$new_props.touchRipple);
    if ("theme" in $$props)
      $$invalidate(42, theme = $$new_props.theme);
    if ("style" in $$props)
      $$invalidate(43, style = $$new_props.style);
    if ("c" in $$props)
      $$invalidate(14, c = $$new_props.c);
    if ("valueClasses" in $$props)
      $$invalidate(17, valueClasses = $$new_props.valueClasses);
    if ("shape" in $$props)
      $$invalidate(44, shape = $$new_props.shape);
    if ("buttonRightClasses" in $$props)
      $$invalidate(18, buttonRightClasses = $$new_props.buttonRightClasses);
    if ("buttonLeftClasses" in $$props)
      $$invalidate(19, buttonLeftClasses = $$new_props.buttonLeftClasses);
    if ("size" in $$props)
      $$invalidate(45, size = $$new_props.size);
    if ("isRaised" in $$props)
      $$invalidate(46, isRaised = $$new_props.isRaised);
    if ("classes" in $$props)
      $$invalidate(20, classes = $$new_props.classes);
    if ("colors" in $$props)
      $$invalidate(47, colors = $$new_props.colors);
    if ("isRounded" in $$props)
      $$invalidate(48, isRounded = $$new_props.isRounded);
    if ("isOutline" in $$props)
      $$invalidate(49, isOutline = $$new_props.isOutline);
    if ("isSmall" in $$props)
      $$invalidate(50, isSmall = $$new_props.isSmall);
    if ("isLarge" in $$props)
      $$invalidate(51, isLarge = $$new_props.isLarge);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*rounded, roundedIos, roundedMaterial*/
    469762048 | $$self.$$.dirty[1] & /*theme*/
    2048) {
      $:
        $$invalidate(48, isRounded = typeof rounded === "undefined" ? theme === "ios" ? roundedIos : roundedMaterial : rounded);
    }
    if ($$self.$$.dirty[0] & /*small, smallIos*/
    1610612736 | $$self.$$.dirty[1] & /*theme, smallMaterial*/
    2049) {
      $:
        $$invalidate(50, isSmall = typeof small === "undefined" ? theme === "ios" ? smallIos : smallMaterial : small);
    }
    if ($$self.$$.dirty[1] & /*large, theme, largeIos, largeMaterial*/
    2062) {
      $:
        $$invalidate(51, isLarge = typeof large === "undefined" ? theme === "ios" ? largeIos : largeMaterial : large);
    }
    if ($$self.$$.dirty[1] & /*raised, theme, raisedIos, raisedMaterial*/
    2160) {
      $:
        $$invalidate(46, isRaised = typeof raised === "undefined" ? theme === "ios" ? raisedIos : raisedMaterial : raised);
    }
    if ($$self.$$.dirty[1] & /*outline, theme, outlineIos, outlineMaterial*/
    2944) {
      $:
        $$invalidate(49, isOutline = typeof outline === "undefined" ? theme === "ios" ? outlineIos : outlineMaterial : outline);
    }
    if ($$self.$$.dirty[0] & /*colorsProp*/
    8388608) {
      $:
        $$invalidate(47, colors = StepperColors(colorsProp, dark));
    }
    if ($$self.$$.dirty[1] & /*isLarge, isSmall*/
    1572864) {
      $:
        $$invalidate(45, size = isLarge ? "large" : isSmall ? "small" : "medium");
    }
    if ($$self.$$.dirty[1] & /*isOutline, isRaised*/
    294912) {
      $:
        $$invalidate(43, style = isOutline && isRaised ? "clear" : isOutline ? "outline" : "fill");
    }
    if ($$self.$$.dirty[1] & /*isRounded*/
    131072) {
      $:
        $$invalidate(44, shape = isRounded ? "rounded" : "square");
    }
    if ($$self.$$.dirty[0] & /*ios, material, buttonsOnly*/
    50331776 | $$self.$$.dirty[1] & /*colors*/
    65536) {
      $:
        $$invalidate(14, c = useThemeClasses({ ios, material }, StepperClasses({ buttonsOnly }, colors), "", (v) => $$invalidate(14, c = v)));
    }
    if ($$self.$$.dirty[0] & /*c, className*/
    4210688 | $$self.$$.dirty[1] & /*isRaised, size, shape*/
    57344) {
      $:
        $$invalidate(20, classes = cls(c.base, isRaised && c.raised, c.size[size], c.shape[shape], className));
    }
    if ($$self.$$.dirty[0] & /*c*/
    16384 | $$self.$$.dirty[1] & /*style, shape*/
    12288) {
      $:
        $$invalidate(19, buttonLeftClasses = cls(c.button, c.buttonStyle[style], c.buttonLeftShape[shape]));
    }
    if ($$self.$$.dirty[0] & /*c*/
    16384 | $$self.$$.dirty[1] & /*style, shape*/
    12288) {
      $:
        $$invalidate(18, buttonRightClasses = cls(c.button, c.buttonStyle[style], c.buttonRightShape[shape]));
    }
    if ($$self.$$.dirty[0] & /*input, c*/
    16388 | $$self.$$.dirty[1] & /*style*/
    4096) {
      $:
        $$invalidate(17, valueClasses = cls(input && c.input, c.value[style]));
    }
  };
  return [
    component,
    value,
    input,
    inputType,
    inputPlaceholder,
    inputDisabled,
    inputReadonly,
    buttonsOnly,
    onInput,
    onChange,
    onFocus,
    onBlur,
    onMinus,
    onPlus,
    c,
    buttonLeftEl,
    buttonRightEl,
    valueClasses,
    buttonRightClasses,
    buttonLeftClasses,
    classes,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    rounded,
    roundedIos,
    roundedMaterial,
    small,
    smallIos,
    smallMaterial,
    large,
    largeIos,
    largeMaterial,
    raised,
    raisedIos,
    raisedMaterial,
    outline,
    outlineIos,
    outlineMaterial,
    touchRipple,
    theme,
    style,
    shape,
    size,
    isRaised,
    colors,
    isRounded,
    isOutline,
    isSmall,
    isLarge,
    span1_binding,
    span4_binding
  ];
}
var Stepper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance52,
      create_fragment52,
      safe_not_equal,
      {
        class: 22,
        colors: 23,
        ios: 24,
        material: 25,
        component: 0,
        value: 1,
        input: 2,
        inputType: 3,
        inputPlaceholder: 4,
        inputDisabled: 5,
        inputReadonly: 6,
        buttonsOnly: 7,
        rounded: 26,
        roundedIos: 27,
        roundedMaterial: 28,
        small: 29,
        smallIos: 30,
        smallMaterial: 31,
        large: 32,
        largeIos: 33,
        largeMaterial: 34,
        raised: 35,
        raisedIos: 36,
        raisedMaterial: 37,
        outline: 38,
        outlineIos: 39,
        outlineMaterial: 40,
        onInput: 8,
        onChange: 9,
        onFocus: 10,
        onBlur: 11,
        onMinus: 12,
        onPlus: 13,
        touchRipple: 41
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stepper",
      options,
      id: create_fragment52.name
    });
  }
  get class() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputType() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputType(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputPlaceholder() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputPlaceholder(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputDisabled() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputDisabled(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputReadonly() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputReadonly(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonsOnly() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonsOnly(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundedIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundedIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundedMaterial() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundedMaterial(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallMaterial() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallMaterial(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get large() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeMaterial() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeMaterial(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raised() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raised(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedMaterial() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedMaterial(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineMaterial() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineMaterial(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onInput() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onInput(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onFocus() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onFocus(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBlur() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBlur(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMinus() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMinus(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPlus() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPlus(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Stepper_default = Stepper;

// node_modules/konsta/shared/esm/classes/ToolbarClasses.js
var ToolbarClasses = (props, colors, classes) => {
  const {
    bgClassName = "",
    bgClass = "",
    outline,
    translucent,
    innerClassName = "",
    innerClass = "",
    tabbar,
    tabbarIcons,
    top
  } = props;
  return {
    base: {
      common: cls(`w-full z-20`, positionClass("relative", classes), !top && "pb-safe")
    },
    bg: {
      common: cls("absolute w-full h-full left-0 top-0", outline && (top ? "hairline-b" : "hairline-t"), bgClassName || bgClass),
      ios: cls(colors.bgIos, translucent && "translucent"),
      material: cls(`${colors.bgMaterial}`)
    },
    inner: {
      common: cls(`flex relative justify-between items-center w-full overflow-hidden`, innerClassName || innerClass),
      ios: cls("pl-2-safe pr-2-safe", tabbarIcons ? "h-12.5" : "h-11"),
      material: cls(!tabbar ? "pl-2-safe pr-2-safe" : "", tabbarIcons ? "h-20" : "h-14")
    },
    highlight: {
      common: cls(top ? "bottom-0" : "top-0", "absolute left-0 w-full h-0.5 duration-200 pointer-events-none transition-transform"),
      ios: colors.tabbarHighlightBgIos,
      material: colors.tabbarHighlightBgMaterial
    }
  };
};

// node_modules/konsta/shared/esm/colors/ToolbarColors.js
var ToolbarColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: cls("bg-ios-light-surface-2", dark("dark:bg-ios-dark-surface-2")),
    bgMaterial: cls("bg-md-light-surface-2", dark("dark:bg-md-dark-surface-2")),
    tabbarHighlightBgIos: "bg-primary",
    tabbarHighlightBgMaterial: cls("bg-md-light-primary", dark("dark:bg-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Toolbar.svelte
var file49 = "node_modules/konsta/svelte/components/Toolbar.svelte";
function create_if_block27(ctx) {
  let span;
  let span_class_value;
  let span_style_value;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[2].highlight);
      attr_dev(span, "style", span_style_value = `width: ${/*highlightStyle*/
      ctx[1].width} ; transform: ${/*highlightStyle*/
      ctx[1].transform}`);
      add_location(span, file49, 97, 4, 2392);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      ctx[22](span);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*c*/
      4 && span_class_value !== (span_class_value = /*c*/
      ctx2[2].highlight)) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty & /*highlightStyle*/
      2 && span_style_value !== (span_style_value = `width: ${/*highlightStyle*/
      ctx2[1].width} ; transform: ${/*highlightStyle*/
      ctx2[1].transform}`)) {
        attr_dev(span, "style", span_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(97:2) {#if hasHighlight}",
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let div2;
  let div0;
  let div0_class_value;
  let t0;
  let div1;
  let div1_class_value;
  let t1;
  let div2_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  let if_block = (
    /*hasHighlight*/
    ctx[3] && create_if_block27(ctx)
  );
  let div2_levels = [
    {
      class: div2_class_value = /*c*/
      ctx[2].base
    },
    /*$$restProps*/
    ctx[4]
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*c*/
      ctx[2].bg);
      add_location(div0, file49, 92, 2, 2300);
      attr_dev(div1, "class", div1_class_value = /*c*/
      ctx[2].inner);
      add_location(div1, file49, 93, 2, 2323);
      set_attributes(div2, div2_data);
      add_location(div2, file49, 91, 0, 2260);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div2, t1);
      if (if_block)
        if_block.m(div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*c*/
      4 && div0_class_value !== (div0_class_value = /*c*/
      ctx2[2].bg)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*c*/
      4 && div1_class_value !== (div1_class_value = /*c*/
      ctx2[2].inner)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (
        /*hasHighlight*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block27(ctx2);
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty & /*c*/
        4 && div2_class_value !== (div2_class_value = /*c*/
        ctx2[2].base)) && { class: div2_class_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let isOutline;
  let hasHighlight;
  let colors;
  let c;
  const omit_props_names = [
    "class",
    "colors",
    "ios",
    "material",
    "translucent",
    "bgClass",
    "innerClass",
    "outline",
    "tabbar",
    "tabbarLabels",
    "tabbarIcons",
    "top"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toolbar", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { translucent = true } = $$props;
  let { bgClass = "" } = $$props;
  let { innerClass = "" } = $$props;
  let { outline = void 0 } = $$props;
  let { tabbar = false } = $$props;
  let { tabbarLabels = false } = $$props;
  let { tabbarIcons = false } = $$props;
  let { top = false } = $$props;
  let highlightElRef = null;
  let theme;
  theme = useTheme({ ios, material }, (v) => $$invalidate(17, theme = v));
  let highlightStyle = { transform: "", width: "" };
  const setHighlight = () => {
    if (hasHighlight && highlightElRef) {
      const linksEl = highlightElRef.previousElementSibling;
      const activeIndex = [...linksEl.children].indexOf(linksEl.querySelector(".k-tabbar-link-active"));
      const width = `${1 / linksEl.children.length * 100}%`;
      const transform = `translateX(${activeIndex * 100}%)`;
      if (width !== highlightStyle.width || transform !== highlightStyle.transform) {
        $$invalidate(1, highlightStyle = { ...highlightStyle, width, transform });
      }
    }
  };
  onMount(() => setHighlight());
  afterUpdate(() => setHighlight());
  const dark = useDarkClasses();
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      highlightElRef = $$value;
      $$invalidate(0, highlightElRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(6, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(8, material = $$new_props.material);
    if ("translucent" in $$new_props)
      $$invalidate(9, translucent = $$new_props.translucent);
    if ("bgClass" in $$new_props)
      $$invalidate(10, bgClass = $$new_props.bgClass);
    if ("innerClass" in $$new_props)
      $$invalidate(11, innerClass = $$new_props.innerClass);
    if ("outline" in $$new_props)
      $$invalidate(12, outline = $$new_props.outline);
    if ("tabbar" in $$new_props)
      $$invalidate(13, tabbar = $$new_props.tabbar);
    if ("tabbarLabels" in $$new_props)
      $$invalidate(14, tabbarLabels = $$new_props.tabbarLabels);
    if ("tabbarIcons" in $$new_props)
      $$invalidate(15, tabbarIcons = $$new_props.tabbarIcons);
    if ("top" in $$new_props)
      $$invalidate(16, top = $$new_props.top);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    afterUpdate,
    useTheme,
    useThemeClasses,
    useDarkClasses,
    ToolbarClasses,
    ToolbarColors,
    className,
    colorsProp,
    ios,
    material,
    translucent,
    bgClass,
    innerClass,
    outline,
    tabbar,
    tabbarLabels,
    tabbarIcons,
    top,
    highlightElRef,
    theme,
    highlightStyle,
    setHighlight,
    dark,
    c,
    colors,
    isOutline,
    hasHighlight
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(6, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(7, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(8, material = $$new_props.material);
    if ("translucent" in $$props)
      $$invalidate(9, translucent = $$new_props.translucent);
    if ("bgClass" in $$props)
      $$invalidate(10, bgClass = $$new_props.bgClass);
    if ("innerClass" in $$props)
      $$invalidate(11, innerClass = $$new_props.innerClass);
    if ("outline" in $$props)
      $$invalidate(12, outline = $$new_props.outline);
    if ("tabbar" in $$props)
      $$invalidate(13, tabbar = $$new_props.tabbar);
    if ("tabbarLabels" in $$props)
      $$invalidate(14, tabbarLabels = $$new_props.tabbarLabels);
    if ("tabbarIcons" in $$props)
      $$invalidate(15, tabbarIcons = $$new_props.tabbarIcons);
    if ("top" in $$props)
      $$invalidate(16, top = $$new_props.top);
    if ("highlightElRef" in $$props)
      $$invalidate(0, highlightElRef = $$new_props.highlightElRef);
    if ("theme" in $$props)
      $$invalidate(17, theme = $$new_props.theme);
    if ("highlightStyle" in $$props)
      $$invalidate(1, highlightStyle = $$new_props.highlightStyle);
    if ("c" in $$props)
      $$invalidate(2, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(18, colors = $$new_props.colors);
    if ("isOutline" in $$props)
      $$invalidate(19, isOutline = $$new_props.isOutline);
    if ("hasHighlight" in $$props)
      $$invalidate(3, hasHighlight = $$new_props.hasHighlight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*outline, theme*/
    135168) {
      $:
        $$invalidate(19, isOutline = typeof outline === "undefined" ? theme === "ios" : outline);
    }
    if ($$self.$$.dirty & /*theme, tabbar, tabbarIcons*/
    172032) {
      $:
        $$invalidate(3, hasHighlight = theme === "material" && tabbar && !tabbarIcons);
    }
    if ($$self.$$.dirty & /*colorsProp*/
    64) {
      $:
        $$invalidate(18, colors = ToolbarColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, isOutline, translucent, bgClass, innerClass, tabbar, top, tabbarIcons, tabbarLabels, colors, className*/
    913312) {
      $:
        $$invalidate(2, c = useThemeClasses(
          { ios, material },
          ToolbarClasses(
            {
              outline: isOutline,
              translucent,
              bgClass,
              innerClass,
              tabbar,
              top,
              tabbarIcons,
              tabbarLabels
            },
            colors,
            className
          ),
          className,
          (v) => $$invalidate(2, c = v)
        ));
    }
  };
  return [
    highlightElRef,
    highlightStyle,
    c,
    hasHighlight,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    translucent,
    bgClass,
    innerClass,
    outline,
    tabbar,
    tabbarLabels,
    tabbarIcons,
    top,
    theme,
    colors,
    isOutline,
    $$scope,
    slots,
    span_binding
  ];
}
var Toolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, {
      class: 5,
      colors: 6,
      ios: 7,
      material: 8,
      translucent: 9,
      bgClass: 10,
      innerClass: 11,
      outline: 12,
      tabbar: 13,
      tabbarLabels: 14,
      tabbarIcons: 15,
      top: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toolbar",
      options,
      id: create_fragment53.name
    });
  }
  get class() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translucent() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translucent(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgClass() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgClass(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerClass() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerClass(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabbar() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabbar(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabbarLabels() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabbarLabels(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabbarIcons() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabbarIcons(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toolbar_default = Toolbar;

// node_modules/konsta/svelte/components/Tabbar.svelte
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: "(8:0) <Toolbar tabbar tabbarLabels={labels} tabbarIcons={icons} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let toolbar;
  let current;
  const toolbar_spread_levels = [
    { tabbar: true },
    { tabbarLabels: (
      /*labels*/
      ctx[0]
    ) },
    { tabbarIcons: (
      /*icons*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[2]
  ];
  let toolbar_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < toolbar_spread_levels.length; i += 1) {
    toolbar_props = assign(toolbar_props, toolbar_spread_levels[i]);
  }
  toolbar = new Toolbar_default({ props: toolbar_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(toolbar.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toolbar.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toolbar, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const toolbar_changes = dirty & /*labels, icons, $$restProps*/
      7 ? get_spread_update(toolbar_spread_levels, [
        toolbar_spread_levels[0],
        dirty & /*labels*/
        1 && { tabbarLabels: (
          /*labels*/
          ctx2[0]
        ) },
        dirty & /*icons*/
        2 && { tabbarIcons: (
          /*icons*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx2[2]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      16) {
        toolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toolbar.$set(toolbar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toolbar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  const omit_props_names = ["labels", "icons"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabbar", slots, ["default"]);
  let { labels = false } = $$props;
  let { icons = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("labels" in $$new_props)
      $$invalidate(0, labels = $$new_props.labels);
    if ("icons" in $$new_props)
      $$invalidate(1, icons = $$new_props.icons);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Toolbar: Toolbar_default, labels, icons });
  $$self.$inject_state = ($$new_props) => {
    if ("labels" in $$props)
      $$invalidate(0, labels = $$new_props.labels);
    if ("icons" in $$props)
      $$invalidate(1, icons = $$new_props.icons);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [labels, icons, $$restProps, slots, $$scope];
}
var Tabbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, { labels: 0, icons: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabbar",
      options,
      id: create_fragment54.name
    });
  }
  get labels() {
    throw new Error("<Tabbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labels(value) {
    throw new Error("<Tabbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icons() {
    throw new Error("<Tabbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons(value) {
    throw new Error("<Tabbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tabbar_default = Tabbar;

// node_modules/konsta/shared/esm/classes/TabbarLinkClasses.js
var TabbarLinkClasses = function(_temp, colors) {
  let {
    hasIcon,
    hasLabel,
    active
  } = _temp === void 0 ? {} : _temp;
  if (colors === void 0) {
    colors = {};
  }
  return {
    content: {
      common: "flex flex-col items-center justify-center h-full",
      ios: cls("py-1", active ? colors.textActiveIos : colors.textIos),
      material: cls("py-2", hasIcon && hasLabel && "space-y-1", active ? colors.textActiveMaterial : colors.textMaterial)
    },
    iconContainer: {
      common: "flex items-center justify-center k-tabbar-link-icon relative",
      ios: cls("w-7 h-7"),
      material: cls("w-16 h-8 rounded-full")
    },
    iconBg: {
      common: "absolute left-0 top-0 w-full h-full rounded-full duration-200 -z-10 pointer-events-none",
      ios: cls(active ? colors.iconBgActiveIos : colors.iconBgIos),
      material: cls(active ? colors.iconBgActiveMaterial : colors.iconBgMaterial, !active && "scale-x-[0.5] opacity-0")
    },
    label: {
      ios: cls(hasIcon ? "text-xs font-medium" : "", ""),
      material: cls(hasIcon ? "text-xs" : "text-sm", "font-medium")
    }
  };
};

// node_modules/konsta/shared/esm/colors/TabbarLinkColors.js
var TabbarLinkColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    textIos: cls("text-black text-opacity-40", dark("dark:text-white dark:text-opacity-55")),
    textActiveIos: "text-primary",
    textMaterial: cls("text-md-light-on-surface-variant", dark("dark:text-md-dark-on-surface-variant")),
    textActiveMaterial: cls("text-md-light-on-secondary-container", dark("dark:text-md-dark-on-secondary-container")),
    iconBgIos: "",
    iconBgActiveIos: "",
    iconBgMaterial: "",
    iconBgActiveMaterial: cls("bg-md-light-secondary-container", dark("dark:bg-md-dark-secondary-container")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/TabbarLink.svelte
var file50 = "node_modules/konsta/svelte/components/TabbarLink.svelte";
var get_label_slot_changes2 = (dirty) => ({});
var get_label_slot_context2 = (ctx) => ({});
var get_icon_slot_changes2 = (dirty) => ({});
var get_icon_slot_context2 = (ctx) => ({});
function create_if_block_117(ctx) {
  let span1;
  let span0;
  let span0_class_value;
  let t;
  let span1_class_value;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[11].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_icon_slot_context2
  );
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      t = space();
      if (icon_slot)
        icon_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t = claim_space(span1_nodes);
      if (icon_slot)
        icon_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = /*c*/
      ctx[5].iconBg);
      add_location(span0, file50, 37, 8, 1092);
      attr_dev(span1, "class", span1_class_value = /*c*/
      ctx[5].iconContainer);
      add_location(span1, file50, 36, 6, 1053);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span1, t);
      if (icon_slot) {
        icon_slot.m(span1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*c*/
      32 && span0_class_value !== (span0_class_value = /*c*/
      ctx2[5].iconBg)) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_icon_slot_changes2
            ),
            get_icon_slot_context2
          );
        }
      }
      if (!current || dirty & /*c*/
      32 && span1_class_value !== (span1_class_value = /*c*/
      ctx2[5].iconContainer)) {
        attr_dev(span1, "class", span1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(36:4) {#if hasIcon}",
    ctx
  });
  return block;
}
function create_if_block28(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  let span_class_value;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[11].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_label_slot_context2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(
        /*label*/
        ctx[2]
      );
      t1 = space();
      if (label_slot)
        label_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*label*/
        ctx[2]
      );
      t1 = claim_space(span_nodes);
      if (label_slot)
        label_slot.l(span_nodes);
      t2 = claim_space(span_nodes);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[5].label);
      add_location(span, file50, 42, 6, 1196);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
      if (label_slot) {
        label_slot.m(span, null);
      }
      append_hydration_dev(span, t2);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*label*/
      4)
        set_data_dev(
          t0,
          /*label*/
          ctx2[2]
        );
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_label_slot_changes2
            ),
            get_label_slot_context2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*c*/
      32 && span_class_value !== (span_class_value = /*c*/
      ctx2[5].label)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (label_slot)
        label_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(42:4) {#if hasLabel}",
    ctx
  });
  return block;
}
function create_default_slot15(ctx) {
  let span;
  let t;
  let span_class_value;
  let current;
  let if_block0 = (
    /*hasIcon*/
    ctx[3] && create_if_block_117(ctx)
  );
  let if_block1 = (
    /*hasLabel*/
    ctx[4] && create_if_block28(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block0)
        if_block0.l(span_nodes);
      t = claim_space(span_nodes);
      if (if_block1)
        if_block1.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*c*/
      ctx[5].content);
      add_location(span, file50, 34, 2, 1004);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_hydration_dev(span, t);
      if (if_block1)
        if_block1.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasIcon*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*hasIcon*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_117(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*hasLabel*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*hasLabel*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block28(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*c*/
      32 && span_class_value !== (span_class_value = /*c*/
      ctx2[5].content)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: "(34:0) <Link tabbar tabbarActive={active} class={className} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let link;
  let current;
  const link_spread_levels = [
    { tabbar: true },
    { tabbarActive: (
      /*active*/
      ctx[1]
    ) },
    { class: (
      /*className*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let link_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i = 0; i < link_spread_levels.length; i += 1) {
    link_props = assign(link_props, link_spread_levels[i]);
  }
  link = new Link_default({ props: link_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(link.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const link_changes = dirty & /*active, className, $$restProps*/
      67 ? get_spread_update(link_spread_levels, [
        link_spread_levels[0],
        dirty & /*active*/
        2 && { tabbarActive: (
          /*active*/
          ctx2[1]
        ) },
        dirty & /*className*/
        1 && { class: (
          /*className*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]) : {};
      if (dirty & /*$$scope, c, label, hasLabel, hasIcon*/
      4156) {
        link_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  let colors;
  let hasIcon;
  let hasLabel;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "active", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabbarLink", slots, ["icon", "label", "default"]);
  const $$slots = compute_slots(slots);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { active = false } = $$props;
  let { label = void 0 } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(7, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(9, material = $$new_props.material);
    if ("active" in $$new_props)
      $$invalidate(1, active = $$new_props.active);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    TabbarLinkClasses,
    TabbarLinkColors,
    useThemeClasses,
    useDarkClasses,
    Link: Link_default,
    className,
    colorsProp,
    ios,
    material,
    active,
    label,
    dark,
    c,
    colors,
    hasIcon,
    hasLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(7, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(8, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(9, material = $$new_props.material);
    if ("active" in $$props)
      $$invalidate(1, active = $$new_props.active);
    if ("label" in $$props)
      $$invalidate(2, label = $$new_props.label);
    if ("c" in $$props)
      $$invalidate(5, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(10, colors = $$new_props.colors);
    if ("hasIcon" in $$props)
      $$invalidate(3, hasIcon = $$new_props.hasIcon);
    if ("hasLabel" in $$props)
      $$invalidate(4, hasLabel = $$new_props.hasLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    128) {
      $:
        $$invalidate(10, colors = TabbarLinkColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*label*/
    4) {
      $:
        $$invalidate(4, hasLabel = label || $$slots.label || $$slots.default);
    }
    if ($$self.$$.dirty & /*ios, material, hasLabel, hasIcon, active, colors*/
    1818) {
      $:
        $$invalidate(5, c = useThemeClasses({ ios, material }, TabbarLinkClasses({ hasLabel, hasIcon, active }, colors), "", (v) => $$invalidate(5, c = v)));
    }
  };
  $:
    $$invalidate(3, hasIcon = $$slots.icon);
  return [
    className,
    active,
    label,
    hasIcon,
    hasLabel,
    c,
    $$restProps,
    colorsProp,
    ios,
    material,
    colors,
    slots,
    $$scope
  ];
}
var TabbarLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, {
      class: 0,
      colors: 7,
      ios: 8,
      material: 9,
      active: 1,
      label: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabbarLink",
      options,
      id: create_fragment55.name
    });
  }
  get class() {
    throw new Error("<TabbarLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabbarLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<TabbarLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<TabbarLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<TabbarLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<TabbarLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<TabbarLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<TabbarLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabbarLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabbarLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<TabbarLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<TabbarLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabbarLink_default = TabbarLink;

// node_modules/konsta/shared/esm/classes/ToastClasses.js
var ToastClasses = (props, colors, classes) => {
  const {
    translucent,
    opened
  } = props;
  return {
    base: {
      common: cls(positionClass("fixed", classes), "z-50 transform transition-transform-opacity w-full sm:w-auto left-0 bottom-0 sm:max-w-lg", !opened && "translate-y-full opacity-0 pointer-events-none"),
      ios: cls(`sm:rounded-lg duration-300`, colors.textIos, colors.bgIos, translucent && "translucent"),
      material: cls(`sm:rounded-2xl duration-200`, colors.textMaterial, colors.bgMaterial),
      left: "sm:left-4-safe sm:bottom-4-safe",
      right: "sm:right-4-safe sm:bottom-4-safe sm:left-auto",
      center: "sm:left-1/2 sm:bottom-4-safe sm:-translate-x-1/2"
    },
    content: {
      common: "flex items-center justify-between",
      ios: "pl-4-safe pr-4-safe pt-3 pb-3-safe sm:px-4 sm:py-3",
      material: "pl-6-safe pr-6-safe py-3.5 pb-3.5-safe sm:px-6 sm:py-3.5"
    },
    button: {
      common: "-my-2 shrink-0 ml-4",
      ios: "",
      material: "-mr-2"
    }
  };
};

// node_modules/konsta/shared/esm/colors/ToastColors.js
var ToastColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: "bg-black",
    bgMaterial: cls("bg-md-light-surface-5", dark("dark:bg-md-dark-surface-5")),
    textIos: "text-white",
    textMaterial: cls("text-md-light-primary", dark("dark:text-md-dark-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Toast.svelte
var file51 = "node_modules/konsta/svelte/components/Toast.svelte";
var get_button_slot_changes = (dirty) => ({});
var get_button_slot_context = (ctx) => ({});
function create_if_block29(ctx) {
  let div;
  let div_class_value;
  let current;
  const button_slot_template = (
    /*#slots*/
    ctx[12].button
  );
  const button_slot = create_slot(
    button_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_button_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (button_slot)
        button_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (button_slot)
        button_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*c*/
      ctx[1].button);
      add_location(div, file51, 33, 6, 938);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (button_slot) {
        button_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (button_slot) {
        if (button_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            button_slot,
            button_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              button_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_button_slot_changes
            ),
            get_button_slot_context
          );
        }
      }
      if (!current || dirty & /*c*/
      2 && div_class_value !== (div_class_value = /*c*/
      ctx2[1].button)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (button_slot)
        button_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(33:4) {#if $$slots.button}",
    ctx
  });
  return block;
}
function create_fragment56(ctx) {
  let div1;
  let div0;
  let t;
  let div0_class_value;
  let div1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let if_block = (
    /*$$slots*/
    ctx[3].button && create_if_block29(ctx)
  );
  let div1_levels = [
    {
      class: div1_class_value = /*c*/
      ctx[1].base[
        /*position*/
        ctx[0]
      ]
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      t = claim_space(div0_nodes);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*c*/
      ctx[1].content);
      add_location(div0, file51, 30, 2, 870);
      set_attributes(div1, div1_data);
      add_location(div1, file51, 29, 0, 820);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div0, t);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*$$slots*/
        ctx2[3].button
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block29(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*c*/
      2 && div0_class_value !== (div0_class_value = /*c*/
      ctx2[1].content)) {
        attr_dev(div0, "class", div0_class_value);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty & /*c, position*/
        3 && div1_class_value !== (div1_class_value = /*c*/
        ctx2[1].base[
          /*position*/
          ctx2[0]
        ])) && { class: div1_class_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let colors;
  let c;
  const omit_props_names = ["class", "colors", "ios", "material", "translucent", "position", "opened"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toast", slots, ["default", "button"]);
  const $$slots = compute_slots(slots);
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { translucent = true } = $$props;
  let { position = "left" } = $$props;
  let { opened = false } = $$props;
  const dark = useDarkClasses();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(5, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(6, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(7, material = $$new_props.material);
    if ("translucent" in $$new_props)
      $$invalidate(8, translucent = $$new_props.translucent);
    if ("position" in $$new_props)
      $$invalidate(0, position = $$new_props.position);
    if ("opened" in $$new_props)
      $$invalidate(9, opened = $$new_props.opened);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ToastClasses,
    ToastColors,
    useThemeClasses,
    useDarkClasses,
    className,
    colorsProp,
    ios,
    material,
    translucent,
    position,
    opened,
    dark,
    c,
    colors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(5, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(6, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(7, material = $$new_props.material);
    if ("translucent" in $$props)
      $$invalidate(8, translucent = $$new_props.translucent);
    if ("position" in $$props)
      $$invalidate(0, position = $$new_props.position);
    if ("opened" in $$props)
      $$invalidate(9, opened = $$new_props.opened);
    if ("c" in $$props)
      $$invalidate(1, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(10, colors = $$new_props.colors);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    32) {
      $:
        $$invalidate(10, colors = ToastColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*ios, material, opened, translucent, colors, className*/
    2e3) {
      $:
        $$invalidate(1, c = useThemeClasses({ ios, material }, ToastClasses({ opened, translucent }, colors, className), className, (v) => $$invalidate(1, c = v)));
    }
  };
  return [
    position,
    c,
    $$restProps,
    $$slots,
    className,
    colorsProp,
    ios,
    material,
    translucent,
    opened,
    colors,
    $$scope,
    slots
  ];
}
var Toast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, {
      class: 4,
      colors: 5,
      ios: 6,
      material: 7,
      translucent: 8,
      position: 0,
      opened: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toast",
      options,
      id: create_fragment56.name
    });
  }
  get class() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translucent() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translucent(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toast_default = Toast;

// node_modules/konsta/shared/esm/classes/ToggleClasses.js
var ToggleClasses = (props, colors, classes, dark) => {
  return {
    base: {
      common: cls(positionClass("relative", classes), `cursor-pointer select-none inline-block align-middle relative duration-300 rounded-full group`, dark("dark:touch-ripple-white")),
      ios: "h-8 w-13 p-0.5",
      material: "w-13 h-8 border-2",
      notChecked: {
        ios: colors.bgIos,
        material: cls(colors.bgMaterial, colors.borderMaterial)
      },
      checked: {
        ios: `${colors.checkedBgIos}`,
        material: cls(colors.checkedBgMaterial, colors.checkedBorderMaterial)
      }
    },
    inner: {
      ios: cls("w-full h-full bg-white rounded-full block duration-300 transform", dark("dark:bg-opacity-0")),
      notChecked: {},
      checked: {
        ios: "scale-0"
      }
    },
    thumbWrap: {
      common: "rounded-full absolute duration-300 transform",
      ios: "w-7 h-7 left-0.5 top-0.5",
      material: "w-6 h-6 left-0.5 top-0.5",
      checked: {
        ios: cls("translate-x-5"),
        material: cls(`translate-x-5`)
      },
      notChecked: ""
    },
    thumb: {
      common: "w-full h-full rounded-full absolute duration-300 transform left-0 top-0",
      ios: "shadow-ios-toggle",
      material: "group-active:scale-[1.1]",
      checked: {
        ios: cls(colors.checkedThumbBgIos),
        material: cls(colors.checkedThumbBgMaterial)
      },
      notChecked: {
        ios: colors.thumbBgIos,
        material: cls("scale-[0.666]", colors.thumbBgMaterial)
      }
    },
    input: {
      common: "hidden"
    }
  };
};

// node_modules/konsta/shared/esm/colors/ToggleColors.js
var ToggleColors = function(colorsProp, dark) {
  if (colorsProp === void 0) {
    colorsProp = {};
  }
  return {
    bgIos: cls("bg-black bg-opacity-10", dark("dark:bg-white dark:bg-opacity-20")),
    checkedBgIos: "bg-primary",
    thumbBgIos: "bg-white",
    checkedThumbBgIos: "bg-white",
    bgMaterial: cls("bg-md-light-surface-variant", dark("dark:bg-md-dark-surface-variant")),
    checkedBgMaterial: cls("bg-md-light-primary", dark("dark:bg-md-dark-primary")),
    borderMaterial: cls("border-md-light-outline", dark("dark:border-md-dark-outline")),
    checkedBorderMaterial: cls("border-md-light-primary", dark("dark:border-md-dark-primary")),
    thumbBgMaterial: cls("bg-md-light-outline", dark("dark:bg-md-dark-outline")),
    checkedThumbBgMaterial: cls("bg-md-light-on-primary", dark("dark:bg-md-dark-on-primary")),
    ...colorsProp
  };
};

// node_modules/konsta/svelte/components/Toggle.svelte
var file52 = "node_modules/konsta/svelte/components/Toggle.svelte";
function create_dynamic_element13(ctx) {
  let svelte_element;
  let input;
  let input_class_value;
  let t0;
  let span0;
  let span0_class_value;
  let t1;
  let span2;
  let span1;
  let span1_class_value;
  let span2_class_value;
  let t2;
  let svelte_element_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*c*/
      ctx[9].base[
        /*state*/
        ctx[10]
      ]
    },
    /*$$restProps*/
    ctx[11]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*component*/
        ctx[2]
      );
      input = element("input");
      t0 = space();
      span0 = element("span");
      t1 = space();
      span2 = element("span");
      span1 = element("span");
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*component*/
        (ctx[2] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      input = claim_element(svelte_element_nodes, "INPUT", { type: true, name: true, class: true });
      t0 = claim_space(svelte_element_nodes);
      span0 = claim_element(svelte_element_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t1 = claim_space(svelte_element_nodes);
      span2 = claim_element(svelte_element_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      span1 = claim_element(span2_nodes, "SPAN", { class: true });
      children(span1).forEach(detach_dev);
      span2_nodes.forEach(detach_dev);
      t2 = claim_space(svelte_element_nodes);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[4]
      );
      input.value = /*value*/
      ctx[5];
      input.disabled = /*disabled*/
      ctx[6];
      input.readOnly = /*readonly*/
      ctx[7];
      input.checked = /*checked*/
      ctx[3];
      attr_dev(input, "class", input_class_value = /*c*/
      ctx[9].input);
      add_location(input, file52, 49, 2, 1352);
      attr_dev(span0, "class", span0_class_value = /*c*/
      ctx[9].inner[
        /*state*/
        ctx[10]
      ]);
      add_location(span0, file52, 59, 2, 1498);
      attr_dev(span1, "class", span1_class_value = /*c*/
      ctx[9].thumb[
        /*state*/
        ctx[10]
      ]);
      add_location(span1, file52, 61, 4, 1608);
      attr_dev(span2, "class", span2_class_value = /*c*/
      ctx[9].thumbWrap[
        /*state*/
        ctx[10]
      ]);
      add_location(span2, file52, 60, 2, 1532);
      if (/-/.test(
        /*component*/
        ctx[2]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file52, 43, 0, 1242);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, input);
      append_hydration_dev(svelte_element, t0);
      append_hydration_dev(svelte_element, span0);
      append_hydration_dev(svelte_element, t1);
      append_hydration_dev(svelte_element, span2);
      append_hydration_dev(span2, span1);
      ctx[20](span2);
      append_hydration_dev(svelte_element, t2);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[21](svelte_element);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          function() {
            if (is_function(
              /*onChange*/
              ctx[8]
            ))
              ctx[8].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*name*/
      16) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx[4]
        );
      }
      if (!current || dirty & /*value*/
      32) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx[5]
        );
      }
      if (!current || dirty & /*disabled*/
      64) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx[6]
        );
      }
      if (!current || dirty & /*readonly*/
      128) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx[7]
        );
      }
      if (!current || dirty & /*checked*/
      8) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx[3]
        );
      }
      if (!current || dirty & /*c*/
      512 && input_class_value !== (input_class_value = /*c*/
      ctx[9].input)) {
        attr_dev(input, "class", input_class_value);
      }
      if (!current || dirty & /*c, state*/
      1536 && span0_class_value !== (span0_class_value = /*c*/
      ctx[9].inner[
        /*state*/
        ctx[10]
      ])) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (!current || dirty & /*c, state*/
      1536 && span1_class_value !== (span1_class_value = /*c*/
      ctx[9].thumb[
        /*state*/
        ctx[10]
      ])) {
        attr_dev(span1, "class", span1_class_value);
      }
      if (!current || dirty & /*c, state*/
      1536 && span2_class_value !== (span2_class_value = /*c*/
      ctx[9].thumbWrap[
        /*state*/
        ctx[10]
      ])) {
        attr_dev(span2, "class", span2_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*c, state*/
        1536 && svelte_element_class_value !== (svelte_element_class_value = /*c*/
        ctx[9].base[
          /*state*/
          ctx[10]
        ])) && { class: svelte_element_class_value },
        dirty & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx[11]
      ]);
      if (/-/.test(
        /*component*/
        ctx[2]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      ctx[20](null);
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element13.name,
    type: "child_dynamic_element",
    source: "(44:0) <svelte:element   this={component}   bind:this={elRef.current}   class={c.base[state]}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let previous_tag = (
    /*component*/
    ctx[2]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*component*/
    ctx[2]
  );
  validate_void_dynamic_element(
    /*component*/
    ctx[2]
  );
  let svelte_element = (
    /*component*/
    ctx[2] && create_dynamic_element13(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*component*/
        ctx2[2]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element13(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*component*/
          ctx2[2]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*component*/
            ctx2[2]
          );
          validate_void_dynamic_element(
            /*component*/
            ctx2[2]
          );
          svelte_element = create_dynamic_element13(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*component*/
      ctx2[2];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  let colors;
  let state;
  let c;
  const omit_props_names = [
    "component",
    "elRef",
    "rippleTargetElRef",
    "class",
    "colors",
    "ios",
    "material",
    "checked",
    "name",
    "value",
    "disabled",
    "readonly",
    "onChange",
    "touchRipple"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toggle", slots, ["default"]);
  let { component = "label" } = $$props;
  let { elRef = { current: null } } = $$props;
  let { rippleTargetElRef = { current: null } } = $$props;
  let { class: className = void 0 } = $$props;
  let { colors: colorsProp = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { checked = false } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { readonly = false } = $$props;
  let { onChange = void 0 } = $$props;
  let { touchRipple = true } = $$props;
  const dark = useDarkClasses();
  useTouchRipple(rippleTargetElRef, touchRipple, elRef);
  function span2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleTargetElRef.current = $$value;
      $$invalidate(1, rippleTargetElRef);
    });
  }
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elRef.current = $$value;
      $$invalidate(0, elRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("component" in $$new_props)
      $$invalidate(2, component = $$new_props.component);
    if ("elRef" in $$new_props)
      $$invalidate(0, elRef = $$new_props.elRef);
    if ("rippleTargetElRef" in $$new_props)
      $$invalidate(1, rippleTargetElRef = $$new_props.rippleTargetElRef);
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("colors" in $$new_props)
      $$invalidate(13, colorsProp = $$new_props.colors);
    if ("ios" in $$new_props)
      $$invalidate(14, ios = $$new_props.ios);
    if ("material" in $$new_props)
      $$invalidate(15, material = $$new_props.material);
    if ("checked" in $$new_props)
      $$invalidate(3, checked = $$new_props.checked);
    if ("name" in $$new_props)
      $$invalidate(4, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(5, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props)
      $$invalidate(7, readonly = $$new_props.readonly);
    if ("onChange" in $$new_props)
      $$invalidate(8, onChange = $$new_props.onChange);
    if ("touchRipple" in $$new_props)
      $$invalidate(16, touchRipple = $$new_props.touchRipple);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ToggleClasses,
    ToggleColors,
    useDarkClasses,
    useThemeClasses,
    useTouchRipple,
    component,
    elRef,
    rippleTargetElRef,
    className,
    colorsProp,
    ios,
    material,
    checked,
    name,
    value,
    disabled,
    readonly,
    onChange,
    touchRipple,
    dark,
    c,
    colors,
    state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("component" in $$props)
      $$invalidate(2, component = $$new_props.component);
    if ("elRef" in $$props)
      $$invalidate(0, elRef = $$new_props.elRef);
    if ("rippleTargetElRef" in $$props)
      $$invalidate(1, rippleTargetElRef = $$new_props.rippleTargetElRef);
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("colorsProp" in $$props)
      $$invalidate(13, colorsProp = $$new_props.colorsProp);
    if ("ios" in $$props)
      $$invalidate(14, ios = $$new_props.ios);
    if ("material" in $$props)
      $$invalidate(15, material = $$new_props.material);
    if ("checked" in $$props)
      $$invalidate(3, checked = $$new_props.checked);
    if ("name" in $$props)
      $$invalidate(4, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(5, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("readonly" in $$props)
      $$invalidate(7, readonly = $$new_props.readonly);
    if ("onChange" in $$props)
      $$invalidate(8, onChange = $$new_props.onChange);
    if ("touchRipple" in $$props)
      $$invalidate(16, touchRipple = $$new_props.touchRipple);
    if ("c" in $$props)
      $$invalidate(9, c = $$new_props.c);
    if ("colors" in $$props)
      $$invalidate(17, colors = $$new_props.colors);
    if ("state" in $$props)
      $$invalidate(10, state = $$new_props.state);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorsProp*/
    8192) {
      $:
        $$invalidate(17, colors = ToggleColors(colorsProp, dark));
    }
    if ($$self.$$.dirty & /*checked*/
    8) {
      $:
        $$invalidate(10, state = checked ? "checked" : "notChecked");
    }
    if ($$self.$$.dirty & /*ios, material, colors, className*/
    184320) {
      $:
        $$invalidate(9, c = useThemeClasses({ ios, material }, ToggleClasses({}, colors, className, dark), className, (v) => $$invalidate(9, c = v)));
    }
  };
  return [
    elRef,
    rippleTargetElRef,
    component,
    checked,
    name,
    value,
    disabled,
    readonly,
    onChange,
    c,
    state,
    $$restProps,
    className,
    colorsProp,
    ios,
    material,
    touchRipple,
    colors,
    $$scope,
    slots,
    span2_binding,
    svelte_element_binding
  ];
}
var Toggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {
      component: 2,
      elRef: 0,
      rippleTargetElRef: 1,
      class: 12,
      colors: 13,
      ios: 14,
      material: 15,
      checked: 3,
      name: 4,
      value: 5,
      disabled: 6,
      readonly: 7,
      onChange: 8,
      touchRipple: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toggle",
      options,
      id: create_fragment57.name
    });
  }
  get component() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get elRef() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elRef(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rippleTargetElRef() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rippleTargetElRef(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colors() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colors(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touchRipple() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touchRipple(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toggle_default = Toggle;
export {
  Actions_default as Actions,
  ActionsButton_default as ActionsButton,
  ActionsGroup_default as ActionsGroup,
  ActionsLabel_default as ActionsLabel,
  App_default as App,
  Badge_default as Badge,
  Block_default as Block,
  BlockFooter_default as BlockFooter,
  BlockHeader_default as BlockHeader,
  BlockTitle_default as BlockTitle,
  Breadcrumbs_default as Breadcrumbs,
  BreadcrumbsCollapsed_default as BreadcrumbsCollapsed,
  BreadcrumbsItem_default as BreadcrumbsItem,
  BreadcrumbsSeparator_default as BreadcrumbsSeparator,
  Button_default as Button,
  Card_default as Card,
  Checkbox_default as Checkbox,
  Chip_default as Chip,
  Dialog_default as Dialog,
  DialogButton_default as DialogButton,
  Fab_default as Fab,
  Icon_default as Icon,
  KonstaProvider_default as KonstaProvider,
  Link_default as Link,
  List_default as List,
  ListButton_default as ListButton,
  ListGroup_default as ListGroup,
  ListInput_default as ListInput,
  ListItem_default as ListItem,
  MenuList_default as MenuList,
  MenuListItem_default as MenuListItem,
  Navbar_default as Navbar,
  NavbarBackLink_default as NavbarBackLink,
  Page_default as Page,
  Panel_default as Panel,
  Popover_default as Popover,
  Popup_default as Popup,
  Preloader_default as Preloader,
  Progressbar_default as Progressbar,
  Radio_default as Radio,
  Range_default as Range,
  Segmented_default as Segmented,
  SegmentedButton_default as SegmentedButton,
  Sheet_default as Sheet,
  Stepper_default as Stepper,
  Tabbar_default as Tabbar,
  TabbarLink_default as TabbarLink,
  Toast_default as Toast,
  Toggle_default as Toggle,
  Toolbar_default as Toolbar,
  useTheme
};
//# sourceMappingURL=konsta_svelte.js.map
